C51 COMPILER V9.53.0.0   COMPATIBILITYHID                                                  01/02/2018 15:19:33 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE COMPATIBILITYHID
OBJECT MODULE PLACED IN CompatibilityHID.obj
COMPILER INVOKED BY: D:\Keil\Install\C51\BIN\C51.EXE USB\Device\CompatibilityHID.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG 
                    -OBJECTEXTEND PRINT(.\CompatibilityHID.lst) OBJECT(CompatibilityHID.obj)

line level    source

   1          
   2          /********************************** (C) COPYRIGHT *******************************
   3          * File Name          :CompatibilityHID.C
   4          * Author             : WCH
   5          * Version            : V1.0
   6          * Date               : 2017/01/20
   7          * Description        : CH554ƒ£ƒ‚HIDºÊ»›…Ë±∏£¨÷ß≥÷÷–∂œ…œœ¬¥´£¨÷ß≥÷…Ë÷√»´ÀŸ£¨µÕÀŸ 
   8          *******************************************************************************/
   9          
  10          #include "./Public/CH554.H"
  11          #include "./Public/Debug.H"
  12          #include <stdio.h>
  13          #include <string.h>
  14          
  15          //#define Fullspeed               1
  16          #ifdef  Fullspeed
              #define THIS_ENDP0_SIZE         64
              #else
  19          #define THIS_ENDP0_SIZE         DEFAULT_ENDP0_SIZE
  20          #endif
  21          UINT8X  Ep0Buffer[8<(THIS_ENDP0_SIZE+2)?8:(THIS_ENDP0_SIZE+2)] _at_ 0x0000;        //∂Àµ„0 OUT&INª∫≥Â«¯£¨±
             -ÿ–Î «≈ºµÿ÷∑
  22          UINT8X  Ep2Buffer[128<(2*MAX_PACKET_SIZE+4)?128:(2*MAX_PACKET_SIZE+4)] _at_ 0x0044;//∂Àµ„2 IN&OUTª∫≥Â«¯,±ÿ
             -–Î «≈ºµÿ÷∑
  23          UINT8   SetupReq,SetupLen,Ready,Count,FLAG,UsbConfig;
  24          PUINT8  pDescr;                                                                    //USB≈‰÷√±Í÷æ
  25          USB_SETUP_REQ   SetupReqBuf;                                                       //‘›¥ÊSetup∞¸
  26          #define UsbSetupBuf     ((PUSB_SETUP_REQ)Ep0Buffer)  
  27          
  28          sbit Ep2InKey = P1^5;                                                              //K1∞¥º¸
  29          #pragma  NOAREGS
  30          /*…Ë±∏√Ë ˆ∑˚*/
  31          UINT8C DevDesc[18] = {0x12,0x01,0x10,0x01,0x00,0x00,0x00,THIS_ENDP0_SIZE,
  32                                0x33,0x52,0x07,0x20,0x00,0x00,0x00,0x00,
  33                                0x00,0x01
  34                               };
  35          UINT8C CfgDesc[41] =
  36          {
  37              0x09,0x02,0x29,0x00,0x01,0x01,0x04,0xA0,0x23,               //≈‰÷√√Ë ˆ∑˚
  38              0x09,0x04,0x00,0x00,0x02,0x03,0x00,0x00,0x05,               //Ω”ø⁄√Ë ˆ∑˚
  39              0x09,0x21,0x00,0x01,0x00,0x01,0x22,0x22,0x00,               //HID¿‡√Ë ˆ∑˚
  40              0x07,0x05,0x82,0x03,THIS_ENDP0_SIZE,0x00,0x18,              //∂Àµ„√Ë ˆ∑˚
  41              0x07,0x05,0x02,0x03,THIS_ENDP0_SIZE,0x00,0x18,              //∂Àµ„√Ë ˆ∑˚
  42          };
  43          /*◊÷∑˚¥Æ√Ë ˆ∑˚ ¬‘*/ 
  44          
  45          /*HID¿‡±®±Ì√Ë ˆ∑˚*/
  46          UINT8C HIDRepDesc[ ] =
  47          {
  48              0x06, 0x00,0xff,
  49              0x09, 0x01,
  50              0xa1, 0x01,                                                   //ºØ∫œø™ º
  51              0x09, 0x02,                                                   //Usage Page  ”√∑®
  52              0x15, 0x00,                                                   //Logical  Minimun
C51 COMPILER V9.53.0.0   COMPATIBILITYHID                                                  01/02/2018 15:19:33 PAGE 2   

  53              0x26, 0x00,0xff,                                              //Logical  Maximun
  54              0x75, 0x08,                                                   //Report Size
  55              0x95, THIS_ENDP0_SIZE,                                        //Report Counet
  56              0x81, 0x06,                                                   //Input
  57              0x09, 0x02,                                                   //Usage Page  ”√∑®
  58              0x15, 0x00,                                                   //Logical  Minimun
  59              0x26, 0x00,0xff,                                              //Logical  Maximun
  60              0x75, 0x08,                                                   //Report Size
  61              0x95, THIS_ENDP0_SIZE,                                        //Report Counet
  62              0x91, 0x06,                                                   //Output
  63              0xC0
  64          };
  65          // unsigned char  code LangDes[]={0x04,0x03,0x09,0x04};           //”Ô—‘√Ë ˆ∑˚
  66          // unsigned char  code SerDes[]={
  67          //                           0x28,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  68          //                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  69          //                           0x00,0x00,0x00,0x00,0x00,0x49,0x00,0x43,0x00,0x42,
  70          //                           0x00,0x43,0x00,0x31,0x00,0x00,0x00,0x00,0x00,0x00
  71          //                           };                                   //◊÷∑˚¥Æ√Ë ˆ∑˚
  72          
  73          UINT8X UserEp2Buf[64];                                            //”√ªß ˝æ›∂®“Â
  74          
  75          /*******************************************************************************
  76          * Function Name  : USBDeviceInit()
  77          * Description    : USB…Ë±∏ƒ£ Ω≈‰÷√,…Ë±∏ƒ£ Ω∆Ù∂Ø£¨ ’∑¢∂Àµ„≈‰÷√£¨÷–∂œø™∆Ù
  78          * Input          : None
  79          * Output         : None
  80          * Return         : None
  81          *******************************************************************************/
  82          void USBDeviceInit()
  83          {
  84   1                IE_USB = 0;
  85   1                USB_CTRL = 0x00;                                                           // œ»…Ë∂®USB…Ë±∏ƒ£ Ω
  86   1      //#ifndef Fullspeed
  87   1      //    UDEV_CTRL |= bUD_LOW_SPEED;                                                //—°‘ÒµÕÀŸ1.5Mƒ£ Ω
  88   1      //#else
  89   1      //    UDEV_CTRL &= ~bUD_LOW_SPEED;                                               //—°‘Ò»´ÀŸ12Mƒ£ Ω£¨ƒ¨»œ∑Ω
             - Ω
  90   1      //#endif
  91   1          UEP2_DMA = Ep2Buffer;                                                      //∂Àµ„2 ˝æ›¥´ ‰µÿ÷∑
  92   1          UEP2_3_MOD |= bUEP2_TX_EN;                                                 //∂Àµ„2∑¢ÀÕ πƒ‹
  93   1          UEP2_3_MOD |= bUEP2_RX_EN;                                                 //∂Àµ„2Ω” ’ πƒ‹
  94   1          UEP2_3_MOD &= ~bUEP2_BUF_MOD;                                              //∂Àµ„2 ’∑¢∏˜64◊÷Ω⁄ª∫≥Â«¯
  95   1          UEP2_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK | UEP_R_RES_ACK;                 //∂Àµ„2◊‘∂Ø∑≠◊™Õ¨≤Ω±Í÷æŒª£¨
             -IN ¬ŒÒ∑µªÿNAK£¨OUT∑µªÿACK
  96   1          UEP0_DMA = Ep0Buffer;                                                      //∂Àµ„0 ˝æ›¥´ ‰µÿ÷∑
  97   1          UEP4_1_MOD &= ~(bUEP4_RX_EN | bUEP4_TX_EN);                                //∂Àµ„0µ•64◊÷Ω⁄ ’∑¢ª∫≥Â«¯
  98   1          UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;                                 //OUT ¬ŒÒ∑µªÿACK£¨IN ¬ŒÒ∑µª
             -ÿNAK        
  99   1              USB_DEV_AD = 0x00;
 100   1              
 101   1              USB_CTRL |= bUC_LOW_SPEED; 
 102   1              UDEV_CTRL |= bUD_LOW_SPEED;             /* µÕÀŸ */
 103   1              UDEV_CTRL |= bUD_PORT_EN | bUD_PD_DIS;          /* Ω˚÷πDP/DMœ¬¿≠µÁ◊Ë */
 104   1              USB_CTRL |= bUC_DEV_PU_EN | bUC_INT_BUSY | bUC_DMA_EN;          /* ∆Ù∂ØUSB…Ë±∏º∞DMA£¨‘⁄÷–∂œ∆⁄º‰÷–∂œ±Í÷æŒ¥«Â≥˝«∞◊‘
             -∂Ø∑µªÿNAK */
 105   1                           // ∆Ù∂ØUSB…Ë±∏º∞DMA£¨‘⁄÷–∂œ∆⁄º‰÷–∂œ±Í÷æŒ¥«Â≥˝«∞◊‘∂Ø∑µªÿNAK
 106   1                                                                 // ‘ –ÌUSB∂Àø⁄
 107   1                USB_INT_FG = 0xFF;                                                         // «Â÷–∂œ±Í÷æ
 108   1                USB_INT_EN = bUIE_SUSPEND | bUIE_TRANSFER | bUIE_BUS_RST;
 109   1                IE_USB = 1;
 110   1      }
C51 COMPILER V9.53.0.0   COMPATIBILITYHID                                                  01/02/2018 15:19:33 PAGE 3   

 111          
 112          /*******************************************************************************
 113          * Function Name  : Enp2BlukIn()
 114          * Description    : USB…Ë±∏ƒ£ Ω∂Àµ„2µƒ≈˙¡ø…œ¥´
 115          * Input          : None
 116          * Output         : None
 117          * Return         : None
 118          *******************************************************************************/
 119          void Enp2BlukIn( )
 120          {
 121   1          memcpy( Ep2Buffer+MAX_PACKET_SIZE, UserEp2Buf, sizeof(UserEp2Buf));        //º”‘ÿ…œ¥´ ˝æ›
 122   1          UEP2_T_LEN = THIS_ENDP0_SIZE;                                              //…œ¥´◊Ó¥Û∞¸≥§∂»
 123   1          UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK;                  //”– ˝æ› ±…œ¥´ ˝æ›≤¢”¶¥ACK
 124   1          while(UEP2_CTRL&UEP_T_RES_ACK);                                            //µ»¥˝¥´ ‰ÕÍ≥…
 125   1      }
 126          
 127          /*******************************************************************************
 128          * Function Name  : DeviceInterrupt()
 129          * Description    : CH559USB÷–∂œ¥¶¿Ì∫Ø ˝
 130          *******************************************************************************/
 131          void    DeviceInterrupt( void ) interrupt INT_NO_USB using 1                    //USB÷–∂œ∑˛ŒÒ≥Ã–Ú, π”√ºƒ¥Ê
             -∆˜◊È1
 132          {
 133   1          UINT8 len,i;
 134   1          if(UIF_TRANSFER)                                                            //USB¥´ ‰ÕÍ≥…±Í÷æ
 135   1          {
 136   2              switch (USB_INT_ST & (MASK_UIS_TOKEN | MASK_UIS_ENDP))
 137   2              {
 138   3              case UIS_TOKEN_IN | 2:                                                  //endpoint 2# ∂Àµ„≈˙¡ø…œ¥´
 139   3                   UEP2_T_LEN = 0;                                                    //‘§ π”√∑¢ÀÕ≥§∂»“ª∂®“™«Âø’
 140   3      //            UEP1_CTRL ^= bUEP_T_TOG;                                          //»Áπ˚≤ª…Ë÷√◊‘∂Ø∑≠◊™‘Ú–Ë“™
             - ÷∂Ø∑≠◊™
 141   3                  UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;           //ƒ¨»œ”¶¥NAK
 142   3                  break;
 143   3              case UIS_TOKEN_OUT | 2:                                                 //endpoint 2# ∂Àµ„≈˙¡øœ¬¥´
 144   3                  if ( U_TOG_OK )                                                     // ≤ªÕ¨≤Ωµƒ ˝æ›∞¸Ω´∂™∆˙
 145   3                  {
 146   4                      len = USB_RX_LEN;                                               //Ω” ’ ˝æ›≥§∂»£¨ ˝æ›¥”Ep2B
             -uffer ◊µÿ÷∑ø™ º¥Ê∑≈
 147   4                      for ( i = 0; i < len; i ++ )
 148   4                      {
 149   5      //                    Ep2Buffer[MAX_PACKET_SIZE+i] = Ep2Buffer[i] ^ 0xFF;         // OUT ˝æ›»°∑¥µΩIN”…º∆À„
             -ª˙—È÷§
 150   5                                              Ep2Buffer[MAX_PACKET_SIZE+i] = Ep2Buffer[i];
 151   5                      }
 152   4                      UEP2_T_LEN = len;
 153   4                      UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK;       // ‘ –Ì…œ¥´
 154   4                  }
 155   3                  break;
 156   3              case UIS_TOKEN_SETUP | 0:                                               //SETUP ¬ŒÒ
 157   3                  len = USB_RX_LEN;
 158   3                  if(len == (sizeof(USB_SETUP_REQ)))
 159   3                  {
 160   4                      SetupLen = UsbSetupBuf->wLengthL;
 161   4                      if(UsbSetupBuf->wLengthH || SetupLen > 0x7F )
 162   4                      {
 163   5                          SetupLen = 0x7F;                                             // œﬁ÷∆◊‹≥§∂»
 164   5                      }
 165   4                      len = 0;                                                         // ƒ¨»œŒ™≥…π¶≤¢«“…œ¥´0≥§∂
             -»
 166   4                      SetupReq = UsbSetupBuf->bRequest;                                                       
 167   4                      if ( ( UsbSetupBuf->bRequestType & USB_REQ_TYP_MASK ) != USB_REQ_TYP_STANDARD )/*HID¿‡√¸¡Ó
C51 COMPILER V9.53.0.0   COMPATIBILITYHID                                                  01/02/2018 15:19:33 PAGE 4   

             -*/
 168   4                      {
 169   5                                                                              switch( SetupReq )                                             
 170   5                                                                              {
 171   6                                                                                      case 0x01:                                                   //GetReport
 172   6                                                                                                       break;
 173   6                                                                                      case 0x02:                                                   //GetIdle
 174   6                                                                                                       break; 
 175   6                                                                                      case 0x03:                                                   //GetProtocol
 176   6                                                                                                       break;                         
 177   6                                                                                      case 0x09:                                                   //SetReport                                                                                
 178   6                                                                                                       break;
 179   6                                                                                      case 0x0A:                                                   //SetIdle
 180   6                                                                                                       break; 
 181   6                                                                                      case 0x0B:                                                   //SetProtocol
 182   6                                                                                                       break;
 183   6                                                                                      default:
 184   6                                                                                                       len = 0xFF;                                                               /*√¸¡Ó≤ª÷ß≥÷*/                                       
 185   6                                                                                                       break;
 186   6                                                                        }             
 187   5                      }
 188   4                      else                                                             //±Í◊º«Î«Û
 189   4                      {
 190   5                          switch(SetupReq)                                             //«Î«Û¬Î
 191   5                          {
 192   6                          case USB_GET_DESCRIPTOR:
 193   6                              switch(UsbSetupBuf->wValueH)
 194   6                              {
 195   7                              case 1:                                                  //…Ë±∏√Ë ˆ∑˚
 196   7                                  pDescr = DevDesc;                                    //∞—…Ë±∏√Ë ˆ∑˚ÀÕµΩ“™∑¢ÀÕµ
             -ƒª∫≥Â«¯
 197   7                                  len = sizeof(DevDesc);
 198   7                                  break;
 199   7                              case 2:                                                  //≈‰÷√√Ë ˆ∑˚
 200   7                                  pDescr = CfgDesc;                                    //∞—…Ë±∏√Ë ˆ∑˚ÀÕµΩ“™∑¢ÀÕµ
             -ƒª∫≥Â«¯
 201   7                                  len = sizeof(CfgDesc);
 202   7                                  break;
 203   7                              case 0x22:                                               //±®±Ì√Ë ˆ∑˚
 204   7                                  pDescr = HIDRepDesc;                                 // ˝æ›◊º±∏…œ¥´
 205   7                                  len = sizeof(HIDRepDesc);
 206   7                                  Ready = 1;                                           //»Áπ˚”–∏¸∂‡Ω”ø⁄£¨∏√±Í◊ºŒ
             -ª”¶∏√‘⁄◊Ó∫Û“ª∏ˆΩ”ø⁄≈‰÷√ÕÍ≥…∫Û”––ß
 207   7                                  break;
 208   7                              default:
 209   7                                  len = 0xff;                                          //≤ª÷ß≥÷µƒ√¸¡ÓªÚ’ﬂ≥ˆ¥Ì
 210   7                                  break;
 211   7                              }
 212   6                              if ( SetupLen > len )
 213   6                              {
 214   7                                  SetupLen = len;    //œﬁ÷∆◊‹≥§∂»
 215   7                              }
 216   6                              len = SetupLen >= THIS_ENDP0_SIZE ? THIS_ENDP0_SIZE : SetupLen;//±æ¥Œ¥´ ‰≥§∂»
 217   6                              memcpy(Ep0Buffer,pDescr,len);                            //º”‘ÿ…œ¥´ ˝æ›
 218   6                              SetupLen -= len;
 219   6                              pDescr += len;
 220   6                              break;
 221   6                          case USB_SET_ADDRESS:
 222   6                              SetupLen = UsbSetupBuf->wValueL;                         //‘›¥ÊUSB…Ë±∏µÿ÷∑
 223   6                              break;
 224   6                          case USB_GET_CONFIGURATION:
 225   6                              Ep0Buffer[0] = UsbConfig;
C51 COMPILER V9.53.0.0   COMPATIBILITYHID                                                  01/02/2018 15:19:33 PAGE 5   

 226   6                              if ( SetupLen >= 1 )
 227   6                              {
 228   7                                  len = 1;
 229   7                              }
 230   6                              break;
 231   6                          case USB_SET_CONFIGURATION:
 232   6                              UsbConfig = UsbSetupBuf->wValueL;
 233   6                              break;
 234   6                          case 0x0A:
 235   6                              break;
 236   6                          case USB_CLEAR_FEATURE:                                      //Clear Feature
 237   6                              if ( ( UsbSetupBuf->bRequestType & USB_REQ_RECIP_MASK ) == USB_REQ_RECIP_ENDP )// 
             -∂Àµ„
 238   6                              {
 239   7                                  switch( UsbSetupBuf->wIndexL )
 240   7                                  {
 241   8                                  case 0x82:
 242   8                                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 243   8                                      break;
 244   8                                  case 0x81:
 245   8                                      UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 246   8                                      break;
 247   8                                  case 0x02:
 248   8                                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 249   8                                      break;
 250   8                                  default:
 251   8                                      len = 0xFF;                                       // ≤ª÷ß≥÷µƒ∂Àµ„
 252   8                                      break;
 253   8                                  }
 254   7                              }
 255   6                              else
 256   6                              {
 257   7                                  len = 0xFF;                                           // ≤ª «∂Àµ„≤ª÷ß≥÷
 258   7                              }
 259   6                              break;
 260   6                          case USB_SET_FEATURE:                                         /* Set Feature */
 261   6                              if( ( UsbSetupBuf->bRequestType & 0x1F ) == 0x00 )        /* …Ë÷√…Ë±∏ */
 262   6                              {
 263   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x01
             - )
 264   7                                  {
 265   8                                      if( CfgDesc[ 7 ] & 0x20 )
 266   8                                      {
 267   9                                          /* …Ë÷√ªΩ–— πƒ‹±Í÷æ */
 268   9                                      }
 269   8                                      else
 270   8                                      {
 271   9                                          len = 0xFF;                                    /* ≤Ÿ◊˜ ß∞‹ */
 272   9                                      }
 273   8                                  }
 274   7                                  else
 275   7                                  {
 276   8                                      len = 0xFF;                                        /* ≤Ÿ◊˜ ß∞‹ */
 277   8                                  }
 278   7                              }
 279   6                              else if( ( UsbSetupBuf->bRequestType & 0x1F ) == 0x02 )    /* …Ë÷√∂Àµ„ */
 280   6                              {
 281   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x00
             - )
 282   7                                  {
 283   8                                      switch( ( ( UINT16 )UsbSetupBuf->wIndexH << 8 ) | UsbSetupBuf->wIndexL )
 284   8                                      {
C51 COMPILER V9.53.0.0   COMPATIBILITYHID                                                  01/02/2018 15:19:33 PAGE 6   

 285   9                                      case 0x82:
 286   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* …Ë÷√∂Àµ„2 I
             -N STALL */
 287   9                                          break;
 288   9                                      case 0x02:
 289   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* …Ë÷√∂Àµ„2 O
             -UT Stall */
 290   9                                          break;
 291   9                                      case 0x81:
 292   9                                          UEP1_CTRL = UEP1_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* …Ë÷√∂Àµ„1 I
             -N STALL */
 293   9                                          break;
 294   9                                      default:
 295   9                                          len = 0xFF;                                     /* ≤Ÿ◊˜ ß∞‹ */
 296   9                                          break;
 297   9                                      }
 298   8                                  }
 299   7                                  else
 300   7                                  {
 301   8                                      len = 0xFF;                                         /* ≤Ÿ◊˜ ß∞‹ */
 302   8                                  }
 303   7                              }
 304   6                              else
 305   6                              {
 306   7                                  len = 0xFF;                                             /* ≤Ÿ◊˜ ß∞‹ */
 307   7                              } 
 308   6                              break;
 309   6                          case USB_GET_STATUS:
 310   6                              Ep0Buffer[0] = 0x00;
 311   6                              Ep0Buffer[1] = 0x00;
 312   6                              if ( SetupLen >= 2 )
 313   6                              {
 314   7                                  len = 2;
 315   7                              }
 316   6                              else
 317   6                              {
 318   7                                  len = SetupLen;
 319   7                              }
 320   6                              break;
 321   6                          default:
 322   6                              len = 0xff;                                                  //≤Ÿ◊˜ ß∞‹
 323   6                              break;
 324   6                          }
 325   5                      }
 326   4                  }
 327   3                  else
 328   3                  {
 329   4                      len = 0xff;                                                          //∞¸≥§∂»¥ÌŒÛ
 330   4                  }
 331   3                  if(len == 0xff)
 332   3                  {
 333   4                      SetupReq = 0xFF;
 334   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;//STALL
 335   4                  }
 336   3                  else if(len <= THIS_ENDP0_SIZE)                                         //…œ¥´ ˝æ›ªÚ’ﬂ◊¥Ã¨Ω◊∂Œ
             -∑µªÿ0≥§∂»∞¸
 337   3                  {
 338   4                      UEP0_T_LEN = len;
 339   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//ƒ¨»œ ˝æ›∞¸ «DATA1£¨∑
             -µªÿ”¶¥ACK
 340   4                  }
 341   3                  else
C51 COMPILER V9.53.0.0   COMPATIBILITYHID                                                  01/02/2018 15:19:33 PAGE 7   

 342   3                  {
 343   4                      UEP0_T_LEN = 0;  //À‰»ª…–Œ¥µΩ◊¥Ã¨Ω◊∂Œ£¨µ´ «Ã·«∞‘§÷√…œ¥´0≥§∂» ˝æ›∞¸“‘∑¿÷˜ª˙Ã·«∞Ω¯»Î◊¥Ã¨Ω◊∂Œ
 344   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//ƒ¨»œ ˝æ›∞¸ «DATA1,∑µ
             -ªÿ”¶¥ACK
 345   4                  }
 346   3                  break;
 347   3              case UIS_TOKEN_IN | 0:                                                      //endpoint0 IN
 348   3                  switch(SetupReq)
 349   3                  {
 350   4                  case USB_GET_DESCRIPTOR:
 351   4                      len = SetupLen >= THIS_ENDP0_SIZE ? THIS_ENDP0_SIZE : SetupLen;     //±æ¥Œ¥´ ‰≥§∂»
 352   4                      memcpy( Ep0Buffer, pDescr, len );                                   //º”‘ÿ…œ¥´ ˝æ›
 353   4                      SetupLen -= len;
 354   4                      pDescr += len;
 355   4                      UEP0_T_LEN = len;
 356   4                      UEP0_CTRL ^= bUEP_T_TOG;                                            //Õ¨≤Ω±Í÷æŒª∑≠◊™
 357   4                      break;
 358   4                  case USB_SET_ADDRESS:
 359   4                      USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | SetupLen;
 360   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 361   4                      break;
 362   4                  default:
 363   4                      UEP0_T_LEN = 0;                                                      //◊¥Ã¨Ω◊∂ŒÕÍ≥…÷–∂œªÚ’
             -ﬂ ««ø÷∆…œ¥´0≥§∂» ˝æ›∞¸Ω· ¯øÿ÷∆¥´ ‰
 364   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 365   4                      break;
 366   4                  }
 367   3                  break;
 368   3              case UIS_TOKEN_OUT | 0:  // endpoint0 OUT
 369   3                  len = USB_RX_LEN;
 370   3                  if(SetupReq == 0x09)
 371   3                  {
 372   4                      if(Ep0Buffer[0])
 373   4                      {
 374   5                          printf("Light on Num Lock LED!\n");
 375   5                      }
 376   4                      else if(Ep0Buffer[0] == 0)
 377   4                      {
 378   5                          printf("Light off Num Lock LED!\n");
 379   5                      }
 380   4                  }
 381   3                  UEP0_T_LEN = 0;  //À‰»ª…–Œ¥µΩ◊¥Ã¨Ω◊∂Œ£¨µ´ «Ã·«∞‘§÷√…œ¥´0≥§∂» ˝æ›∞¸“‘∑¿÷˜ª˙Ã·«∞Ω¯»Î◊¥Ã¨Ω◊∂Œ
 382   3                  UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_ACK;//ƒ¨»œ ˝æ›∞¸ «DATA0,∑µªÿ”¶¥ACK
 383   3                  break;
 384   3              default:
 385   3                  break;
 386   3              }
 387   2              UIF_TRANSFER = 0;                                                           //–¥0«Âø’÷–∂œ
 388   2          }
 389   1          if(UIF_BUS_RST)                                                                 //…Ë±∏ƒ£ ΩUSB◊‹œﬂ∏¥Œª÷
             -–∂œ
 390   1          {
 391   2              UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 392   2              UEP1_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK;
 393   2              UEP2_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK | UEP_T_RES_NAK;
 394   2              USB_DEV_AD = 0x00;
 395   2              UIF_SUSPEND = 0;
 396   2              UIF_TRANSFER = 0;
 397   2              UIF_BUS_RST = 0;                                                             //«Â÷–∂œ±Í÷æ
 398   2          }
 399   1          if (UIF_SUSPEND)                                                                 //USB◊‹œﬂπ“∆/ªΩ–—ÕÍ≥
             -…
C51 COMPILER V9.53.0.0   COMPATIBILITYHID                                                  01/02/2018 15:19:33 PAGE 8   

 400   1          {
 401   2              UIF_SUSPEND = 0;
 402   2              if ( USB_MIS_ST & bUMS_SUSPEND )                                             //π“∆
 403   2              {
 404   3      #ifdef DE_PRINTF
 405   3                  printf( "zz" );                                                          //ÀØ√ﬂ◊¥Ã¨
 406   3      #endif
 407   3                  while ( XBUS_AUX & bUART0_TX )
 408   3                  {
 409   4                      ;    //µ»¥˝∑¢ÀÕÕÍ≥…
 410   4                  }
 411   3                  SAFE_MOD = 0x55;
 412   3                  SAFE_MOD = 0xAA;
 413   3                  WAKE_CTRL = bWAK_BY_USB | bWAK_RXD0_LO;                                   //USBªÚ’ﬂRXD0”––≈∫≈ 
             -±ø…±ªªΩ–—
 414   3                  PCON |= PD;                                                               //ÀØ√ﬂ
 415   3                  SAFE_MOD = 0x55;
 416   3                  SAFE_MOD = 0xAA;
 417   3                  WAKE_CTRL = 0x00;
 418   3              }
 419   2          }
 420   1          else {                                                                             //“‚Õ‚µƒ÷–∂œ,≤ªø…ƒ‹
             -∑¢…˙µƒ«Èøˆ
 421   2              USB_INT_FG = 0xFF;                                                             //«Â÷–∂œ±Í÷æ
 422   2      //      printf("UnknownInt  N");
 423   2          }
 424   1      }
 425          
 426          main()
 427          {
 428   1          UINT8 i;
 429   1          CfgFsys( );                                                           //CH559 ±÷”—°‘Ò≈‰÷√
 430   1          mDelaymS(5);                                                          //–ﬁ∏ƒ÷˜∆µµ»¥˝ƒ⁄≤øæß’ÒŒ»∂®,±ÿº”       
 431   1          mInitSTDIO( );                                                        //¥Æø⁄0≥ı ºªØ
 432   1      #ifdef DE_PRINTF
 433   1          printf("start ...\n");
 434   1      #endif  
 435   1          for(i=0; i<64; i++)                                                   //◊º±∏—› æ ˝æ›
 436   1          {
 437   2              UserEp2Buf[i] = i;
 438   2          }
 439   1          USBDeviceInit();                                                      //USB…Ë±∏ƒ£ Ω≥ı ºªØ
 440   1          EA = 1;                                                               //‘ –Ìµ•∆¨ª˙÷–∂œ              
 441   1          UEP1_T_LEN = 0;                                                       //‘§ π”√∑¢ÀÕ≥§∂»“ª∂®“™«Âø’
 442   1          UEP2_T_LEN = 0;                                                       //‘§ π”√∑¢ÀÕ≥§∂»“ª∂®“™«Âø’
 443   1          FLAG = 0;
 444   1          Ready = 0;
 445   1          while(1)
 446   1          {
 447   2              if(Ready&& (Ep2InKey==0))
 448   2              {
 449   3                  Enp2BlukIn( );
 450   3                  mDelaymS( 100 );
 451   3              }
 452   2              mDelaymS( 100 );                                                   //ƒ£ƒ‚µ•∆¨ª˙◊ˆ∆‰À¸ ¬
 453   2          }
 454   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1166    ----
   CONSTANT SIZE    =    156    ----
C51 COMPILER V9.53.0.0   COMPATIBILITYHID                                                  01/02/2018 15:19:33 PAGE 9   

   XDATA SIZE       =     81       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
