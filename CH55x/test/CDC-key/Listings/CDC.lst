C51 COMPILER V9.56.0.0   CDC                                                               11/08/2019 05:34:28 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE CDC
OBJECT MODULE PLACED IN .\Objects\CDC.obj
COMPILER INVOKED BY: C:\Keil_v5_c51\C51\BIN\C51.EXE CDC.C LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Public) DEBUG OBJECTEX
                    -TEND PRINT(.\Listings\CDC.lst) TABS(2) OBJECT(.\Objects\CDC.obj)

line level    source

   1          /********************************** (C) COPYRIGHT *******************************
   2          * File Name          : CDC.C
   3          * Author             : WCH
   4          * Version            : V1.0
   5          * Date               : 2017/03/01
   6          * Description        : CH554×öCDCÉè±¸×ª´®¿Ú£¬Ñ¡Ôñ´®¿Ú1
   7          *******************************************************************************/
   8          #include "CH554.H"
   9          #include "DEBUG.H"
  10          #include <stdio.h>
  11          #include <string.h>
  12          
  13          #include "gpio.h"
  14          #include "touchkey.h"
  15               
  16          #pragma  NOAREGS
  17               
  18          UINT8X  Ep0Buffer[DEFAULT_ENDP0_SIZE] _at_ 0x0000;                                 //¶Ëµã0 OUT&IN»º³åÇø£¬±
             -ØÐëÊÇÅ¼µØÖ·
  19          UINT8X  Ep1Buffer[8] _at_ 0x0040;                                                  //¶Ëµã1ÉÏ´«»º³åÇø
  20          UINT8X  Ep2Buffer[2*MAX_PACKET_SIZE] _at_ 0x0080;                                  //¶Ëµã2 IN & OUT»º³åÇø,
             -±ØÐëÊÇÅ¼µØÖ·
  21          
  22          UINT16 SetupLen;
  23          UINT8   SetupReq,Count,UsbConfig;
  24          PUINT8  pDescr;                                                                //USBÅäÖÃ±êÖ¾
  25          USB_SETUP_REQ   SetupReqBuf;                                                   //ÔÝ´æSetup°ü
  26          #define UsbSetupBuf     ((PUSB_SETUP_REQ)Ep0Buffer)
  27          
  28          #define  SET_LINE_CODING                0X20            // Configures DTE rate, stop-bits, parity, and num
             -ber-of-character
  29          #define  GET_LINE_CODING                0X21            // This request allows the host to find out the cu
             -rrently configured line coding.
  30          #define  SET_CONTROL_LINE_STATE         0X22            // This request generates RS-232/V.24 style contro
             -l signals.
  31          
  32          
  33          /*Éè±¸ÃèÊö·û*/
  34          UINT8C DevDesc[] = {0x12,0x01,0x10,0x01,0x02,0x00,0x00,DEFAULT_ENDP0_SIZE,
  35                              0x86,0x1a,0x22,0x57,0x00,0x01,0x01,0x02,
  36                              0x03,0x01
  37                             };
  38          UINT8C CfgDesc[] ={
  39              0x09,0x02,0x43,0x00,0x02,0x01,0x00,0xa0,0x32,             //ÅäÖÃÃèÊö·û£¨Á½¸ö½Ó¿Ú£©
  40            //ÒÔÏÂÎª½Ó¿Ú0£¨CDC½Ó¿Ú£©ÃèÊö·û  
  41              0x09,0x04,0x00,0x00,0x01,0x02,0x02,0x01,0x00,             //CDC½Ó¿ÚÃèÊö·û(Ò»¸ö¶Ëµã)
  42            //ÒÔÏÂÎª¹¦ÄÜÃèÊö·û
  43              0x05,0x24,0x00,0x10,0x01,                                 //¹¦ÄÜÃèÊö·û(Í·)
  44            0x05,0x24,0x01,0x00,0x00,                                 //¹ÜÀíÃèÊö·û(Ã»ÓÐÊý¾ÝÀà½Ó¿Ú) 03 01
  45            0x04,0x24,0x02,0x02,                                      //Ö§³ÖSet_Line_Coding¡¢Set_Control_Line_State¡¢
             -Get_Line_Coding¡¢Serial_State 
  46            0x05,0x24,0x06,0x00,0x01,                                 //±àºÅÎª0µÄCDC½Ó¿Ú;±àºÅ1µÄÊý¾ÝÀà½Ó¿Ú
  47            0x07,0x05,0x81,0x03,0x08,0x00,0xFF,                       //ÖÐ¶ÏÉÏ´«¶ËµãÃèÊö·û
  48            //ÒÔÏÂÎª½Ó¿Ú1£¨Êý¾Ý½Ó¿Ú£©ÃèÊö·û
C51 COMPILER V9.56.0.0   CDC                                                               11/08/2019 05:34:28 PAGE 2   

  49            0x09,0x04,0x01,0x00,0x02,0x0a,0x00,0x00,0x00,             //Êý¾Ý½Ó¿ÚÃèÊö·û
  50              0x07,0x05,0x02,0x02,0x40,0x00,0x00,                       //¶ËµãÃèÊö·û  
  51            0x07,0x05,0x82,0x02,0x40,0x00,0x00,                       //¶ËµãÃèÊö·û
  52          };
  53          /*×Ö·û´®ÃèÊö·û*/
  54           unsigned char  code LangDes[]={0x04,0x03,0x09,0x04};           //ÓïÑÔÃèÊö·û
  55           unsigned char  code SerDes[]={                                 //ÐòÁÐºÅ×Ö·û´®ÃèÊö·û
  56                          0x14,0x03,
  57                  0x32,0x00,0x30,0x00,0x31,0x00,0x37,0x00,0x2D,0x00,
  58                  0x32,0x00,0x2D,0x00,
  59                  0x32,0x00,0x35,0x00
  60                          };     
  61           unsigned char  code Prod_Des[]={                                //²úÆ·×Ö·û´®ÃèÊö·û
  62                  0x14,0x03,
  63                  0x43,0x00,0x48,0x00,0x35,0x00,0x35,0x00,0x34,0x00,0x5F,0x00,
  64                  0x43,0x00,0x44,0x00,0x43,0x00,
  65           };
  66           unsigned char  code Manuf_Des[]={  
  67                  0x0A,0x03,
  68                  0x5F,0x6c,0xCF,0x82,0x81,0x6c,0x52,0x60,
  69           };
  70          
  71          //cdc²ÎÊý
  72          UINT8X LineCoding[7]={0x00,0xe1,0x00,0x00,0x00,0x00,0x08};   //³õÊ¼»¯²¨ÌØÂÊÎª57600£¬1Í£Ö¹Î»£¬ÎÞÐ£Ñé£¬8Êý¾Ý
             -Î»¡£
  73          
  74          #define UART_REV_LEN  64                 //´®¿Ú½ÓÊÕ»º³åÇø´óÐ¡
  75          UINT8I Receive_Uart_Buf[UART_REV_LEN];   //´®¿Ú½ÓÊÕ»º³åÇø
  76          volatile UINT8I Uart_Input_Point = 0;   //Ñ­»·»º³åÇøÐ´ÈëÖ¸Õë£¬×ÜÏß¸´Î»ÐèÒª³õÊ¼»¯Îª0
  77          volatile UINT8I Uart_Output_Point = 0;  //Ñ­»·»º³åÇøÈ¡³öÖ¸Õë£¬×ÜÏß¸´Î»ÐèÒª³õÊ¼»¯Îª0
  78          volatile UINT8I UartByteCount = 0;      //µ±Ç°»º³åÇøÊ£Óà´ýÈ¡×Ö½ÚÊý
  79          
  80          
  81          volatile UINT8I USBByteCount = 0;      //´ú±íUSB¶Ëµã½ÓÊÕµ½µÄÊý¾Ý
  82          volatile UINT8I USBBufOutPoint = 0;    //È¡Êý¾ÝÖ¸Õë
  83          
  84          volatile UINT8I UpPoint2_Busy  = 0;   //ÉÏ´«¶ËµãÊÇ·ñÃ¦±êÖ¾
  85          
  86          
  87          /*******************************************************************************
  88          * Function Name  : USBDeviceCfg()
  89          * Description    : USBÉè±¸Ä£Ê½ÅäÖÃ
  90          * Input          : None
  91          * Output         : None
  92          * Return         : None
  93          *******************************************************************************/
  94          void USBDeviceCfg()
  95          {
  96   1          USB_CTRL = 0x00;                                                            //Çå¿ÕUSB¿ØÖÆ¼Ä´æÆ÷
  97   1          USB_CTRL &= ~bUC_HOST_MODE;                                                 //¸ÃÎ»ÎªÑ¡ÔñÉè±¸Ä£Ê½
  98   1          USB_CTRL |=  bUC_DEV_PU_EN | bUC_INT_BUSY | bUC_DMA_EN;                     //USBÉè±¸ºÍÄÚ²¿ÉÏÀ­Ê¹ÄÜ,ÔÚ
             -ÖÐ¶ÏÆÚ¼äÖÐ¶Ï±êÖ¾Î´Çå³ýÇ°×Ô¶¯·µ»ØNAK
  99   1          USB_DEV_AD = 0x00;                                                          //Éè±¸µØÖ·³õÊ¼»¯
 100   1      //     USB_CTRL |= bUC_LOW_SPEED;
 101   1      //     UDEV_CTRL |= bUD_LOW_SPEED;                                              //Ñ¡ÔñµÍËÙ1.5MÄ£Ê½
 102   1          USB_CTRL &= ~bUC_LOW_SPEED;
 103   1          UDEV_CTRL &= ~bUD_LOW_SPEED;                                                //Ñ¡ÔñÈ«ËÙ12MÄ£Ê½£¬Ä¬ÈÏ·½Ê½
 104   1          UDEV_CTRL = bUD_PD_DIS;                                                     // ½ûÖ¹DP/DMÏÂÀ­µç×è
 105   1          UDEV_CTRL |= bUD_PORT_EN;                                                   //Ê¹ÄÜÎïÀí¶Ë¿Ú
 106   1      }
 107          /*******************************************************************************
 108          * Function Name  : USBDeviceIntCfg()
C51 COMPILER V9.56.0.0   CDC                                                               11/08/2019 05:34:28 PAGE 3   

 109          * Description    : USBÉè±¸Ä£Ê½ÖÐ¶Ï³õÊ¼»¯
 110          * Input          : None
 111          * Output         : None
 112          * Return         : None
 113          *******************************************************************************/
 114          void USBDeviceIntCfg()
 115          {
 116   1          USB_INT_EN |= bUIE_SUSPEND;                                               //Ê¹ÄÜÉè±¸¹ÒÆðÖÐ¶Ï
 117   1          USB_INT_EN |= bUIE_TRANSFER;                                              //Ê¹ÄÜUSB´«ÊäÍê³ÉÖÐ¶Ï
 118   1          USB_INT_EN |= bUIE_BUS_RST;                                               //Ê¹ÄÜÉè±¸Ä£Ê½USB×ÜÏß¸´Î»ÖÐ¶
             -Ï
 119   1          USB_INT_FG |= 0x1F;                                                       //ÇåÖÐ¶Ï±êÖ¾
 120   1          IE_USB = 1;                                                               //Ê¹ÄÜUSBÖÐ¶Ï
 121   1          EA = 1;                                                                   //ÔÊÐíµ¥Æ¬»úÖÐ¶Ï
 122   1      }
 123          /*******************************************************************************
 124          * Function Name  : USBDeviceEndPointCfg()
 125          * Description    : USBÉè±¸Ä£Ê½¶ËµãÅäÖÃ£¬Ä£Äâ¼æÈÝHIDÉè±¸£¬³ýÁË¶Ëµã0µÄ¿ØÖÆ´«Êä£¬»¹°üÀ¨¶Ëµã2ÅúÁ¿ÉÏÏÂ´«
 126          * Input          : None
 127          * Output         : None
 128          * Return         : None
 129          *******************************************************************************/
 130          void USBDeviceEndPointCfg()
 131          {
 132   1        UEP1_DMA = Ep1Buffer;                                                      //¶Ëµã1 ·¢ËÍÊý¾Ý´«ÊäµØÖ·
 133   1          UEP2_DMA = Ep2Buffer;                                                      //¶Ëµã2 INÊý¾Ý´«ÊäµØÖ· 
 134   1          UEP2_3_MOD = 0xCC;                                                         //¶Ëµã2/3 µ¥»º³åÊÕ·¢Ê¹ÄÜ
 135   1          UEP2_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK | UEP_R_RES_ACK;                 //¶Ëµã2×Ô¶¯·­×ªÍ¬²½±êÖ¾Î»£¬
             -INÊÂÎñ·µ»ØNAK£¬OUT·µ»ØACK
 136   1      
 137   1          UEP1_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK;                                 //¶Ëµã1×Ô¶¯·­×ªÍ¬²½±êÖ¾Î»£¬
             -INÊÂÎñ·µ»ØNAK  
 138   1        UEP0_DMA = Ep0Buffer;                                                      //¶Ëµã0Êý¾Ý´«ÊäµØÖ·
 139   1          UEP4_1_MOD = 0X40;                                                         //¶Ëµã1ÉÏ´«»º³åÇø£»¶Ëµã0µ¥6
             -4×Ö½ÚÊÕ·¢»º³åÇø
 140   1          UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;                                 //ÊÖ¶¯·­×ª£¬OUTÊÂÎñ·µ»ØACK£
             -¬INÊÂÎñ·µ»ØNAK
 141   1      }
 142          /*******************************************************************************
 143          * Function Name  : Config_Uart1(UINT8 *cfg_uart)
 144          * Description    : ÅäÖÃ´®¿Ú1²ÎÊý
 145          * Input          : ´®¿ÚÅäÖÃ²ÎÊý ËÄÎ»²¨ÌØÂÊ¡¢Í£Ö¹Î»¡¢Ð£Ñé¡¢Êý¾ÝÎ»
 146          * Output         : None
 147          * Return         : None
 148          *******************************************************************************/
 149          void Config_Uart1(UINT8 *cfg_uart)
 150          {
 151   1        UINT32 uart1_buad = 0;
 152   1        *((UINT8 *)&uart1_buad) = cfg_uart[3];
 153   1        *((UINT8 *)&uart1_buad+1) = cfg_uart[2];
 154   1        *((UINT8 *)&uart1_buad+2) = cfg_uart[1];
 155   1        *((UINT8 *)&uart1_buad+3) = cfg_uart[0];
 156   1        IE_UART1 = 0;
 157   1        SBAUD1 = 0 - FREQ_SYS/16/uart1_buad;
 158   1        IE_UART1 = 1;
 159   1      }
 160          /*******************************************************************************
 161          * Function Name  : DeviceInterrupt()
 162          * Description    : CH559USBÖÐ¶Ï´¦Àíº¯Êý
 163          *******************************************************************************/
 164          void    DeviceInterrupt( void ) interrupt INT_NO_USB                       //USBÖÐ¶Ï·þÎñ³ÌÐò,Ê¹ÓÃ¼Ä´æÆ÷×é1
 165          {
C51 COMPILER V9.56.0.0   CDC                                                               11/08/2019 05:34:28 PAGE 4   

 166   1          UINT16 len;
 167   1          if(UIF_TRANSFER)                                                            //USB´«ÊäÍê³É±êÖ¾
 168   1          {
 169   2              switch (USB_INT_ST & (MASK_UIS_TOKEN | MASK_UIS_ENDP))
 170   2              {
 171   3          case UIS_TOKEN_IN | 1:                                                  //endpoint 1# ¶ËµãÖÐ¶ÏÉÏ´«
 172   3            UEP1_T_LEN = 0; 
 173   3            UEP1_CTRL = UEP1_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;           //Ä¬ÈÏÓ¦´ðNAK
 174   3            break;
 175   3              case UIS_TOKEN_IN | 2:                                                  //endpoint 2# ¶ËµãÅúÁ¿ÉÏ´«
 176   3            {   
 177   4              UEP2_T_LEN = 0;                                                    //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 178   4              UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;           //Ä¬ÈÏÓ¦´ðNAK
 179   4              UpPoint2_Busy = 0;                                                  //Çå³ýÃ¦±êÖ¾
 180   4            }
 181   3                  break;
 182   3              case UIS_TOKEN_OUT | 2:                                                 //endpoint 3# ¶ËµãÅúÁ¿ÏÂ´«
 183   3                  if ( U_TOG_OK )                                                     // ²»Í¬²½µÄÊý¾Ý°ü½«¶ªÆú
 184   3                  {
 185   4                      USBByteCount = USB_RX_LEN;
 186   4              USBBufOutPoint = 0;                                             //È¡Êý¾ÝÖ¸Õë¸´Î»
 187   4              UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_R_RES | UEP_R_RES_NAK;       //ÊÕµ½Ò»°üÊý¾Ý¾ÍNAK£¬Ö÷º¯Êý´¦ÀíÍê£¬ÓÉÖ
             -÷º¯ÊýÐÞ¸ÄÏìÓ¦·½Ê½
 188   4                  }
 189   3                  break;
 190   3              case UIS_TOKEN_SETUP | 0:                                                //SETUPÊÂÎñ
 191   3                  len = USB_RX_LEN;
 192   3                  if(len == (sizeof(USB_SETUP_REQ)))
 193   3                  {
 194   4                      SetupLen = ((UINT16)UsbSetupBuf->wLengthH<<8) | (UsbSetupBuf->wLengthL);
 195   4                      len = 0;                                                      // Ä¬ÈÏÎª³É¹¦²¢ÇÒÉÏ´«0³¤¶È
 196   4                      SetupReq = UsbSetupBuf->bRequest;             
 197   4                      if ( ( UsbSetupBuf->bRequestType & USB_REQ_TYP_MASK ) != USB_REQ_TYP_STANDARD )//·Ç±ê×¼ÇëÇ
             -ó
 198   4                      {
 199   5                        switch( SetupReq ) 
 200   5                        {
 201   6                          case GET_LINE_CODING:   //0x21  currently configured
 202   6                            pDescr = LineCoding;
 203   6                            len = sizeof(LineCoding);
 204   6                            len = SetupLen >= DEFAULT_ENDP0_SIZE ? DEFAULT_ENDP0_SIZE : SetupLen;  // ±¾´Î´«Êä³¤¶È
 205   6                            memcpy(Ep0Buffer,pDescr,len); 
 206   6                            SetupLen -= len;
 207   6                            pDescr += len;
 208   6                            break;            
 209   6                          case SET_CONTROL_LINE_STATE:  //0x22  generates RS-232/V.24 style control signals                   
 210   6                            break;
 211   6                          case SET_LINE_CODING:      //0x20  Configure
 212   6                            break;
 213   6                          default:
 214   6                               len = 0xFF;                                             /*ÃüÁî²»Ö§³Ö*/         
 215   6                               break;
 216   6                        }   
 217   5                      }
 218   4                      else                                                             //±ê×¼ÇëÇó
 219   4                      {
 220   5                          switch(SetupReq)                                             //ÇëÇóÂë
 221   5                          {
 222   6                          case USB_GET_DESCRIPTOR:
 223   6                              switch(UsbSetupBuf->wValueH)
 224   6                              {
 225   7                              case 1:                                                       //Éè±¸ÃèÊö·û
C51 COMPILER V9.56.0.0   CDC                                                               11/08/2019 05:34:28 PAGE 5   

 226   7                                  pDescr = DevDesc;                                         //°ÑÉè±¸ÃèÊö·ûËÍµ½Òª
             -·¢ËÍµÄ»º³åÇø
 227   7                                  len = sizeof(DevDesc);
 228   7                                  break;
 229   7                              case 2:                                                        //ÅäÖÃÃèÊö·û
 230   7                                  pDescr = CfgDesc;                                          //°ÑÉè±¸ÃèÊö·ûËÍµ½Ò
             -ª·¢ËÍµÄ»º³åÇø
 231   7                                  len = sizeof(CfgDesc);
 232   7                                  break;
 233   7                              case 3:
 234   7                                if(UsbSetupBuf->wValueL == 0)
 235   7                                {
 236   8                                  pDescr = LangDes;                                          
 237   8                                  len = sizeof(LangDes);                
 238   8                                }
 239   7                                else if(UsbSetupBuf->wValueL == 1)
 240   7                                {
 241   8                                  pDescr = Manuf_Des; 
 242   8                                  len = sizeof(Manuf_Des);
 243   8                                }
 244   7                                else if(UsbSetupBuf->wValueL == 2)
 245   7                                {
 246   8                                  pDescr = Prod_Des; 
 247   8                                  len = sizeof(Prod_Des);
 248   8                                }
 249   7                                else
 250   7                                {
 251   8                                  pDescr = SerDes; 
 252   8                                  len = sizeof(SerDes);
 253   8                                }             
 254   7                                break;
 255   7                              default:
 256   7                                  len = 0xff;                                                //²»Ö§³ÖµÄÃüÁî»òÕß³
             -ö´í
 257   7                                  break;
 258   7                              }
 259   6                              if ( SetupLen > len )
 260   6                              {
 261   7                                  SetupLen = len;    //ÏÞÖÆ×Ü³¤¶È
 262   7                              }
 263   6                              len = SetupLen >= DEFAULT_ENDP0_SIZE ? DEFAULT_ENDP0_SIZE : SetupLen;             
             -               //±¾´Î´«Êä³¤¶È
 264   6                              memcpy(Ep0Buffer,pDescr,len);                                  //¼ÓÔØÉÏ´«Êý¾Ý
 265   6                              SetupLen -= len;
 266   6                              pDescr += len;
 267   6                              break;
 268   6                          case USB_SET_ADDRESS:
 269   6                              SetupLen = UsbSetupBuf->wValueL;                              //ÔÝ´æUSBÉè±¸µØÖ·
 270   6                              break;
 271   6                          case USB_GET_CONFIGURATION:
 272   6                              Ep0Buffer[0] = UsbConfig;
 273   6                              if ( SetupLen >= 1 )
 274   6                              {
 275   7                                  len = 1;
 276   7                              }
 277   6                              break;
 278   6                          case USB_SET_CONFIGURATION:
 279   6                              UsbConfig = UsbSetupBuf->wValueL;
 280   6                              break;
 281   6                          case USB_GET_INTERFACE:
 282   6                              break;
 283   6                          case USB_CLEAR_FEATURE:                                            //Clear Feature
C51 COMPILER V9.56.0.0   CDC                                                               11/08/2019 05:34:28 PAGE 6   

 284   6                              if( ( UsbSetupBuf->bRequestType & 0x1F ) == USB_REQ_RECIP_DEVICE )                
             -  /* Çå³ýÉè±¸ */
 285   6                              {
 286   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x01
             - )
 287   7                                  {
 288   8                                      if( CfgDesc[ 7 ] & 0x20 )
 289   8                                      {
 290   9                                          /* »½ÐÑ */
 291   9                                      }
 292   8                                      else
 293   8                                      {
 294   9                                          len = 0xFF;                                        /* ²Ù×÷Ê§°Ü */
 295   9                                      }
 296   8                                  }
 297   7                                  else
 298   7                                  {
 299   8                                      len = 0xFF;                                            /* ²Ù×÷Ê§°Ü */
 300   8                                  }
 301   7                              }
 302   6                              else if ( ( UsbSetupBuf->bRequestType & USB_REQ_RECIP_MASK ) == USB_REQ_RECIP_ENDP
             - )// ¶Ëµã
 303   6                              {
 304   7                                  switch( UsbSetupBuf->wIndexL )
 305   7                                  {
 306   8                                  case 0x83:
 307   8                                      UEP3_CTRL = UEP3_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 308   8                                      break;
 309   8                                  case 0x03:
 310   8                                      UEP3_CTRL = UEP3_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 311   8                                      break;
 312   8                                  case 0x82:
 313   8                                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 314   8                                      break;
 315   8                                  case 0x02:
 316   8                                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 317   8                                      break;
 318   8                                  case 0x81:
 319   8                                      UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 320   8                                      break;
 321   8                                  case 0x01:
 322   8                                      UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 323   8                                      break;              
 324   8                                  default:
 325   8                                      len = 0xFF;                                         // ²»Ö§³ÖµÄ¶Ëµã
 326   8                                      break;
 327   8                                  }
 328   7                              }
 329   6                              else
 330   6                              {
 331   7                                  len = 0xFF;                                                // ²»ÊÇ¶Ëµã²»Ö§³Ö
 332   7                              }
 333   6                              break;
 334   6                          case USB_SET_FEATURE:                                          /* Set Feature */
 335   6                              if( ( UsbSetupBuf->bRequestType & 0x1F ) == USB_REQ_RECIP_DEVICE )                
             -  /* ÉèÖÃÉè±¸ */
 336   6                              {
 337   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x01
             - )
 338   7                                  {
 339   8                                      if( CfgDesc[ 7 ] & 0x20 )
 340   8                                      {
C51 COMPILER V9.56.0.0   CDC                                                               11/08/2019 05:34:28 PAGE 7   

 341   9                                          /* ÐÝÃß */
 342   9                                        #ifdef DE_PRINTF
 343   9                                              printf( "suspend\n" );                                                             //Ë
             -¯Ãß×´Ì¬
 344   9                                        #endif
 345   9                                        while ( XBUS_AUX & bUART0_TX )
 346   9                                        {
 347  10                                          ;    //µÈ´ý·¢ËÍÍê³É
 348  10                                        }
 349   9                                        SAFE_MOD = 0x55;
 350   9                                        SAFE_MOD = 0xAA;
 351   9                                        WAKE_CTRL = bWAK_BY_USB | bWAK_RXD0_LO | bWAK_RXD1_LO;                      //USB»òÕßRXD0
             -/1ÓÐÐÅºÅÊ±¿É±»»½ÐÑ
 352   9                                        PCON |= PD;                                                                 //Ë¯Ãß
 353   9                                        SAFE_MOD = 0x55;
 354   9                                        SAFE_MOD = 0xAA;
 355   9                                        WAKE_CTRL = 0x00;
 356   9                                      }
 357   8                                      else
 358   8                                      {
 359   9                                          len = 0xFF;                                        /* ²Ù×÷Ê§°Ü */
 360   9                                      }
 361   8                                  }
 362   7                                  else
 363   7                                  {
 364   8                                      len = 0xFF;                                            /* ²Ù×÷Ê§°Ü */
 365   8                                  }
 366   7                              }
 367   6                              else if( ( UsbSetupBuf->bRequestType & 0x1F ) == USB_REQ_RECIP_ENDP )             
             -/* ÉèÖÃ¶Ëµã */
 368   6                              {
 369   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x00
             - )
 370   7                                  {
 371   8                                      switch( ( ( UINT16 )UsbSetupBuf->wIndexH << 8 ) | UsbSetupBuf->wIndexL )
 372   8                                      {
 373   9                                      case 0x83:
 374   9                                          UEP3_CTRL = UEP3_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã3 I
             -N STALL */
 375   9                                          break;
 376   9                                      case 0x03:
 377   9                                          UEP3_CTRL = UEP3_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* ÉèÖÃ¶Ëµã3 O
             -UT Stall */
 378   9                                          break;                  
 379   9                                      case 0x82:
 380   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã2 I
             -N STALL */
 381   9                                          break;
 382   9                                      case 0x02:
 383   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* ÉèÖÃ¶Ëµã2 O
             -UT Stall */
 384   9                                          break;
 385   9                                      case 0x81:
 386   9                                          UEP1_CTRL = UEP1_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã1 I
             -N STALL */
 387   9                                          break;
 388   9                      case 0x01:
 389   9                        UEP1_CTRL = UEP1_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* ÉèÖÃ¶Ëµã1 OUT Stall */
 390   9                                      default:
 391   9                                          len = 0xFF;                                    /* ²Ù×÷Ê§°Ü */
 392   9                                          break;
 393   9                                      }
C51 COMPILER V9.56.0.0   CDC                                                               11/08/2019 05:34:28 PAGE 8   

 394   8                                  }
 395   7                                  else
 396   7                                  {
 397   8                                      len = 0xFF;                                      /* ²Ù×÷Ê§°Ü */
 398   8                                  }
 399   7                              }
 400   6                              else
 401   6                              {
 402   7                                  len = 0xFF;                                          /* ²Ù×÷Ê§°Ü */
 403   7                              }
 404   6                              break;
 405   6                          case USB_GET_STATUS:
 406   6                              Ep0Buffer[0] = 0x00;
 407   6                              Ep0Buffer[1] = 0x00;
 408   6                              if ( SetupLen >= 2 )
 409   6                              {
 410   7                                  len = 2;
 411   7                              }
 412   6                              else
 413   6                              {
 414   7                                  len = SetupLen;
 415   7                              }
 416   6                              break;
 417   6                          default:
 418   6                              len = 0xff;                                                    //²Ù×÷Ê§°Ü
 419   6                              break;
 420   6                          }
 421   5                      }
 422   4                  }
 423   3                  else
 424   3                  {
 425   4                      len = 0xff;                                                         //°ü³¤¶È´íÎó
 426   4                  }
 427   3                  if(len == 0xff)
 428   3                  {
 429   4                      SetupReq = 0xFF;
 430   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;//STALL
 431   4                  }
 432   3                  else if(len <= DEFAULT_ENDP0_SIZE)                                                       //ÉÏ´
             -«Êý¾Ý»òÕß×´Ì¬½×¶Î·µ»Ø0³¤¶È°ü
 433   3                  {
 434   4                      UEP0_T_LEN = len;
 435   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA1£¬·
             -µ»ØÓ¦´ðACK
 436   4                  }
 437   3                  else
 438   3                  {
 439   4                      UEP0_T_LEN = 0;  //ËäÈ»ÉÐÎ´µ½×´Ì¬½×¶Î£¬µ«ÊÇÌáÇ°Ô¤ÖÃÉÏ´«0³¤¶ÈÊý¾Ý°üÒÔ·ÀÖ÷»úÌáÇ°½øÈë×´Ì¬½×¶Î
 440   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA1,·µ
             -»ØÓ¦´ðACK
 441   4                  }
 442   3                  break;
 443   3              case UIS_TOKEN_IN | 0:                                                      //endpoint0 IN
 444   3                  switch(SetupReq)
 445   3                  {
 446   4                  case USB_GET_DESCRIPTOR:
 447   4                      len = SetupLen >= DEFAULT_ENDP0_SIZE ? DEFAULT_ENDP0_SIZE : SetupLen;                     
             -            //±¾´Î´«Êä³¤¶È
 448   4                      memcpy( Ep0Buffer, pDescr, len );                                   //¼ÓÔØÉÏ´«Êý¾Ý
 449   4                      SetupLen -= len;
 450   4                      pDescr += len;
 451   4                      UEP0_T_LEN = len;
C51 COMPILER V9.56.0.0   CDC                                                               11/08/2019 05:34:28 PAGE 9   

 452   4                      UEP0_CTRL ^= bUEP_T_TOG;                                             //Í¬²½±êÖ¾Î»·­×ª
 453   4                      break;
 454   4                  case USB_SET_ADDRESS:
 455   4                      USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | SetupLen;
 456   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 457   4                      break;
 458   4                  default:
 459   4                      UEP0_T_LEN = 0;                                                      //×´Ì¬½×¶ÎÍê³ÉÖÐ¶Ï»òÕ
             -ßÊÇÇ¿ÖÆÉÏ´«0³¤¶ÈÊý¾Ý°ü½áÊø¿ØÖÆ´«Êä
 460   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 461   4                      break;
 462   4                  }
 463   3                  break;
 464   3              case UIS_TOKEN_OUT | 0:  // endpoint0 OUT
 465   3            if(SetupReq ==SET_LINE_CODING)  //ÉèÖÃ´®¿ÚÊôÐÔ
 466   3            {
 467   4              if( U_TOG_OK ) 
 468   4              {
 469   5                memcpy(LineCoding,UsbSetupBuf,USB_RX_LEN);
 470   5      //          Config_Uart1(LineCoding);
 471   5                UEP0_T_LEN = 0;
 472   5                UEP0_CTRL |= UEP_R_RES_ACK | UEP_T_RES_ACK;  // ×¼±¸ÉÏ´«0°ü       
 473   5              }
 474   4            }
 475   3            else
 476   3            {
 477   4              UEP0_T_LEN = 0;  
 478   4              UEP0_CTRL |= UEP_R_RES_ACK | UEP_T_RES_NAK;  //×´Ì¬½×¶Î£¬¶ÔINÏìÓ¦NAK
 479   4            }
 480   3                  break;
 481   3      
 482   3                
 483   3                
 484   3              default:
 485   3                  break;
 486   3              }
 487   2              UIF_TRANSFER = 0;                                                           //Ð´0Çå¿ÕÖÐ¶Ï
 488   2          }
 489   1          if(UIF_BUS_RST)                                                                 //Éè±¸Ä£Ê½USB×ÜÏß¸´Î»Ö
             -Ð¶Ï
 490   1          {
 491   2      #ifdef DE_PRINTF
 492   2                  printf( "reset\n" );                                                             //Ë¯Ãß×´Ì¬
 493   2      #endif    
 494   2              UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 495   2              UEP1_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK;
 496   2              UEP2_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK | UEP_R_RES_ACK;
 497   2              USB_DEV_AD = 0x00;
 498   2              UIF_SUSPEND = 0;
 499   2              UIF_TRANSFER = 0;
 500   2              UIF_BUS_RST = 0;                                                             //ÇåÖÐ¶Ï±êÖ¾
 501   2              Uart_Input_Point = 0;   //Ñ­»·»º³åÇøÊäÈëÖ¸Õë
 502   2              Uart_Output_Point = 0;  //Ñ­»·»º³åÇø¶Á³öÖ¸Õë
 503   2              UartByteCount = 0;      //µ±Ç°»º³åÇøÊ£Óà´ýÈ¡×Ö½ÚÊý
 504   2              USBByteCount = 0;       //USB¶ËµãÊÕµ½µÄ³¤¶È
 505   2              UsbConfig = 0;          //Çå³ýÅäÖÃÖµ
 506   2              UpPoint2_Busy = 0;
 507   2          }
 508   1          if (UIF_SUSPEND)                                                                 //USB×ÜÏß¹ÒÆð/»½ÐÑÍê³
             -É
 509   1          {
 510   2              UIF_SUSPEND = 0;
C51 COMPILER V9.56.0.0   CDC                                                               11/08/2019 05:34:28 PAGE 10  

 511   2              if ( USB_MIS_ST & bUMS_SUSPEND )                                             //¹ÒÆð
 512   2              {
 513   3      #ifdef DE_PRINTF
 514   3                  printf( "suspend\n" );                                                             //Ë¯Ãß×´Ì¬
 515   3      #endif
 516   3                  while ( XBUS_AUX & bUART0_TX )
 517   3                  {
 518   4                      ;    //µÈ´ý·¢ËÍÍê³É
 519   4                  }
 520   3                  SAFE_MOD = 0x55;
 521   3                  SAFE_MOD = 0xAA;
 522   3                  WAKE_CTRL = bWAK_BY_USB | bWAK_RXD0_LO | bWAK_RXD1_LO;                      //USB»òÕßRXD0/1ÓÐÐ
             -ÅºÅÊ±¿É±»»½ÐÑ
 523   3                  PCON |= PD;                                                                 //Ë¯Ãß
 524   3                  SAFE_MOD = 0x55;
 525   3                  SAFE_MOD = 0xAA;
 526   3                  WAKE_CTRL = 0x00;
 527   3              }
 528   2          }
 529   1          else {                                                                             //ÒâÍâµÄÖÐ¶Ï,²»¿ÉÄÜ
             -·¢ÉúµÄÇé¿ö
 530   2              USB_INT_FG = 0xFF;                                                             //ÇåÖÐ¶Ï±êÖ¾
 531   2      
 532   2          }
 533   1      }
 534          /*******************************************************************************
 535          * Function Name  : Uart1_ISR()
 536          * Description    : ´®¿Ú½ÓÊÕÖÐ¶Ïº¯Êý£¬ÊµÏÖÑ­»·»º³å½ÓÊÕ
 537          *******************************************************************************/
 538          void Uart1_ISR(void) interrupt INT_NO_UART1
 539          {
 540   1        if(U1RI)   //ÊÕµ½Êý¾Ý
 541   1        {
 542   2          Receive_Uart_Buf[Uart_Input_Point++] = SBUF1;
 543   2          UartByteCount++;                    //µ±Ç°»º³åÇøÊ£Óà´ýÈ¡×Ö½ÚÊý
 544   2          if(Uart_Input_Point>=UART_REV_LEN)
 545   2            Uart_Input_Point = 0;           //Ð´ÈëÖ¸Õë
 546   2          U1RI =0;    
 547   2        }
 548   1        
 549   1      }
 550          
 551          void Fill_Buffer(UINT8 dat)
 552          {
 553   1        Receive_Uart_Buf[Uart_Input_Point++] = dat;
 554   1        UartByteCount++;                    //µ±Ç°»º³åÇøÊ£Óà´ýÈ¡×Ö½ÚÊý
 555   1        if(Uart_Input_Point>=UART_REV_LEN)
 556   1          Uart_Input_Point = 0;           //Ð´ÈëÖ¸Õë
 557   1      }
 558          
 559          sbit LED0 = P1^6;
 560          sbit LED1 = P1^7;
 561          
 562          //Ö÷º¯Êý
 563          main()
 564          {
 565   1          UINT8 lenth;
 566   1          UINT8 Uart_Timeout = 0;
 567   1          UINT8 key = 0;
 568   1          CfgFsys( );                                                           //CH559Ê±ÖÓÑ¡ÔñÅäÖÃ
 569   1          mDelaymS(5);                                                          //ÐÞ¸ÄÖ÷ÆµµÈ´ýÄÚ²¿¾§ÕñÎÈ¶¨,±Ø¼Ó 
 570   1          mInitSTDIO( );                                                        //´®¿Ú0,¿ÉÒÔÓÃÓÚµ÷ÊÔ
C51 COMPILER V9.56.0.0   CDC                                                               11/08/2019 05:34:28 PAGE 11  

 571   1      //    UART1Setup( );                                                        //ÓÃÓÚCDC
 572   1      
 573   1          TK_Init( BIT4+BIT5+BIT6+BIT7,  1, 1 );    /* Choose TIN2, TIN3, TIN4, TIN5 for touchkey input. enable inte
             -rrupt. */
 574   1          TK_SelectChannel(0);                      /* NOTICE: ch is not compatible with the IO actually. */
 575   1      
 576   1      //    Port1Cfg(1,6);                                                             //P16ÉèÖÃÍÆÍìÄ£Ê½
 577   1      //    Port1Cfg(1,7);                                                             //P17ÉèÖÃÍÆÍìÄ£Ê½
 578   1      //    LED0 = 0;
 579   1      //    LED1 = 0; 
 580   1        
 581   1      #ifdef DE_PRINTF
 582   1          printf("start ...\n");
 583   1      #endif  
 584   1          USBDeviceCfg();                                                    
 585   1          USBDeviceEndPointCfg();                                               //¶ËµãÅäÖÃ
 586   1          USBDeviceIntCfg();                                                    //ÖÐ¶Ï³õÊ¼»¯
 587   1          UEP0_T_LEN = 0;
 588   1          UEP1_T_LEN = 0;                                                       //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 589   1          UEP2_T_LEN = 0;                                                       //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 590   1        
 591   1          while(1)
 592   1          {
 593   2            if( Touch_IN != 0 )
 594   2            {
 595   3              key = Touch_IN;
 596   3              Touch_IN = 0;
 597   3              Fill_Buffer(key);
 598   3            }
 599   2              if(UsbConfig)
 600   2              {
 601   3                if(USBByteCount)  //usb ½ÓÊÕ¶ËÓÐÊý¾Ý
 602   3                {
 603   4                  USBByteCount = 0;
 604   4                  UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_R_RES | UEP_R_RES_ACK; //
 605   4                }
 606   3                if(UartByteCount)
 607   3                  Uart_Timeout++;
 608   3                if(!UpPoint2_Busy)   //¶Ëµã²»·±Ã¦£¨¿ÕÏÐºóµÄµÚÒ»°üÊý¾Ý£¬Ö»ÓÃ×÷´¥·¢ÉÏ´«£©
 609   3                {
 610   4                    if(UartByteCount)
 611   4                    {
 612   5                      lenth = UartByteCount;
 613   5                      if(lenth>0)
 614   5                      {
 615   6                        if(lenth>39 || Uart_Timeout>100)
 616   6                        {     
 617   7                          Uart_Timeout = 0;
 618   7                          if(Uart_Output_Point+lenth>UART_REV_LEN)
 619   7                            lenth = UART_REV_LEN-Uart_Output_Point;
 620   7                          UartByteCount -= lenth;     
 621   7                          //Ð´ÉÏ´«¶Ëµã
 622   7                          memcpy(Ep2Buffer+MAX_PACKET_SIZE,&Receive_Uart_Buf[Uart_Output_Point],lenth);
 623   7                          Uart_Output_Point+=lenth;
 624   7                          if(Uart_Output_Point>=UART_REV_LEN)
 625   7                            Uart_Output_Point = 0;            
 626   7                          UEP2_T_LEN = lenth;                                                    //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿
             -Õ
 627   7                          UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK;            //Ó¦´ðACK
 628   7                          UpPoint2_Busy = 1;
 629   7                        }
 630   6                      }
C51 COMPILER V9.56.0.0   CDC                                                               11/08/2019 05:34:28 PAGE 12  

 631   5                    }
 632   4                }
 633   3              }   
 634   2          }
 635   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1870    ----
   CONSTANT SIZE    =    166    ----
   XDATA SIZE       =     23       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     70    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
