C51 COMPILER V9.56.0.0   COMPATIBILITYHID                                                  11/08/2019 18:23:07 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE COMPATIBILITYHID
OBJECT MODULE PLACED IN CompatibilityHID.OBJ
COMPILER INVOKED BY: C:\Keil_v5_c51\C51\BIN\C51.EXE CompatibilityHID.C LARGE OPTIMIZE(8,SPEED) BROWSE NOAREGS INCDIR(..\
                    -VendorDefinedDev) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          
   2          /********************************** (C) COPYRIGHT *******************************
   3          * File Name          :CompatibilityHID.C
   4          * Author             : WCH
   5          * Version            : V1.2
   6          * Date               : 2018/02/28
   7          * Description        : CH554Ä£ÄâHID¼æÈÝÉè±¸£¬Ö§³ÖÖÐ¶ÏÉÏÏÂ´«£¬Ö§³Ö¿ØÖÆ¶ËµãÉÏÏÂ´«£¬Ö§³ÖÉèÖÃÈ«ËÙ£¬µÍËÙ 
   8          *******************************************************************************/
   9          
  10          #include "CH554.H"
  11          #include "Debug.H"
  12          #include <stdio.h>
  13          #include <string.h>
  14          
  15          #define Fullspeed               1
  16          
  17          #ifdef  Fullspeed
  18          #define THIS_ENDP0_SIZE         64
  19          #else
              #define THIS_ENDP0_SIZE         8                                                  //µÍËÙUSB£¬ÖÐ¶Ï´«Êä¡¢¿Ø
             -ÖÆ´«Êä×î´ó°ü³¤¶ÈÎª8
              #endif
  22          UINT8X  Ep0Buffer[8>(THIS_ENDP0_SIZE+2)?8:(THIS_ENDP0_SIZE+2)] _at_ 0x0000;        //¶Ëµã0 OUT&IN»º³åÇø£¬±
             -ØÐëÊÇÅ¼µØÖ·
  23          UINT8X  Ep2Buffer[128>(2*MAX_PACKET_SIZE+4)?128:(2*MAX_PACKET_SIZE+4)] _at_ 0x0044;//¶Ëµã2 IN&OUT»º³åÇø,±Ø
             -ÐëÊÇÅ¼µØÖ·
  24          UINT8   SetupReq,SetupLen,Ready,Count,FLAG,UsbConfig;
  25          PUINT8  pDescr;                                                                    //USBÅäÖÃ±êÖ¾
  26          USB_SETUP_REQ   SetupReqBuf;                                                       //ÔÝ´æSetup°ü
  27          #define UsbSetupBuf     ((PUSB_SETUP_REQ)Ep0Buffer)  
  28          
  29          sbit Ep2InKey = P1^5;                                                              //K1°´¼ü
  30          #pragma  NOAREGS
  31          /*Éè±¸ÃèÊö·û*/
  32          UINT8C DevDesc[18] = {0x12,0x01,0x10,0x01,0x00,0x00,0x00,THIS_ENDP0_SIZE,
  33                                0x31,0x51,0x07,0x20,0x00,0x00,0x00,0x00,
  34                                0x00,0x01
  35                               };
  36          UINT8C CfgDesc[41] =
  37          {
  38              0x09,0x02,0x29,0x00,0x01,0x01,0x04,0xA0,0x23,               //ÅäÖÃÃèÊö·û
  39              0x09,0x04,0x00,0x00,0x02,0x03,0x00,0x00,0x05,               //½Ó¿ÚÃèÊö·û
  40              0x09,0x21,0x00,0x01,0x00,0x01,0x22,0x22,0x00,               //HIDÀàÃèÊö·û
  41          #ifdef  Fullspeed 
  42              0x07,0x05,0x82,0x03,THIS_ENDP0_SIZE,0x00,0x01,              //¶ËµãÃèÊö·û(È«ËÙ¼ä¸ôÊ±¼ä¸Ä³É1ms)
  43              0x07,0x05,0x02,0x03,THIS_ENDP0_SIZE,0x00,0x01,              //¶ËµãÃèÊö·û
  44          #else
                  0x07,0x05,0x82,0x03,THIS_ENDP0_SIZE,0x00,0x0A,              //¶ËµãÃèÊö·û(µÍËÙ¼ä¸ôÊ±¼ä×îÐ¡10ms)
                  0x07,0x05,0x02,0x03,THIS_ENDP0_SIZE,0x00,0x0A,              //¶ËµãÃèÊö·û
              #endif  
  48          };
  49          /*×Ö·û´®ÃèÊö·û ÂÔ*/ 
  50          
  51          /*HIDÀà±¨±íÃèÊö·û*/
C51 COMPILER V9.56.0.0   COMPATIBILITYHID                                                  11/08/2019 18:23:07 PAGE 2   

  52          UINT8C HIDRepDesc[ ] =
  53          {
  54              0x06, 0x00,0xff,
  55              0x09, 0x01,
  56              0xa1, 0x01,                                                   //¼¯ºÏ¿ªÊ¼
  57              0x09, 0x02,                                                   //Usage Page  ÓÃ·¨
  58              0x15, 0x00,                                                   //Logical  Minimun
  59              0x26, 0x00,0xff,                                              //Logical  Maximun
  60              0x75, 0x08,                                                   //Report Size
  61              0x95, THIS_ENDP0_SIZE,                                        //Report Counet
  62              0x81, 0x06,                                                   //Input
  63              0x09, 0x02,                                                   //Usage Page  ÓÃ·¨
  64              0x15, 0x00,                                                   //Logical  Minimun
  65              0x26, 0x00,0xff,                                              //Logical  Maximun
  66              0x75, 0x08,                                                   //Report Size
  67              0x95, THIS_ENDP0_SIZE,                                        //Report Counet
  68              0x91, 0x06,                                                   //Output
  69              0xC0
  70          };
  71          // unsigned char  code LangDes[]={0x04,0x03,0x09,0x04};           //ÓïÑÔÃèÊö·û
  72          // unsigned char  code SerDes[]={
  73          //                           0x28,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  74          //                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  75          //                           0x00,0x00,0x00,0x00,0x00,0x49,0x00,0x43,0x00,0x42,
  76          //                           0x00,0x43,0x00,0x31,0x00,0x00,0x00,0x00,0x00,0x00
  77          //                           };                                   //×Ö·û´®ÃèÊö·û
  78          
  79          UINT8X UserEp2Buf[64];                                            //ÓÃ»§Êý¾Ý¶¨Òå
  80          UINT8 Endp2Busy = 0;
  81          
  82          /*******************************************************************************
  83          * Function Name  : USBDeviceInit()
  84          * Description    : USBÉè±¸Ä£Ê½ÅäÖÃ,Éè±¸Ä£Ê½Æô¶¯£¬ÊÕ·¢¶ËµãÅäÖÃ£¬ÖÐ¶Ï¿ªÆô
  85          * Input          : None
  86          * Output         : None
  87          * Return         : None
  88          *******************************************************************************/
  89          void USBDeviceInit()
  90          {
  91   1        IE_USB = 0;
  92   1        USB_CTRL = 0x00;                                                           // ÏÈÉè¶¨USBÉè±¸Ä£Ê½
  93   1        UDEV_CTRL = bUD_PD_DIS;                                                    // ½ûÖ¹DP/DMÏÂÀ­µç×è 
  94   1      #ifndef Fullspeed
                  UDEV_CTRL |= bUD_LOW_SPEED;                                                //Ñ¡ÔñµÍËÙ1.5MÄ£Ê½
                  USB_CTRL |= bUC_LOW_SPEED;
              #else
  98   1          UDEV_CTRL &= ~bUD_LOW_SPEED;                                               //Ñ¡ÔñÈ«ËÙ12MÄ£Ê½£¬Ä¬ÈÏ·½Ê½
  99   1          USB_CTRL &= ~bUC_LOW_SPEED;
 100   1      #endif
 101   1          UEP2_DMA = Ep2Buffer;                                                      //¶Ëµã2Êý¾Ý´«ÊäµØÖ·
 102   1          UEP2_3_MOD |= bUEP2_TX_EN | bUEP2_RX_EN;                                   //¶Ëµã2·¢ËÍ½ÓÊÕÊ¹ÄÜ
 103   1          UEP2_3_MOD &= ~bUEP2_BUF_MOD;                                              //¶Ëµã2ÊÕ·¢¸÷64×Ö½Ú»º³åÇø
 104   1          UEP2_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK | UEP_R_RES_ACK;                 //¶Ëµã2×Ô¶¯·­×ªÍ¬²½±êÖ¾Î»£¬
             -INÊÂÎñ·µ»ØNAK£¬OUT·µ»ØACK
 105   1          UEP0_DMA = Ep0Buffer;                                                      //¶Ëµã0Êý¾Ý´«ÊäµØÖ·
 106   1          UEP4_1_MOD &= ~(bUEP4_RX_EN | bUEP4_TX_EN);                                //¶Ëµã0µ¥64×Ö½ÚÊÕ·¢»º³åÇø
 107   1          UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;                                 //OUTÊÂÎñ·µ»ØACK£¬INÊÂÎñ·µ»
             -ØNAK
 108   1          
 109   1        USB_DEV_AD = 0x00;
 110   1        USB_CTRL |= bUC_DEV_PU_EN | bUC_INT_BUSY | bUC_DMA_EN;                     // Æô¶¯USBÉè±¸¼°DMA£¬ÔÚÖÐ¶ÏÆÚ¼
             -äÖÐ¶Ï±êÖ¾Î´Çå³ýÇ°×Ô¶¯·µ»ØNAK
C51 COMPILER V9.56.0.0   COMPATIBILITYHID                                                  11/08/2019 18:23:07 PAGE 3   

 111   1        UDEV_CTRL |= bUD_PORT_EN;                                                  // ÔÊÐíUSB¶Ë¿Ú
 112   1        USB_INT_FG = 0xFF;                                                         // ÇåÖÐ¶Ï±êÖ¾
 113   1        USB_INT_EN = bUIE_SUSPEND | bUIE_TRANSFER | bUIE_BUS_RST;
 114   1        IE_USB = 1;
 115   1      }
 116          
 117          /*******************************************************************************
 118          * Function Name  : Enp2BlukIn()
 119          * Description    : USBÉè±¸Ä£Ê½¶Ëµã2µÄÅúÁ¿ÉÏ´«
 120          * Input          : None
 121          * Output         : None
 122          * Return         : None
 123          *******************************************************************************/
 124          void Enp2BlukIn( )
 125          {
 126   1          memcpy( Ep2Buffer+MAX_PACKET_SIZE, UserEp2Buf, sizeof(UserEp2Buf));        //¼ÓÔØÉÏ´«Êý¾Ý
 127   1          UEP2_T_LEN = THIS_ENDP0_SIZE;                                              //ÉÏ´«×î´ó°ü³¤¶È
 128   1          UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK;                  //ÓÐÊý¾ÝÊ±ÉÏ´«Êý¾Ý²¢Ó¦´ðACK
 129   1      }
 130          
 131          /*******************************************************************************
 132          * Function Name  : DeviceInterrupt()
 133          * Description    : CH559USBÖÐ¶Ï´¦Àíº¯Êý
 134          *******************************************************************************/
 135          void DeviceInterrupt( void ) interrupt INT_NO_USB using 1                    //USBÖÐ¶Ï·þÎñ³ÌÐò,Ê¹ÓÃ¼Ä´æÆ÷×
             -é1
 136          {
 137   1          UINT8 len,i;
 138   1          if(UIF_TRANSFER)                                                            //USB´«ÊäÍê³É±êÖ¾
 139   1          {
 140   2              switch (USB_INT_ST & (MASK_UIS_TOKEN | MASK_UIS_ENDP))
 141   2              {
 142   3              case UIS_TOKEN_IN | 2:                                                  //endpoint 2# ¶ËµãÅúÁ¿ÉÏ´«
 143   3                  UEP2_T_LEN = 0;                                                    //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 144   3      //            UEP1_CTRL ^= bUEP_T_TOG;                                          //Èç¹û²»ÉèÖÃ×Ô¶¯·­×ªÔòÐèÒª
             -ÊÖ¶¯·­×ª
 145   3                  Endp2Busy = 0 ;
 146   3            UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;           //Ä¬ÈÏÓ¦´ðNAK
 147   3                  break;
 148   3              case UIS_TOKEN_OUT | 2:                                                 //endpoint 2# ¶ËµãÅúÁ¿ÏÂ´«
 149   3                  if ( U_TOG_OK )                                                     // ²»Í¬²½µÄÊý¾Ý°ü½«¶ªÆú
 150   3                  {
 151   4                      len = USB_RX_LEN;                                               //½ÓÊÕÊý¾Ý³¤¶È£¬Êý¾Ý´ÓEp2B
             -ufferÊ×µØÖ·¿ªÊ¼´æ·Å
 152   4                      for ( i = 0; i < len; i ++ )
 153   4                      {
 154   5                          Ep2Buffer[MAX_PACKET_SIZE+i] = Ep2Buffer[i] ^ 0xFF;         // OUTÊý¾ÝÈ¡·´µ½INÓÉ¼ÆËã»ú
             -ÑéÖ¤
 155   5                      }
 156   4                      UEP2_T_LEN = len;
 157   4                      UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK;       // ÔÊÐíÉÏ´«
 158   4                  }
 159   3                  break;
 160   3              case UIS_TOKEN_SETUP | 0:                                               //SETUPÊÂÎñ
 161   3                  len = USB_RX_LEN;
 162   3                  if(len == (sizeof(USB_SETUP_REQ)))
 163   3                  {
 164   4                      SetupLen = UsbSetupBuf->wLengthL;
 165   4                      len = 0;                                                         // Ä¬ÈÏÎª³É¹¦²¢ÇÒÉÏ´«0³¤¶
             -È
 166   4                      SetupReq = UsbSetupBuf->bRequest;             
 167   4                      if ( ( UsbSetupBuf->bRequestType & USB_REQ_TYP_MASK ) != USB_REQ_TYP_STANDARD )/*HIDÀàÃüÁî
C51 COMPILER V9.56.0.0   COMPATIBILITYHID                                                  11/08/2019 18:23:07 PAGE 4   

             -*/
 168   4                      {
 169   5                switch( SetupReq )                                             
 170   5                {
 171   6                  case 0x01:                                                  //GetReport
 172   6                    pDescr = UserEp2Buf;                                    //¿ØÖÆ¶ËµãÉÏ´«Êä¾Ý
 173   6                    if(SetupLen >= THIS_ENDP0_SIZE)                         //´óÓÚ¶Ëµã0´óÐ¡£¬ÐèÒªÌØÊâ´¦Àí
 174   6                    {
 175   7                      len = THIS_ENDP0_SIZE;
 176   7                    }                          
 177   6                    else
 178   6                    {                          
 179   7                      len = SetupLen;                                   
 180   7                    }                          
 181   6                    break;
 182   6                  case 0x02:                                                   //GetIdle
 183   6                    break;  
 184   6                  case 0x03:                                                   //GetProtocol
 185   6                    break;        
 186   6                  case 0x09:                                                   //SetReport                    
 187   6                    break; 
 188   6                  case 0x0A:                                                   //SetIdle
 189   6                    break;  
 190   6                  case 0x0B:                                                   //SetProtocol
 191   6                    break;
 192   6                  default:
 193   6                    len = 0xFF;                                       /*ÃüÁî²»Ö§³Ö*/          
 194   6                    break;
 195   6                } 
 196   5                if( SetupLen > len )
 197   5                {
 198   6                  SetupLen = len;    //ÏÞÖÆ×Ü³¤¶È
 199   6                }
 200   5                len = SetupLen >= THIS_ENDP0_SIZE ? THIS_ENDP0_SIZE : SetupLen;   //±¾´Î´«Êä³¤¶È
 201   5                memcpy(Ep0Buffer,pDescr,len);                                     //¼ÓÔØÉÏ´«Êý¾Ý
 202   5                SetupLen -= len;
 203   5                pDescr += len;                  
 204   5                      }
 205   4                      else                                                             //±ê×¼ÇëÇó
 206   4                      {
 207   5                          switch(SetupReq)                                             //ÇëÇóÂë
 208   5                          {
 209   6                          case USB_GET_DESCRIPTOR:
 210   6                              switch(UsbSetupBuf->wValueH)
 211   6                              {
 212   7                              case 1:                                                  //Éè±¸ÃèÊö·û
 213   7                                  pDescr = DevDesc;                                    //°ÑÉè±¸ÃèÊö·ûËÍµ½Òª·¢ËÍµ
             -Ä»º³åÇø
 214   7                                  len = sizeof(DevDesc);
 215   7                                  break;
 216   7                              case 2:                                                  //ÅäÖÃÃèÊö·û
 217   7                                  pDescr = CfgDesc;                                    //°ÑÉè±¸ÃèÊö·ûËÍµ½Òª·¢ËÍµ
             -Ä»º³åÇø
 218   7                                  len = sizeof(CfgDesc);
 219   7                                  break;
 220   7                              case 0x22:                                               //±¨±íÃèÊö·û
 221   7                                  pDescr = HIDRepDesc;                                 //Êý¾Ý×¼±¸ÉÏ´«
 222   7                                  len = sizeof(HIDRepDesc);                            
 223   7                                  break;
 224   7                              default:
 225   7                                  len = 0xff;                                          //²»Ö§³ÖµÄÃüÁî»òÕß³ö´í
 226   7                                  break;
C51 COMPILER V9.56.0.0   COMPATIBILITYHID                                                  11/08/2019 18:23:07 PAGE 5   

 227   7                              }
 228   6                              if ( SetupLen > len )
 229   6                              {
 230   7                                  SetupLen = len;    //ÏÞÖÆ×Ü³¤¶È
 231   7                              }
 232   6                              len = SetupLen >= THIS_ENDP0_SIZE ? THIS_ENDP0_SIZE : SetupLen;//±¾´Î´«Êä³¤¶È
 233   6                              memcpy(Ep0Buffer,pDescr,len);                            //¼ÓÔØÉÏ´«Êý¾Ý
 234   6                              SetupLen -= len;
 235   6                              pDescr += len;
 236   6                              break;
 237   6                          case USB_SET_ADDRESS:
 238   6                              SetupLen = UsbSetupBuf->wValueL;                         //ÔÝ´æUSBÉè±¸µØÖ·
 239   6                              break;
 240   6                          case USB_GET_CONFIGURATION:
 241   6                              Ep0Buffer[0] = UsbConfig;
 242   6                              if ( SetupLen >= 1 )
 243   6                              {
 244   7                                  len = 1;
 245   7                              }
 246   6                              break;
 247   6                          case USB_SET_CONFIGURATION:
 248   6                              UsbConfig = UsbSetupBuf->wValueL;
 249   6                  if(UsbConfig)
 250   6                  {
 251   7                    Ready = 1;                                            //set configÃüÁîÒ»°ã´ú±íusbÃ¶¾ÙÍê³ÉµÄ±êÖ¾
 252   7                  }
 253   6                              break;
 254   6                          case 0x0A:
 255   6                              break;
 256   6                          case USB_CLEAR_FEATURE:                                      //Clear Feature
 257   6                              if ( ( UsbSetupBuf->bRequestType & USB_REQ_RECIP_MASK ) == USB_REQ_RECIP_ENDP )// 
             -¶Ëµã
 258   6                              {
 259   7                                  switch( UsbSetupBuf->wIndexL )
 260   7                                  {
 261   8                                  case 0x82:
 262   8                                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 263   8                                      break;
 264   8                                  case 0x81:
 265   8                                      UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 266   8                                      break;
 267   8                                  case 0x02:
 268   8                                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 269   8                                      break;
 270   8                                  default:
 271   8                                      len = 0xFF;                                       // ²»Ö§³ÖµÄ¶Ëµã
 272   8                                      break;
 273   8                                  }
 274   7                              }
 275   6                              else
 276   6                              {
 277   7                                  len = 0xFF;                                           // ²»ÊÇ¶Ëµã²»Ö§³Ö
 278   7                              }
 279   6                              break;
 280   6                          case USB_SET_FEATURE:                                         /* Set Feature */
 281   6                              if( ( UsbSetupBuf->bRequestType & 0x1F ) == 0x00 )        /* ÉèÖÃÉè±¸ */
 282   6                              {
 283   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x01
             - )
 284   7                                  {
 285   8                                      if( CfgDesc[ 7 ] & 0x20 )
 286   8                                      {
C51 COMPILER V9.56.0.0   COMPATIBILITYHID                                                  11/08/2019 18:23:07 PAGE 6   

 287   9                                          /* ÉèÖÃ»½ÐÑÊ¹ÄÜ±êÖ¾ */
 288   9                                      }
 289   8                                      else
 290   8                                      {
 291   9                                          len = 0xFF;                                    /* ²Ù×÷Ê§°Ü */
 292   9                                      }
 293   8                                  }
 294   7                                  else
 295   7                                  {
 296   8                                      len = 0xFF;                                        /* ²Ù×÷Ê§°Ü */
 297   8                                  }
 298   7                              }
 299   6                              else if( ( UsbSetupBuf->bRequestType & 0x1F ) == 0x02 )    /* ÉèÖÃ¶Ëµã */
 300   6                              {
 301   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x00
             - )
 302   7                                  {
 303   8                                      switch( ( ( UINT16 )UsbSetupBuf->wIndexH << 8 ) | UsbSetupBuf->wIndexL )
 304   8                                      {
 305   9                                      case 0x82:
 306   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã2 I
             -N STALL */
 307   9                                          break;
 308   9                                      case 0x02:
 309   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* ÉèÖÃ¶Ëµã2 O
             -UT Stall */
 310   9                                          break;
 311   9                                      case 0x81:
 312   9                                          UEP1_CTRL = UEP1_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã1 I
             -N STALL */
 313   9                                          break;
 314   9                                      default:
 315   9                                          len = 0xFF;                                     /* ²Ù×÷Ê§°Ü */
 316   9                                          break;
 317   9                                      }
 318   8                                  }
 319   7                                  else
 320   7                                  {
 321   8                                      len = 0xFF;                                         /* ²Ù×÷Ê§°Ü */
 322   8                                  }
 323   7                              }
 324   6                              else
 325   6                              {
 326   7                                  len = 0xFF;                                             /* ²Ù×÷Ê§°Ü */
 327   7                              } 
 328   6                              break;
 329   6                          case USB_GET_STATUS:
 330   6                              Ep0Buffer[0] = 0x00;
 331   6                              Ep0Buffer[1] = 0x00;
 332   6                              if ( SetupLen >= 2 )
 333   6                              {
 334   7                                  len = 2;
 335   7                              }
 336   6                              else
 337   6                              {
 338   7                                  len = SetupLen;
 339   7                              }
 340   6                              break;
 341   6                          default:
 342   6                              len = 0xff;                                                  //²Ù×÷Ê§°Ü
 343   6                              break;
 344   6                          }
C51 COMPILER V9.56.0.0   COMPATIBILITYHID                                                  11/08/2019 18:23:07 PAGE 7   

 345   5                      }
 346   4                  }
 347   3                  else
 348   3                  {
 349   4                      len = 0xff;                                                          //°ü³¤¶È´íÎó
 350   4                  }
 351   3                  if(len == 0xff)
 352   3                  {
 353   4                      SetupReq = 0xFF;
 354   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;//STALL
 355   4                  }
 356   3                  else if(len <= THIS_ENDP0_SIZE)                                         //ÉÏ´«Êý¾Ý»òÕß×´Ì¬½×¶Î
             -·µ»Ø0³¤¶È°ü
 357   3                  {
 358   4                      UEP0_T_LEN = len;
 359   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA1£¬·
             -µ»ØÓ¦´ðACK
 360   4                  }
 361   3                  else
 362   3                  {
 363   4                      UEP0_T_LEN = 0;  //ËäÈ»ÉÐÎ´µ½×´Ì¬½×¶Î£¬µ«ÊÇÌáÇ°Ô¤ÖÃÉÏ´«0³¤¶ÈÊý¾Ý°üÒÔ·ÀÖ÷»úÌáÇ°½øÈë×´Ì¬½×¶Î
 364   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA1,·µ
             -»ØÓ¦´ðACK
 365   4                  }
 366   3                  break;
 367   3              case UIS_TOKEN_IN | 0:                                                      //endpoint0 IN
 368   3                  switch(SetupReq)
 369   3                  {
 370   4                  case USB_GET_DESCRIPTOR:
 371   4                  case HID_GET_REPORT:              
 372   4                      len = SetupLen >= THIS_ENDP0_SIZE ? THIS_ENDP0_SIZE : SetupLen;     //±¾´Î´«Êä³¤¶È
 373   4                      memcpy( Ep0Buffer, pDescr, len );                                   //¼ÓÔØÉÏ´«Êý¾Ý
 374   4                      SetupLen -= len;
 375   4                      pDescr += len;
 376   4                      UEP0_T_LEN = len;
 377   4                      UEP0_CTRL ^= bUEP_T_TOG;                                            //Í¬²½±êÖ¾Î»·­×ª
 378   4                      break;
 379   4                  case USB_SET_ADDRESS:
 380   4                      USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | SetupLen;
 381   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 382   4                      break;
 383   4                  default:
 384   4                      UEP0_T_LEN = 0;                                                      //×´Ì¬½×¶ÎÍê³ÉÖÐ¶Ï»òÕ
             -ßÊÇÇ¿ÖÆÉÏ´«0³¤¶ÈÊý¾Ý°ü½áÊø¿ØÖÆ´«Êä
 385   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 386   4                      break;
 387   4                  }
 388   3                  break;
 389   3              case UIS_TOKEN_OUT | 0:  // endpoint0 OUT
 390   3                  len = USB_RX_LEN;
 391   3                  if(SetupReq == 0x09)
 392   3                  {
 393   4                      if(Ep0Buffer[0])
 394   4                      {
 395   5                          printf("Light on Num Lock LED!\n");
 396   5                      }
 397   4                      else if(Ep0Buffer[0] == 0)
 398   4                      {
 399   5                          printf("Light off Num Lock LED!\n");
 400   5                      }
 401   4                  }
 402   3                  UEP0_CTRL ^= bUEP_R_TOG;                                     //Í¬²½±êÖ¾Î»·­×ª   
C51 COMPILER V9.56.0.0   COMPATIBILITYHID                                                  11/08/2019 18:23:07 PAGE 8   

 403   3                  break;
 404   3              default:
 405   3                  break;
 406   3              }
 407   2              UIF_TRANSFER = 0;                                                           //Ð´0Çå¿ÕÖÐ¶Ï
 408   2          }
 409   1          if(UIF_BUS_RST)                                                                 //Éè±¸Ä£Ê½USB×ÜÏß¸´Î»Ö
             -Ð¶Ï
 410   1          {
 411   2              UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 412   2              UEP1_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK;
 413   2              UEP2_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK | UEP_T_RES_NAK;
 414   2              USB_DEV_AD = 0x00;
 415   2              UIF_SUSPEND = 0;
 416   2              UIF_TRANSFER = 0;
 417   2          Endp2Busy = 0;
 418   2              UIF_BUS_RST = 0;                                                             //ÇåÖÐ¶Ï±êÖ¾
 419   2          }
 420   1          if (UIF_SUSPEND)                                                                 //USB×ÜÏß¹ÒÆð/»½ÐÑÍê³
             -É
 421   1          {
 422   2              UIF_SUSPEND = 0;
 423   2              if ( USB_MIS_ST & bUMS_SUSPEND )                                             //¹ÒÆð
 424   2              {
 425   3      #ifdef DE_PRINTF
 426   3                  printf( "zz" );                                                          //Ë¯Ãß×´Ì¬
 427   3      #endif
 428   3      //             while ( XBUS_AUX & bUART0_TX )
 429   3      //             {
 430   3      //                 ;    //µÈ´ý·¢ËÍÍê³É
 431   3      //             }
 432   3      //             SAFE_MOD = 0x55;
 433   3      //             SAFE_MOD = 0xAA;
 434   3      //             WAKE_CTRL = bWAK_BY_USB | bWAK_RXD0_LO;                                   //USB»òÕßRXD0ÓÐÐÅ
             -ºÅÊ±¿É±»»½ÐÑ
 435   3      //             PCON |= PD;                                                               //Ë¯Ãß
 436   3      //             SAFE_MOD = 0x55;
 437   3      //             SAFE_MOD = 0xAA;
 438   3      //             WAKE_CTRL = 0x00;
 439   3              }
 440   2          }
 441   1          else {                                                                             //ÒâÍâµÄÖÐ¶Ï,²»¿ÉÄÜ
             -·¢ÉúµÄÇé¿ö
 442   2              USB_INT_FG = 0xFF;                                                             //ÇåÖÐ¶Ï±êÖ¾
 443   2      //      printf("UnknownInt  N");
 444   2          }
 445   1      }
 446          
 447          main()
 448          {
 449   1          UINT8 i;
 450   1          CfgFsys( );                                                           //CH559Ê±ÖÓÑ¡ÔñÅäÖÃ
 451   1          mDelaymS(5);                                                          //ÐÞ¸ÄÖ÷ÆµµÈ´ýÄÚ²¿¾§ÕñÎÈ¶¨,±Ø¼Ó 
 452   1          mInitSTDIO( );                                                        //´®¿Ú0³õÊ¼»¯
 453   1      #ifdef DE_PRINTF
 454   1          printf("start ...\n");
 455   1      #endif  
 456   1          for(i=0; i<64; i++)                                                   //×¼±¸ÑÝÊ¾Êý¾Ý
 457   1          {
 458   2              UserEp2Buf[i] = i;
 459   2          }
 460   1          USBDeviceInit();                                                      //USBÉè±¸Ä£Ê½³õÊ¼»¯
C51 COMPILER V9.56.0.0   COMPATIBILITYHID                                                  11/08/2019 18:23:07 PAGE 9   

 461   1          EA = 1;                                                               //ÔÊÐíµ¥Æ¬»úÖÐ¶Ï    
 462   1          UEP1_T_LEN = 0;                                                       //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 463   1          UEP2_T_LEN = 0;                                                       //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 464   1          FLAG = 0;
 465   1          Ready = 0;
 466   1          while(1)
 467   1          {
 468   2              if(Ready && (Ep2InKey==0))
 469   2              {
 470   3                  while( Endp2Busy );                                            //Èç¹ûÃ¦£¨ÉÏÒ»°üÊý¾ÝÃ»ÓÐ´«ÉÏÈ¥£©£¬Ôòµ
             -È´ý¡£
 471   3                  Endp2Busy = 1;                                                 //ÉèÖÃÎªÃ¦×´Ì¬
 472   3                  Enp2BlukIn( );
 473   3                  mDelaymS( 2000 );
 474   3              }
 475   2              mDelaymS( 1000 );                                                 //Ä£Äâµ¥Æ¬»ú×öÆäËüÊÂ
 476   2          }
 477   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1211    ----
   CONSTANT SIZE    =    156    ----
   XDATA SIZE       =     82       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
