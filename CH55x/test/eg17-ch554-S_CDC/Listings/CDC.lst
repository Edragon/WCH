C51 COMPILER V9.60.0.0   CDC                                                               11/11/2019 01:03:46 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE CDC
OBJECT MODULE PLACED IN .\Objects\CDC.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE CDC.C LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Public) DEBUG OBJECTEXTEND
                    - PRINT(.\Listings\CDC.lst) TABS(2) OBJECT(.\Objects\CDC.obj)

line level    source

   1          /********************************** (C) COPYRIGHT *******************************
   2          * File Name          : CDC.C
   3          * Author             : WCH
   4          * Version            : V1.0
   5          * Date               : 2017/03/01
   6          * Description        : CH554×öCDCÉè±¸×ª´®¿Ú£¬Ñ¡Ôñ´®¿Ú1
   7          *******************************************************************************/
   8          #include "CH554.H"
   9          #include "DEBUG.H"
  10          #include "GPIO.H"
  11          
  12          #include <stdio.h>
  13          #include <string.h>
  14          
  15          #pragma  NOAREGS
  16          
  17          UINT8X  Ep0Buffer[DEFAULT_ENDP0_SIZE] _at_ 0x0000;                                 //¶Ëµã0 OUT&IN»º³åÇø£¬±
             -ØÐëÊÇÅ¼µØÖ·
  18          UINT8X  Ep1Buffer[8] _at_ 0x0040;                                                  //¶Ëµã1ÉÏ´«»º³åÇø
  19          UINT8X  Ep2Buffer[2*MAX_PACKET_SIZE] _at_ 0x0080;                                  //¶Ëµã2 IN & OUT»º³åÇø,
             -±ØÐëÊÇÅ¼µØÖ·
  20          
  21          UINT16 SetupLen;
  22          UINT8   SetupReq,Count,UsbConfig;
  23          PUINT8  pDescr;                                                                //USBÅäÖÃ±êÖ¾
  24          USB_SETUP_REQ   SetupReqBuf;                                                   //ÔÝ´æSetup°ü
  25          #define UsbSetupBuf     ((PUSB_SETUP_REQ)Ep0Buffer)
  26          
  27          #define  SET_LINE_CODING                0X20            // Configures DTE rate, stop-bits, parity, and num
             -ber-of-character
  28          #define  GET_LINE_CODING                0X21            // This request allows the host to find out the cu
             -rrently configured line coding.
  29          #define  SET_CONTROL_LINE_STATE         0X22            // This request generates RS-232/V.24 style contro
             -l signals.
  30          
  31          
  32          
  33          
  34          /*Éè±¸ÃèÊö·û*/
  35          UINT8C DevDesc[] = {0x12,0x01,0x10,0x01,0x02,0x00,0x00,DEFAULT_ENDP0_SIZE,
  36                              0x86,0x1a,0x22,0x57,0x00,0x01,0x01,0x02,
  37                              0x03,0x01
  38                             };
  39          UINT8C CfgDesc[] ={
  40              0x09,0x02,0x43,0x00,0x02,0x01,0x00,0xa0,0x32,             //ÅäÖÃÃèÊö·û£¨Á½¸ö½Ó¿Ú£©
  41            //ÒÔÏÂÎª½Ó¿Ú0£¨CDC½Ó¿Ú£©ÃèÊö·û  
  42              0x09,0x04,0x00,0x00,0x01,0x02,0x02,0x01,0x00,             //CDC½Ó¿ÚÃèÊö·û(Ò»¸ö¶Ëµã)
  43            //ÒÔÏÂÎª¹¦ÄÜÃèÊö·û
  44              0x05,0x24,0x00,0x10,0x01,                                 //¹¦ÄÜÃèÊö·û(Í·)
  45            0x05,0x24,0x01,0x00,0x00,                                 //¹ÜÀíÃèÊö·û(Ã»ÓÐÊý¾ÝÀà½Ó¿Ú) 03 01
  46            0x04,0x24,0x02,0x02,                                      //Ö§³ÖSet_Line_Coding¡¢Set_Control_Line_State¡¢
             -Get_Line_Coding¡¢Serial_State 
  47            0x05,0x24,0x06,0x00,0x01,                                 //±àºÅÎª0µÄCDC½Ó¿Ú;±àºÅ1µÄÊý¾ÝÀà½Ó¿Ú
  48            0x07,0x05,0x81,0x03,0x08,0x00,0xFF,                       //ÖÐ¶ÏÉÏ´«¶ËµãÃèÊö·û
C51 COMPILER V9.60.0.0   CDC                                                               11/11/2019 01:03:46 PAGE 2   

  49            //ÒÔÏÂÎª½Ó¿Ú1£¨Êý¾Ý½Ó¿Ú£©ÃèÊö·û
  50            0x09,0x04,0x01,0x00,0x02,0x0a,0x00,0x00,0x00,             //Êý¾Ý½Ó¿ÚÃèÊö·û
  51              0x07,0x05,0x02,0x02,0x40,0x00,0x00,                       //¶ËµãÃèÊö·û  
  52            0x07,0x05,0x82,0x02,0x40,0x00,0x00,                       //¶ËµãÃèÊö·û
  53          };
  54          /*×Ö·û´®ÃèÊö·û*/
  55           unsigned char  code LangDes[]={0x04,0x03,0x09,0x04};           //ÓïÑÔÃèÊö·û
  56           unsigned char  code SerDes[]={                                 //ÐòÁÐºÅ×Ö·û´®ÃèÊö·û
  57                          0x14,0x03,
  58                  0x32,0x00,0x30,0x00,0x31,0x00,0x37,0x00,0x2D,0x00,
  59                  0x32,0x00,0x2D,0x00,
  60                  0x32,0x00,0x35,0x00
  61                          };     
  62           unsigned char  code Prod_Des[]={                                //²úÆ·×Ö·û´®ÃèÊö·û
  63                  0x14,0x03,
  64                  0x43,0x00,0x48,0x00,0x35,0x00,0x35,0x00,0x34,0x00,0x5F,0x00,
  65                  0x43,0x00,0x44,0x00,0x43,0x00,
  66           };
  67           unsigned char  code Manuf_Des[]={  
  68                  0x0A,0x03,
  69                  0x5F,0x6c,0xCF,0x82,0x81,0x6c,0x52,0x60,
  70           };
  71          
  72          //cdc²ÎÊý
  73          UINT8X LineCoding[7]={0x00,0xe1,0x00,0x00,0x00,0x00,0x08};   //³õÊ¼»¯²¨ÌØÂÊÎª57600£¬1Í£Ö¹Î»£¬ÎÞÐ£Ñé£¬8Êý¾Ý
             -Î»¡£
  74          
  75          #define UART_REV_LEN  64                 //´®¿Ú½ÓÊÕ»º³åÇø´óÐ¡
  76          UINT8I Receive_Uart_Buf[UART_REV_LEN];   //´®¿Ú½ÓÊÕ»º³åÇø
  77          volatile UINT8I Uart_Input_Point = 0;   //Ñ­»·»º³åÇøÐ´ÈëÖ¸Õë£¬×ÜÏß¸´Î»ÐèÒª³õÊ¼»¯Îª0
  78          volatile UINT8I Uart_Output_Point = 0;  //Ñ­»·»º³åÇøÈ¡³öÖ¸Õë£¬×ÜÏß¸´Î»ÐèÒª³õÊ¼»¯Îª0
  79          volatile UINT8I UartByteCount = 0;      //µ±Ç°»º³åÇøÊ£Óà´ýÈ¡×Ö½ÚÊý
  80          
  81          
  82          volatile UINT8I USBByteCount = 0;      //´ú±íUSB¶Ëµã½ÓÊÕµ½µÄÊý¾Ý
  83          volatile UINT8I USBBufOutPoint = 0;    //È¡Êý¾ÝÖ¸Õë
  84          
  85          volatile UINT8I UpPoint2_Busy  = 0;   //ÉÏ´«¶ËµãÊÇ·ñÃ¦±êÖ¾
  86          
  87          
  88          /*******************************************************************************
  89          * Function Name  : USBDeviceCfg()
  90          * Description    : USBÉè±¸Ä£Ê½ÅäÖÃ
  91          * Input          : None
  92          * Output         : None
  93          * Return         : None
  94          *******************************************************************************/
  95          void USBDeviceCfg()
  96          {
  97   1          USB_CTRL = 0x00;                                                           //Çå¿ÕUSB¿ØÖÆ¼Ä´æÆ÷
  98   1          USB_CTRL &= ~bUC_HOST_MODE;                                                //¸ÃÎ»ÎªÑ¡ÔñÉè±¸Ä£Ê½
  99   1          USB_CTRL |=  bUC_DEV_PU_EN | bUC_INT_BUSY | bUC_DMA_EN;                    //USBÉè±¸ºÍÄÚ²¿ÉÏÀ­Ê¹ÄÜ,ÔÚÖ
             -Ð¶ÏÆÚ¼äÖÐ¶Ï±êÖ¾Î´Çå³ýÇ°×Ô¶¯·µ»ØNAK
 100   1          USB_DEV_AD = 0x00;                                                         //Éè±¸µØÖ·³õÊ¼»¯
 101   1      //     USB_CTRL |= bUC_LOW_SPEED;
 102   1      //     UDEV_CTRL |= bUD_LOW_SPEED;                                                //Ñ¡ÔñµÍËÙ1.5MÄ£Ê½
 103   1          USB_CTRL &= ~bUC_LOW_SPEED;
 104   1          UDEV_CTRL &= ~bUD_LOW_SPEED;                                             //Ñ¡ÔñÈ«ËÙ12MÄ£Ê½£¬Ä¬ÈÏ·½Ê½
 105   1          UDEV_CTRL = bUD_PD_DIS;  // ½ûÖ¹DP/DMÏÂÀ­µç×è
 106   1          UDEV_CTRL |= bUD_PORT_EN;                                                  //Ê¹ÄÜÎïÀí¶Ë¿Ú
 107   1      }
 108          /*******************************************************************************
C51 COMPILER V9.60.0.0   CDC                                                               11/11/2019 01:03:46 PAGE 3   

 109          * Function Name  : USBDeviceIntCfg()
 110          * Description    : USBÉè±¸Ä£Ê½ÖÐ¶Ï³õÊ¼»¯
 111          * Input          : None
 112          * Output         : None
 113          * Return         : None
 114          *******************************************************************************/
 115          void USBDeviceIntCfg()
 116          {
 117   1          USB_INT_EN |= bUIE_SUSPEND;                                               //Ê¹ÄÜÉè±¸¹ÒÆðÖÐ¶Ï
 118   1          USB_INT_EN |= bUIE_TRANSFER;                                              //Ê¹ÄÜUSB´«ÊäÍê³ÉÖÐ¶Ï
 119   1          USB_INT_EN |= bUIE_BUS_RST;                                               //Ê¹ÄÜÉè±¸Ä£Ê½USB×ÜÏß¸´Î»ÖÐ¶
             -Ï
 120   1          USB_INT_FG |= 0x1F;                                                       //ÇåÖÐ¶Ï±êÖ¾
 121   1          IE_USB = 1;                                                               //Ê¹ÄÜUSBÖÐ¶Ï
 122   1          EA = 1;                                                                   //ÔÊÐíµ¥Æ¬»úÖÐ¶Ï
 123   1      }
 124          /*******************************************************************************
 125          * Function Name  : USBDeviceEndPointCfg()
 126          * Description    : USBÉè±¸Ä£Ê½¶ËµãÅäÖÃ£¬Ä£Äâ¼æÈÝHIDÉè±¸£¬³ýÁË¶Ëµã0µÄ¿ØÖÆ´«Êä£¬»¹°üÀ¨¶Ëµã2ÅúÁ¿ÉÏÏÂ´«
 127          * Input          : None
 128          * Output         : None
 129          * Return         : None
 130          *******************************************************************************/
 131          void USBDeviceEndPointCfg()
 132          {
 133   1        UEP1_DMA = Ep1Buffer;                                                      //¶Ëµã1 ·¢ËÍÊý¾Ý´«ÊäµØÖ·
 134   1          UEP2_DMA = Ep2Buffer;                                                      //¶Ëµã2 INÊý¾Ý´«ÊäµØÖ· 
 135   1          UEP2_3_MOD = 0xCC;                                                         //¶Ëµã2/3 µ¥»º³åÊÕ·¢Ê¹ÄÜ
 136   1          UEP2_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK | UEP_R_RES_ACK;                 //¶Ëµã2×Ô¶¯·­×ªÍ¬²½±êÖ¾Î»£¬
             -INÊÂÎñ·µ»ØNAK£¬OUT·µ»ØACK
 137   1      
 138   1          UEP1_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK;                                 //¶Ëµã1×Ô¶¯·­×ªÍ¬²½±êÖ¾Î»£¬
             -INÊÂÎñ·µ»ØNAK  
 139   1        UEP0_DMA = Ep0Buffer;                                                      //¶Ëµã0Êý¾Ý´«ÊäµØÖ·
 140   1          UEP4_1_MOD = 0X40;                                                         //¶Ëµã1ÉÏ´«»º³åÇø£»¶Ëµã0µ¥6
             -4×Ö½ÚÊÕ·¢»º³åÇø
 141   1          UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;                                 //ÊÖ¶¯·­×ª£¬OUTÊÂÎñ·µ»ØACK£
             -¬INÊÂÎñ·µ»ØNAK
 142   1      }
 143          /*******************************************************************************
 144          * Function Name  : Config_Uart1(UINT8 *cfg_uart)
 145          * Description    : ÅäÖÃ´®¿Ú1²ÎÊý
 146          * Input          : ´®¿ÚÅäÖÃ²ÎÊý ËÄÎ»²¨ÌØÂÊ¡¢Í£Ö¹Î»¡¢Ð£Ñé¡¢Êý¾ÝÎ»
 147          * Output         : None
 148          * Return         : None
 149          *******************************************************************************/
 150          void Config_Uart1(UINT8 *cfg_uart)
 151          {
 152   1        UINT32 uart1_buad = 0;
 153   1        *((UINT8 *)&uart1_buad) = cfg_uart[3];
 154   1        *((UINT8 *)&uart1_buad+1) = cfg_uart[2];
 155   1        *((UINT8 *)&uart1_buad+2) = cfg_uart[1];
 156   1        *((UINT8 *)&uart1_buad+3) = cfg_uart[0];
 157   1        IE_UART1 = 0;
 158   1        SBAUD1 = 0 - FREQ_SYS/16/uart1_buad;
 159   1        IE_UART1 = 1;
 160   1      }
 161          /*******************************************************************************
 162          * Function Name  : DeviceInterrupt()
 163          * Description    : CH559USBÖÐ¶Ï´¦Àíº¯Êý
 164          *******************************************************************************/
 165          void    DeviceInterrupt( void ) interrupt INT_NO_USB                       //USBÖÐ¶Ï·þÎñ³ÌÐò,Ê¹ÓÃ¼Ä´æÆ÷×é1
C51 COMPILER V9.60.0.0   CDC                                                               11/11/2019 01:03:46 PAGE 4   

 166          {
 167   1          UINT16 len;
 168   1          if(UIF_TRANSFER)                                                            //USB´«ÊäÍê³É±êÖ¾
 169   1          {
 170   2              switch (USB_INT_ST & (MASK_UIS_TOKEN | MASK_UIS_ENDP))
 171   2              {
 172   3          case UIS_TOKEN_IN | 1:                                                  //endpoint 1# ¶ËµãÖÐ¶ÏÉÏ´«
 173   3            UEP1_T_LEN = 0; 
 174   3            UEP1_CTRL = UEP1_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;           //Ä¬ÈÏÓ¦´ðNAK
 175   3            break;
 176   3              case UIS_TOKEN_IN | 2:                                                  //endpoint 2# ¶ËµãÅúÁ¿ÉÏ´«
 177   3            {   
 178   4              UEP2_T_LEN = 0;                                                    //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 179   4              UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;           //Ä¬ÈÏÓ¦´ðNAK
 180   4              UpPoint2_Busy = 0;                                                  //Çå³ýÃ¦±êÖ¾
 181   4            }
 182   3                  break;
 183   3              case UIS_TOKEN_OUT | 2:                                                 //endpoint 3# ¶ËµãÅúÁ¿ÏÂ´«
 184   3                  if ( U_TOG_OK )                                                     // ²»Í¬²½µÄÊý¾Ý°ü½«¶ªÆú
 185   3                  {
 186   4                      USBByteCount = USB_RX_LEN;
 187   4              USBBufOutPoint = 0;                                             //È¡Êý¾ÝÖ¸Õë¸´Î»
 188   4              UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_R_RES | UEP_R_RES_NAK;       //ÊÕµ½Ò»°üÊý¾Ý¾ÍNAK£¬Ö÷º¯Êý´¦ÀíÍê£¬ÓÉÖ
             -÷º¯ÊýÐÞ¸ÄÏìÓ¦·½Ê½
 189   4                  }
 190   3                  break;
 191   3              case UIS_TOKEN_SETUP | 0:                                                //SETUPÊÂÎñ
 192   3                  len = USB_RX_LEN;
 193   3                  if(len == (sizeof(USB_SETUP_REQ)))
 194   3                  {
 195   4                      SetupLen = ((UINT16)UsbSetupBuf->wLengthH<<8) | (UsbSetupBuf->wLengthL);
 196   4                      len = 0;                                                      // Ä¬ÈÏÎª³É¹¦²¢ÇÒÉÏ´«0³¤¶È
 197   4                      SetupReq = UsbSetupBuf->bRequest;             
 198   4                      if ( ( UsbSetupBuf->bRequestType & USB_REQ_TYP_MASK ) != USB_REQ_TYP_STANDARD )//·Ç±ê×¼ÇëÇ
             -ó
 199   4                      {
 200   5                switch( SetupReq ) 
 201   5                {
 202   6                  case GET_LINE_CODING:   //0x21  currently configured
 203   6                    pDescr = LineCoding;
 204   6                    len = sizeof(LineCoding);
 205   6                    len = SetupLen >= DEFAULT_ENDP0_SIZE ? DEFAULT_ENDP0_SIZE : SetupLen;  // ±¾´Î´«Êä³¤¶È
 206   6                    memcpy(Ep0Buffer,pDescr,len); 
 207   6                    SetupLen -= len;
 208   6                    pDescr += len;
 209   6                    break;            
 210   6                  case SET_CONTROL_LINE_STATE:  //0x22  generates RS-232/V.24 style control signals                   
 211   6                    break;
 212   6                  case SET_LINE_CODING:      //0x20  Configure
 213   6                    break;
 214   6                  default:
 215   6                       len = 0xFF;                                             /*ÃüÁî²»Ö§³Ö*/         
 216   6                       break;
 217   6                }   
 218   5                      }
 219   4                      else                                                             //±ê×¼ÇëÇó
 220   4                      {
 221   5                          switch(SetupReq)                                             //ÇëÇóÂë
 222   5                          {
 223   6                          case USB_GET_DESCRIPTOR:
 224   6                              switch(UsbSetupBuf->wValueH)
 225   6                              {
C51 COMPILER V9.60.0.0   CDC                                                               11/11/2019 01:03:46 PAGE 5   

 226   7                              case 1:                                                       //Éè±¸ÃèÊö·û
 227   7                                  pDescr = DevDesc;                                         //°ÑÉè±¸ÃèÊö·ûËÍµ½Òª
             -·¢ËÍµÄ»º³åÇø
 228   7                                  len = sizeof(DevDesc);
 229   7                                  break;
 230   7                              case 2:                                                        //ÅäÖÃÃèÊö·û
 231   7                                  pDescr = CfgDesc;                                          //°ÑÉè±¸ÃèÊö·ûËÍµ½Ò
             -ª·¢ËÍµÄ»º³åÇø
 232   7                                  len = sizeof(CfgDesc);
 233   7                                  break;
 234   7                  case 3:
 235   7                    if(UsbSetupBuf->wValueL == 0)
 236   7                    {
 237   8                      pDescr = LangDes;                                          
 238   8                      len = sizeof(LangDes);                
 239   8                    }
 240   7                    else if(UsbSetupBuf->wValueL == 1)
 241   7                    {
 242   8                      pDescr = Manuf_Des; 
 243   8                      len = sizeof(Manuf_Des);
 244   8                    }
 245   7                    else if(UsbSetupBuf->wValueL == 2)
 246   7                    {
 247   8                      pDescr = Prod_Des; 
 248   8                      len = sizeof(Prod_Des);
 249   8                    }
 250   7                    else
 251   7                    {
 252   8                      pDescr = SerDes; 
 253   8                      len = sizeof(SerDes);
 254   8                    }             
 255   7                    break;
 256   7                              default:
 257   7                                  len = 0xff;                                                //²»Ö§³ÖµÄÃüÁî»òÕß³
             -ö´í
 258   7                                  break;
 259   7                              }
 260   6                              if ( SetupLen > len )
 261   6                              {
 262   7                                  SetupLen = len;    //ÏÞÖÆ×Ü³¤¶È
 263   7                              }
 264   6                              len = SetupLen >= DEFAULT_ENDP0_SIZE ? DEFAULT_ENDP0_SIZE : SetupLen;             
             -               //±¾´Î´«Êä³¤¶È
 265   6                              memcpy(Ep0Buffer,pDescr,len);                                  //¼ÓÔØÉÏ´«Êý¾Ý
 266   6                              SetupLen -= len;
 267   6                              pDescr += len;
 268   6                              break;
 269   6                          case USB_SET_ADDRESS:
 270   6                              SetupLen = UsbSetupBuf->wValueL;                              //ÔÝ´æUSBÉè±¸µØÖ·
 271   6                              break;
 272   6                          case USB_GET_CONFIGURATION:
 273   6                              Ep0Buffer[0] = UsbConfig;
 274   6                              if ( SetupLen >= 1 )
 275   6                              {
 276   7                                  len = 1;
 277   7                              }
 278   6                              break;
 279   6                          case USB_SET_CONFIGURATION:
 280   6                              UsbConfig = UsbSetupBuf->wValueL;
 281   6                              break;
 282   6                          case USB_GET_INTERFACE:
 283   6                              break;
C51 COMPILER V9.60.0.0   CDC                                                               11/11/2019 01:03:46 PAGE 6   

 284   6                          case USB_CLEAR_FEATURE:                                            //Clear Feature
 285   6                              if( ( UsbSetupBuf->bRequestType & 0x1F ) == USB_REQ_RECIP_DEVICE )                
             -  /* Çå³ýÉè±¸ */
 286   6                              {
 287   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x01
             - )
 288   7                                  {
 289   8                                      if( CfgDesc[ 7 ] & 0x20 )
 290   8                                      {
 291   9                                          /* »½ÐÑ */
 292   9                                      }
 293   8                                      else
 294   8                                      {
 295   9                                          len = 0xFF;                                        /* ²Ù×÷Ê§°Ü */
 296   9                                      }
 297   8                                  }
 298   7                                  else
 299   7                                  {
 300   8                                      len = 0xFF;                                            /* ²Ù×÷Ê§°Ü */
 301   8                                  }
 302   7                              }
 303   6                              else if ( ( UsbSetupBuf->bRequestType & USB_REQ_RECIP_MASK ) == USB_REQ_RECIP_ENDP
             - )// ¶Ëµã
 304   6                              {
 305   7                                  switch( UsbSetupBuf->wIndexL )
 306   7                                  {
 307   8                                  case 0x83:
 308   8                                      UEP3_CTRL = UEP3_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 309   8                                      break;
 310   8                                  case 0x03:
 311   8                                      UEP3_CTRL = UEP3_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 312   8                                      break;
 313   8                                  case 0x82:
 314   8                                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 315   8                                      break;
 316   8                                  case 0x02:
 317   8                                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 318   8                                      break;
 319   8                                  case 0x81:
 320   8                                      UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 321   8                                      break;
 322   8                                  case 0x01:
 323   8                                      UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 324   8                                      break;              
 325   8                                  default:
 326   8                                      len = 0xFF;                                         // ²»Ö§³ÖµÄ¶Ëµã
 327   8                                      break;
 328   8                                  }
 329   7                              }
 330   6                              else
 331   6                              {
 332   7                                  len = 0xFF;                                                // ²»ÊÇ¶Ëµã²»Ö§³Ö
 333   7                              }
 334   6                              break;
 335   6                          case USB_SET_FEATURE:                                          /* Set Feature */
 336   6                              if( ( UsbSetupBuf->bRequestType & 0x1F ) == USB_REQ_RECIP_DEVICE )                
             -  /* ÉèÖÃÉè±¸ */
 337   6                              {
 338   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x01
             - )
 339   7                                  {
 340   8                                      if( CfgDesc[ 7 ] & 0x20 )
C51 COMPILER V9.60.0.0   CDC                                                               11/11/2019 01:03:46 PAGE 7   

 341   8                                      {
 342   9                                          /* ÐÝÃß */
 343   9                  #ifdef DE_PRINTF
 344   9                        printf( "suspend\n" );                                                             //Ë¯Ãß×´Ì¬
 345   9                  #endif
 346   9                        while ( XBUS_AUX & bUART0_TX )
 347   9                        {
 348  10                          ;    //µÈ´ý·¢ËÍÍê³É
 349  10                        }
 350   9                        SAFE_MOD = 0x55;
 351   9                        SAFE_MOD = 0xAA;
 352   9                        WAKE_CTRL = bWAK_BY_USB | bWAK_RXD0_LO | bWAK_RXD1_LO;                      //USB»òÕßRXD0/1ÓÐÐÅºÅ
             -Ê±¿É±»»½ÐÑ
 353   9                        PCON |= PD;                                                                 //Ë¯Ãß
 354   9                        SAFE_MOD = 0x55;
 355   9                        SAFE_MOD = 0xAA;
 356   9                        WAKE_CTRL = 0x00;
 357   9                                      }
 358   8                                      else
 359   8                                      {
 360   9                                          len = 0xFF;                                        /* ²Ù×÷Ê§°Ü */
 361   9                                      }
 362   8                                  }
 363   7                                  else
 364   7                                  {
 365   8                                      len = 0xFF;                                            /* ²Ù×÷Ê§°Ü */
 366   8                                  }
 367   7                              }
 368   6                              else if( ( UsbSetupBuf->bRequestType & 0x1F ) == USB_REQ_RECIP_ENDP )             
             -/* ÉèÖÃ¶Ëµã */
 369   6                              {
 370   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x00
             - )
 371   7                                  {
 372   8                                      switch( ( ( UINT16 )UsbSetupBuf->wIndexH << 8 ) | UsbSetupBuf->wIndexL )
 373   8                                      {
 374   9                                      case 0x83:
 375   9                                          UEP3_CTRL = UEP3_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã3 I
             -N STALL */
 376   9                                          break;
 377   9                                      case 0x03:
 378   9                                          UEP3_CTRL = UEP3_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* ÉèÖÃ¶Ëµã3 O
             -UT Stall */
 379   9                                          break;                  
 380   9                                      case 0x82:
 381   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã2 I
             -N STALL */
 382   9                                          break;
 383   9                                      case 0x02:
 384   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* ÉèÖÃ¶Ëµã2 O
             -UT Stall */
 385   9                                          break;
 386   9                                      case 0x81:
 387   9                                          UEP1_CTRL = UEP1_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã1 I
             -N STALL */
 388   9                                          break;
 389   9                      case 0x01:
 390   9                        UEP1_CTRL = UEP1_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* ÉèÖÃ¶Ëµã1 OUT Stall */
 391   9                                      default:
 392   9                                          len = 0xFF;                                    /* ²Ù×÷Ê§°Ü */
 393   9                                          break;
 394   9                                      }
C51 COMPILER V9.60.0.0   CDC                                                               11/11/2019 01:03:46 PAGE 8   

 395   8                                  }
 396   7                                  else
 397   7                                  {
 398   8                                      len = 0xFF;                                      /* ²Ù×÷Ê§°Ü */
 399   8                                  }
 400   7                              }
 401   6                              else
 402   6                              {
 403   7                                  len = 0xFF;                                          /* ²Ù×÷Ê§°Ü */
 404   7                              }
 405   6                              break;
 406   6                          case USB_GET_STATUS:
 407   6                              Ep0Buffer[0] = 0x00;
 408   6                              Ep0Buffer[1] = 0x00;
 409   6                              if ( SetupLen >= 2 )
 410   6                              {
 411   7                                  len = 2;
 412   7                              }
 413   6                              else
 414   6                              {
 415   7                                  len = SetupLen;
 416   7                              }
 417   6                              break;
 418   6                          default:
 419   6                              len = 0xff;                                                    //²Ù×÷Ê§°Ü
 420   6                              break;
 421   6                          }
 422   5                      }
 423   4                  }
 424   3                  else
 425   3                  {
 426   4                      len = 0xff;                                                         //°ü³¤¶È´íÎó
 427   4                  }
 428   3                  if(len == 0xff)
 429   3                  {
 430   4                      SetupReq = 0xFF;
 431   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;//STALL
 432   4                  }
 433   3                  else if(len <= DEFAULT_ENDP0_SIZE)                                                       //ÉÏ´
             -«Êý¾Ý»òÕß×´Ì¬½×¶Î·µ»Ø0³¤¶È°ü
 434   3                  {
 435   4                      UEP0_T_LEN = len;
 436   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA1£¬·
             -µ»ØÓ¦´ðACK
 437   4                  }
 438   3                  else
 439   3                  {
 440   4                      UEP0_T_LEN = 0;  //ËäÈ»ÉÐÎ´µ½×´Ì¬½×¶Î£¬µ«ÊÇÌáÇ°Ô¤ÖÃÉÏ´«0³¤¶ÈÊý¾Ý°üÒÔ·ÀÖ÷»úÌáÇ°½øÈë×´Ì¬½×¶Î
 441   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA1,·µ
             -»ØÓ¦´ðACK
 442   4                  }
 443   3                  break;
 444   3              case UIS_TOKEN_IN | 0:                                                      //endpoint0 IN
 445   3                  switch(SetupReq)
 446   3                  {
 447   4                  case USB_GET_DESCRIPTOR:
 448   4                      len = SetupLen >= DEFAULT_ENDP0_SIZE ? DEFAULT_ENDP0_SIZE : SetupLen;                     
             -            //±¾´Î´«Êä³¤¶È
 449   4                      memcpy( Ep0Buffer, pDescr, len );                                   //¼ÓÔØÉÏ´«Êý¾Ý
 450   4                      SetupLen -= len;
 451   4                      pDescr += len;
 452   4                      UEP0_T_LEN = len;
C51 COMPILER V9.60.0.0   CDC                                                               11/11/2019 01:03:46 PAGE 9   

 453   4                      UEP0_CTRL ^= bUEP_T_TOG;                                             //Í¬²½±êÖ¾Î»·­×ª
 454   4                      break;
 455   4                  case USB_SET_ADDRESS:
 456   4                      USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | SetupLen;
 457   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 458   4                      break;
 459   4                  default:
 460   4                      UEP0_T_LEN = 0;                                                      //×´Ì¬½×¶ÎÍê³ÉÖÐ¶Ï»òÕ
             -ßÊÇÇ¿ÖÆÉÏ´«0³¤¶ÈÊý¾Ý°ü½áÊø¿ØÖÆ´«Êä
 461   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 462   4                      break;
 463   4                  }
 464   3                  break;
 465   3              case UIS_TOKEN_OUT | 0:  // endpoint0 OUT
 466   3            if(SetupReq ==SET_LINE_CODING)  //ÉèÖÃ´®¿ÚÊôÐÔ
 467   3            {
 468   4              if( U_TOG_OK ) 
 469   4              {
 470   5                memcpy(LineCoding,UsbSetupBuf,USB_RX_LEN);
 471   5                Config_Uart1(LineCoding);
 472   5                UEP0_T_LEN = 0;
 473   5                UEP0_CTRL |= UEP_R_RES_ACK | UEP_T_RES_ACK;  // ×¼±¸ÉÏ´«0°ü       
 474   5              }
 475   4            }
 476   3            else
 477   3            {
 478   4              UEP0_T_LEN = 0;  
 479   4              UEP0_CTRL |= UEP_R_RES_ACK | UEP_T_RES_NAK;  //×´Ì¬½×¶Î£¬¶ÔINÏìÓ¦NAK
 480   4            }
 481   3                  break;
 482   3      
 483   3                
 484   3                
 485   3              default:
 486   3                  break;
 487   3              }
 488   2              UIF_TRANSFER = 0;                                                           //Ð´0Çå¿ÕÖÐ¶Ï
 489   2          }
 490   1          if(UIF_BUS_RST)                                                                 //Éè±¸Ä£Ê½USB×ÜÏß¸´Î»Ö
             -Ð¶Ï
 491   1          {
 492   2      #ifdef DE_PRINTF
 493   2                  printf( "reset\n" );                                                             //Ë¯Ãß×´Ì¬
 494   2      #endif    
 495   2              UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 496   2              UEP1_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK;
 497   2              UEP2_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK | UEP_R_RES_ACK;
 498   2              USB_DEV_AD = 0x00;
 499   2              UIF_SUSPEND = 0;
 500   2              UIF_TRANSFER = 0;
 501   2              UIF_BUS_RST = 0;                                                             //ÇåÖÐ¶Ï±êÖ¾
 502   2          Uart_Input_Point = 0;   //Ñ­»·»º³åÇøÊäÈëÖ¸Õë
 503   2          Uart_Output_Point = 0;  //Ñ­»·»º³åÇø¶Á³öÖ¸Õë
 504   2          UartByteCount = 0;      //µ±Ç°»º³åÇøÊ£Óà´ýÈ¡×Ö½ÚÊý
 505   2          USBByteCount = 0;       //USB¶ËµãÊÕµ½µÄ³¤¶È
 506   2          UsbConfig = 0;          //Çå³ýÅäÖÃÖµ
 507   2          UpPoint2_Busy = 0;
 508   2          }
 509   1          if (UIF_SUSPEND)                                                                 //USB×ÜÏß¹ÒÆð/»½ÐÑÍê³
             -É
 510   1          {
 511   2              UIF_SUSPEND = 0;
C51 COMPILER V9.60.0.0   CDC                                                               11/11/2019 01:03:46 PAGE 10  

 512   2              if ( USB_MIS_ST & bUMS_SUSPEND )                                             //¹ÒÆð
 513   2              {
 514   3      #ifdef DE_PRINTF
 515   3                  printf( "suspend\n" );                                                             //Ë¯Ãß×´Ì¬
 516   3      #endif
 517   3                  while ( XBUS_AUX & bUART0_TX )
 518   3                  {
 519   4                      ;    //µÈ´ý·¢ËÍÍê³É
 520   4                  }
 521   3                  SAFE_MOD = 0x55;
 522   3                  SAFE_MOD = 0xAA;
 523   3                  WAKE_CTRL = bWAK_BY_USB | bWAK_RXD0_LO | bWAK_RXD1_LO;                      //USB»òÕßRXD0/1ÓÐÐ
             -ÅºÅÊ±¿É±»»½ÐÑ
 524   3                  PCON |= PD;                                                                 //Ë¯Ãß
 525   3                  SAFE_MOD = 0x55;
 526   3                  SAFE_MOD = 0xAA;
 527   3                  WAKE_CTRL = 0x00;
 528   3              }
 529   2          }
 530   1          else {                                                                             //ÒâÍâµÄÖÐ¶Ï,²»¿ÉÄÜ
             -·¢ÉúµÄÇé¿ö
 531   2              USB_INT_FG = 0xFF;                                                             //ÇåÖÐ¶Ï±êÖ¾
 532   2      
 533   2          }
 534   1      }
 535          /*******************************************************************************
 536          * Function Name  : Uart1_ISR()
 537          * Description    : ´®¿Ú½ÓÊÕÖÐ¶Ïº¯Êý£¬ÊµÏÖÑ­»·»º³å½ÓÊÕ
 538          *******************************************************************************/
 539          void Uart1_ISR(void) interrupt INT_NO_UART1
 540          {
 541   1        if(U1RI)   //ÊÕµ½Êý¾Ý
 542   1        {
 543   2          Receive_Uart_Buf[Uart_Input_Point++] = SBUF1;
 544   2          UartByteCount++;                    //µ±Ç°»º³åÇøÊ£Óà´ýÈ¡×Ö½ÚÊý
 545   2          if(Uart_Input_Point>=UART_REV_LEN)
 546   2            Uart_Input_Point = 0;           //Ð´ÈëÖ¸Õë
 547   2          U1RI =0;    
 548   2        }
 549   1        
 550   1      }
 551          
 552          sbit LED0 = P1^4;
 553          // UART1 57600
 554          
 555          //Ö÷º¯Êý
 556          main()
 557          {
 558   1      
 559   1        UINT8 lenth;
 560   1        UINT8 Uart_Timeout = 0;
 561   1        CfgFsys( );                                                           //CH559Ê±ÖÓÑ¡ÔñÅäÖÃ
 562   1        mDelaymS(5);                                                          //ÐÞ¸ÄÖ÷ÆµµÈ´ýÄÚ²¿¾§ÕñÎÈ¶¨,±Ø¼Ó 
 563   1        mInitSTDIO( );                                                        //´®¿Ú0,¿ÉÒÔÓÃÓÚµ÷ÊÔ
 564   1        UART1Setup( );      //ÓÃÓÚCDC
 565   1        
 566   1        Port1Cfg(1,4);
 567   1        LED0 = 0;
 568   1        
 569   1      #ifdef DE_PRINTF
 570   1          printf("start ...\n");
 571   1      #endif  
C51 COMPILER V9.60.0.0   CDC                                                               11/11/2019 01:03:46 PAGE 11  

 572   1          USBDeviceCfg();                                                    
 573   1          USBDeviceEndPointCfg();                                               //¶ËµãÅäÖÃ
 574   1          USBDeviceIntCfg();                                                    //ÖÐ¶Ï³õÊ¼»¯
 575   1        UEP0_T_LEN = 0;
 576   1          UEP1_T_LEN = 0;                                                       //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 577   1          UEP2_T_LEN = 0;                                                       //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 578   1        
 579   1          while(1)
 580   1          {
 581   2          if(UsbConfig)
 582   2          {
 583   3            // USB -> UART1
 584   3            if(USBByteCount)   //USB½ÓÊÕ¶ËµãÓÐÊý¾Ý
 585   3            {
 586   4                if ( Ep2Buffer[0] = 'A') {
*** WARNING C276 IN LINE 586 OF CDC.C: constant in condition expression
 587   5                  printf("Received 'A'\n");
 588   5                  LED0 = ~LED0;
 589   5                }
 590   4              
 591   4              CH554UART1SendByte(Ep2Buffer[USBBufOutPoint++]);
 592   4              USBByteCount--;
 593   4              
 594   4              if(USBByteCount==0) 
 595   4                UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_R_RES | UEP_R_RES_ACK;
 596   4            }
 597   3            if(UartByteCount)
 598   3              Uart_Timeout++;
 599   3            
 600   3            // UART1 Receive_Uart_Buf -> USB Ep2Buffer
 601   3            if(!UpPoint2_Busy)   //¶Ëµã²»·±Ã¦£¨¿ÕÏÐºóµÄµÚÒ»°üÊý¾Ý£¬Ö»ÓÃ×÷´¥·¢ÉÏ´«£©
 602   3            {
 603   4              lenth = UartByteCount;
 604   4              if(lenth>0)
 605   4              {
 606   5                if(lenth>39 || Uart_Timeout>100)
 607   5                {   
 608   6                  Uart_Timeout = 0;
 609   6                  if(Uart_Output_Point+lenth>UART_REV_LEN)
 610   6                    lenth = UART_REV_LEN-Uart_Output_Point;
 611   6                  UartByteCount -= lenth;     
 612   6                  //Ð´ÉÏ´«¶Ëµã
 613   6                  memcpy(Ep2Buffer+MAX_PACKET_SIZE,&Receive_Uart_Buf[Uart_Output_Point],lenth);
 614   6                  Uart_Output_Point+=lenth;
 615   6                  if(Uart_Output_Point>=UART_REV_LEN)
 616   6                    Uart_Output_Point = 0;            
 617   6                  UEP2_T_LEN = lenth;                                                    //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 618   6                  UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK;            //Ó¦´ðACK
 619   6                  UpPoint2_Busy = 1;
 620   6                }
 621   5              }
 622   4            }
 623   3          }   
 624   2          }
 625   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1968    ----
   CONSTANT SIZE    =    180    ----
   XDATA SIZE       =     23       8
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   CDC                                                               11/11/2019 01:03:46 PAGE 12  

   DATA SIZE        =   ----    ----
   IDATA SIZE       =     70    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
