C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE USBCORE
OBJECT MODULE PLACED IN UsbCore.OBJ
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE UsbCore.c BROWSE DEBUG OBJECTEXTEND TABS(1)

stmt level    source

   1          /******************************************************************
   2             本程序只供学习使用，未经作者许可，不得用于其它任何用途
   3             
   4                  欢迎访问我的USB专区：http://group.ednchina.com/93/
   5                  欢迎访问我的blog：   http://www.ednchina.com/blog/computer00
   6                                       http://computer00.21ic.org
   7          
   8                  感谢PCB赞助商――电子园： http://bbs.cepark.com/
   9          
  10          UsbCore.c file
  11          
  12          作者：电脑圈圈
  13          建立日期: 2008.06.29
  14          修改日期: 2008.07.14
  15          版本：V1.1
  16          版权所有，盗版必究。
  17          Copyright(C) 电脑圈圈 2008-2018
  18          All rights reserved            
  19          *******************************************************************/
  20          
  21          #include "config.h"
  22          #include "pdiusbd12.h"
  23          #include "uart.h"
  24          #include "usbcore.h"
  25          #include "led.h"
  26          
  27          idata uint8 Buffer[16];  //读端点0用的缓冲区
  28          
  29          //USB设备请求的各字段
  30          uint8  bmRequestType;
  31          uint8  bRequest;
  32          uint16 wValue;
  33          uint16 wIndex;
  34          uint16 wLength;
  35          //当前发送数据的位置
  36          uint8 * pSendData;
  37          //需要发送数据的长度
  38          uint16 SendLength;
  39          //是否需要发送0数据包的标志。在USB控制传输的数据过程中，
  40          //当返回的数据包字节数少于最大包长时，会认为数据过程结束。
  41          //当请求的字节数比实际需要返回的字节数长，而实际返回的字节
  42          //数又刚好是端点0大小的整数倍时，就需要返回一个0长度的数据包
  43          //来结束数据过程。因此这里增加一个标志，供程序决定是否需要返回
  44          //一个0长度的数据包。
  45          uint8 NeedZeroPacket;
  46          
  47          //当前的配置值。只有在设置非0配置后
  48          uint8 ConfigValue;
  49          
  50          //端点1缓冲是否忙的标志。当缓冲区中有数据时，该标志为真。
  51          //当缓冲区中空闲时，该标志为假。
  52          uint8 Ep1InIsBusy;
  53          
  54          //USB设备描述符的定义
  55          code uint8 DeviceDescriptor[0x12]=  //设备描述符为18字节
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 2   

  56          {
  57          //bLength字段。设备描述符的长度为18(0x12)字节
  58           0x12,
  59           
  60          //bDescriptorType字段。设备描述符的编号为0x01
  61           0x01,
  62           
  63          //bcdUSB字段。这里设置版本为USB1.1，即0x0110。
  64          //由于是小端结构，所以低字节在先，即0x10，0x01。
  65           0x10,
  66           0x01,
  67           
  68          //bDeviceClass字段。我们不在设备描述符中定义设备类，
  69          //而在接口描述符中定义设备类，所以该字段的值为0。
  70           0x00,
  71           
  72          //bDeviceSubClass字段。bDeviceClass字段为0时，该字段也为0。
  73           0x00,
  74           
  75          //bDeviceProtocol字段。bDeviceClass字段为0时，该字段也为0。
  76           0x00,
  77           
  78          //bMaxPacketSize0字段。PDIUSBD12的端点0大小的16字节。
  79           0x10,
  80           
  81          //idVender字段。厂商ID号，我们这里取0x8888，仅供实验用。
  82          //实际产品不能随便使用厂商ID号，必须跟USB协会申请厂商ID号。
  83          //注意小端模式，低字节在先。
  84           0x88,
  85           0x88,
  86           
  87          //idProduct字段。产品ID号，由于是第二个实验，我们这里取0x0002。
  88          //注意小端模式，低字节应该在前。
  89           0x02,
  90           0x00,
  91           
  92          //bcdDevice字段。我们这个USB键盘刚开始做，就叫它1.0版吧，即0x0100。
  93          //小端模式，低字节在先。
  94           0x00,
  95           0x01,
  96           
  97          //iManufacturer字段。厂商字符串的索引值，为了方便记忆和管理，
  98          //字符串索引就从1开始吧。
  99           0x01,
 100          
 101          //iProduct字段。产品字符串的索引值。刚刚用了1，这里就取2吧。
 102          //注意字符串索引值不要使用相同的值。
 103           0x02,
 104           
 105          //iSerialNumber字段。设备的序列号字符串索引值。
 106          //这里取3就可以了。
 107           0x03,
 108          
 109          //bNumConfigurations字段。该设备所具有的配置数。
 110          //我们只需要一种配置就行了，因此该值设置为1。
 111           0x01
 112          };
 113          //////////////////////////设备描述符完毕//////////////////////////////
 114          
 115          //USB报告描述符的定义
 116          code uint8 ReportDescriptor[]=
 117          {
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 3   

 118           //每行开始的第一字节为该条目的前缀，前缀的格式为：
 119           //D7~D4：bTag。D3~D2：bType；D1~D0：bSize。以下分别对每个条目注释。
 120           
 121           //这是一个全局（bType为1）条目，将用途页选择为普通桌面Generic Desktop Page(0x01)
 122           //后面跟一字节数据（bSize为1），后面的字节数就不注释了，
 123           //自己根据bSize来判断。
 124           0x05, 0x01, // USAGE_PAGE (Generic Desktop)
 125           
 126           //这是一个局部（bType为2）条目，说明接下来的集合用途用于键盘
 127           0x09, 0x06, // USAGE (Keyboard)
 128           
 129           //这是一个主条目（bType为0）条目，开集合，后面跟的数据0x01表示
 130           //该集合是一个应用集合。它的性质在前面由用途页和用途定义为
 131           //普通桌面用的键盘。
 132           0xa1, 0x01, // COLLECTION (Application)
 133           
 134           //这是一个全局条目，选择用途页为键盘（Keyboard/Keypad(0x07)）
 135           0x05, 0x07, //     USAGE_PAGE (Keyboard/Keypad)
 136          
 137           //这是一个局部条目，说明用途的最小值为0xe0。实际上是键盘左Ctrl键。
 138           //具体的用途值可在HID用途表中查看。
 139           0x19, 0xe0, //     USAGE_MINIMUM (Keyboard LeftControl)
 140           
 141           //这是一个局部条目，说明用途的最大值为0xe7。实际上是键盘右GUI键。
 142           0x29, 0xe7, //     USAGE_MAXIMUM (Keyboard Right GUI)
 143           
 144           //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值）
 145           //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。
 146           0x15, 0x00, //     LOGICAL_MINIMUM (0)
 147           
 148           //这是一个全局条目，说明逻辑值最大为1。
 149           0x25, 0x01, //     LOGICAL_MAXIMUM (1)
 150           
 151           //这是一个全局条目，说明数据域的数量为八个。
 152           0x95, 0x08, //     REPORT_COUNT (8)
 153           
 154           //这是一个全局条目，说明每个数据域的长度为1个bit。
 155           0x75, 0x01, //     REPORT_SIZE (1)
 156           
 157           //这是一个主条目，说明有8个长度为1bit的数据域（数量和长度
 158           //由前面的两个全局条目所定义）用来做为输入，
 159           //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示
 160           //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。
 161           //这样定义的结果就是，当某个域的值为1时，就表示对应的键按下。
 162           //bit0就对应着用途最小值0xe0，bit7对应着用途最大值0xe7。
 163           0x81, 0x02, //     INPUT (Data,Var,Abs)
 164           
 165           //这是一个全局条目，说明数据域数量为1个
 166           0x95, 0x01, //     REPORT_COUNT (1)
 167           
 168           //这是一个全局条目，说明每个数据域的长度为8bit。
 169           0x75, 0x08, //     REPORT_SIZE (8)
 170           
 171           //这是一个主条目，输入用，由前面两个全局条目可知，长度为8bit，
 172           //数量为1个。它的属性为常量（即返回的数据一直是0）。
 173           //该字节是保留字节（保留给OEM使用）。
 174           0x81, 0x03, //     INPUT (Cnst,Var,Abs)
 175           
 176           //这是一个全局条目。定义位域数量为6个。
 177           0x95, 0x06, //   REPORT_COUNT (6)
 178           
 179           //这是一个全局条目。定义每个位域长度为8bit。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 4   

 180           //其实这里这个条目不要也是可以的，因为在前面已经有一个定义
 181           //长度为8bit的全局条目了。
 182           0x75, 0x08, //   REPORT_SIZE (8)
 183           
 184           //这是一个全局条目，定义逻辑最小值为0。
 185           //同上，这里这个全局条目也是可以不要的，因为前面已经有一个
 186           //定义逻辑最小值为0的全局条目了。
 187           0x15, 0x00, //   LOGICAL_MINIMUM (0)
 188           
 189           //这是一个全局条目，定义逻辑最大值为255。
 190           0x25, 0xFF, //   LOGICAL_MAXIMUM (255)
 191           
 192           //这是一个全局条目，选择用途页为键盘。
 193           //前面已经选择过用途页为键盘了，所以该条目不要也可以。
 194           0x05, 0x07, //   USAGE_PAGE (Keyboard/Keypad)
 195           
 196           //这是一个局部条目，定义用途最小值为0（0表示没有键按下）
 197           0x19, 0x00, //   USAGE_MINIMUM (Reserved (no event indicated))
 198           
 199           //这是一个局部条目，定义用途最大值为0x65
 200           0x29, 0x65, //   USAGE_MAXIMUM (Keyboard Application)
 201           
 202           //这是一个主条目。它说明这六个8bit的数据域是输入用的，
 203           //属性为：Data,Ary,Abs。Data说明数据是可以变的，Ary说明
 204           //这些数据域是一个数组，即每个8bit都可以表示某个键值，
 205           //如果按下的键太多（例如超过这里定义的长度或者键盘本身无法
 206           //扫描出按键情况时），则这些数据返回全1（二进制），表示按键无效。
 207           //Abs表示这些值是绝对值。
 208           0x81, 0x00, //     INPUT (Data,Ary,Abs)
 209          
 210           //以下为输出报告的描述
 211           //逻辑最小值前面已经有定义为0了，这里可以省略。 
 212           //这是一个全局条目，说明逻辑值最大为1。
 213           0x25, 0x01, //     LOGICAL_MAXIMUM (1)
 214           
 215           //这是一个全局条目，说明数据域数量为5个。 
 216           0x95, 0x05, //   REPORT_COUNT (5)
 217           
 218           //这是一个全局条目，说明数据域的长度为1bit。
 219           0x75, 0x01, //   REPORT_SIZE (1)
 220           
 221           //这是一个全局条目，说明使用的用途页为指示灯（LED）
 222           0x05, 0x08, //   USAGE_PAGE (LEDs)
 223           
 224           //这是一个局部条目，说明用途最小值为数字键盘灯。
 225           0x19, 0x01, //   USAGE_MINIMUM (Num Lock)
 226           
 227           //这是一个局部条目，说明用途最大值为Kana灯。
 228           0x29, 0x05, //   USAGE_MAXIMUM (Kana)
 229           
 230           //这是一个主条目。定义输出数据，即前面定义的5个LED。
 231           0x91, 0x02, //   OUTPUT (Data,Var,Abs)
 232           
 233           //这是一个全局条目。定义位域数量为1个。
 234           0x95, 0x01, //   REPORT_COUNT (1)
 235           
 236           //这是一个全局条目。定义位域长度为3bit。
 237           0x75, 0x03, //   REPORT_SIZE (3)
 238           
 239           //这是一个主条目，定义输出常量，前面用了5bit，所以这里需要
 240           //3个bit来凑成一字节。
 241           0x91, 0x03, //   OUTPUT (Cnst,Var,Abs)
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 5   

 242           
 243           //下面这个主条目用来关闭前面的集合。bSize为0，所以后面没数据。
 244           0xc0        // END_COLLECTION
 245          };
 246          //通过上面的报告描述符的定义，我们知道返回的输入报告具有8字节。
 247          //第一字节的8个bit用来表示特殊键是否按下（例如Shift、Alt等键）。
 248          //第二字节为保留值，值为常量0。第三到第八字节是一个普通键键值的
 249          //数组，当没有键按下时，全部6个字节值都为0。当只有一个普通键按下时，
 250          //这六个字节中的第一字节值即为该按键的键值（具体的键值请看HID的
 251          //用途表文档），当有多个普通键同时按下时，则同时返回这些键的键值。
 252          //如果按下的键太多，则这六个字节都为0xFF（不能返回0x00，这样会让
 253          //操作系统认为所有键都已经释放）。至于键值在数组中的先后顺序是
 254          //无所谓的，操作系统会负责检查是否有新键按下。我们应该在中断端点1
 255          //中按照上面的格式返回实际的键盘数据。另外，报告中还定义了一个字节
 256          //的输出报告，是用来控制LED情况的。只使用了低7位，高1位是保留值0。
 257          //当某位的值为1时，则表示对应的LED要点亮。操作系统会负责同步各个
 258          //键盘之间的LED，例如你有两块键盘，一块的数字键盘灯亮时，另一块
 259          //也会跟着亮。键盘本身不需要判断各种LED应该何时亮，它只是等待主机
 260          //发送报告给它，然后根据报告值来点亮相应的LED。我们在端点1输出中断
 261          //中读出这1字节的输出报告，然后对它取反（因为学习板上的LED是低电平时
 262          //亮），直接发送到LED上。这样main函数中按键点亮LED的代码就不需要了。
 263          ///////////////////////////报告描述符完毕////////////////////////////
 264          
 265          //USB配置描述符集合的定义
 266          //配置描述符总长度为9+9+9+7+7字节
 267          code uint8 ConfigurationDescriptor[9+9+9+7+7]=
 268          {
 269           /***************配置描述符***********************/
 270           //bLength字段。配置描述符的长度为9字节。
 271           0x09,
 272           
 273           //bDescriptorType字段。配置描述符编号为0x02。
 274           0x02,
 275           
 276           //wTotalLength字段。配置描述符集合的总长度，
 277           //包括配置描述符本身、接口描述符、类描述符、端点描述符等。
 278           sizeof(ConfigurationDescriptor)&0xFF, //低字节
 279           (sizeof(ConfigurationDescriptor)>>8)&0xFF, //高字节
 280           
 281           //bNumInterfaces字段。该配置包含的接口数，只有一个接口。
 282           0x01,
 283           
 284           //bConfiguration字段。该配置的值为1。
 285           0x01,
 286           
 287           //iConfigurationz字段，该配置的字符串索引。这里没有，为0。
 288           0x00,
 289           
 290           //bmAttributes字段，该设备的属性。由于我们的板子是总线供电的，
 291           //并且我们不想实现远程唤醒的功能，所以该字段的值为0x80。
 292           0x80,
 293           
 294           //bMaxPower字段，该设备需要的最大电流量。由于我们的板子
 295           //需要的电流不到100mA，因此我们这里设置为100mA。由于每单位
 296           //电流为2mA，所以这里设置为50(0x32)。
 297           0x32,
 298           
 299           /*******************接口描述符*********************/
 300           //bLength字段。接口描述符的长度为9字节。
 301           0x09,
 302           
 303           //bDescriptorType字段。接口描述符的编号为0x04。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 6   

 304           0x04,
 305           
 306           //bInterfaceNumber字段。该接口的编号，第一个接口，编号为0。
 307           0x00,
 308           
 309           //bAlternateSetting字段。该接口的备用编号，为0。
 310           0x00,
 311           
 312           //bNumEndpoints字段。非0端点的数目。该USB键盘需要二个
 313           //中断端点（一个输入一个输出），因此该值为2。
 314           0x02,
 315           
 316           //bInterfaceClass字段。该接口所使用的类。USB键盘是HID类，
 317           //HID类的编码为0x03。
 318           0x03,
 319           
 320           //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中，
 321           //只规定了一种子类：支持BIOS引导启动的子类。
 322           //USB键盘、鼠标属于该子类，子类代码为0x01。
 323           0x01,
 324           
 325           //bInterfaceProtocol字段。如果子类为支持引导启动的子类，
 326           //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。
 327           0x01,
 328           
 329           //iConfiguration字段。该接口的字符串索引值。这里没有，为0。
 330           0x00,
 331           
 332           /******************HID描述符************************/
 333           //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。
 334           0x09,
 335           
 336           //bDescriptorType字段。HID描述符的编号为0x21。
 337           0x21,
 338           
 339           //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。
 340           0x10,
 341           0x01,
 342           
 343           //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。
 344           0x21,
 345           
 346           //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。
 347           0x01,
 348           
 349           //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。
 350           0x22,
 351           
 352           //bDescriptorLength字段。下级描述符的长度。下级描述符为报告描述符。
 353           sizeof(ReportDescriptor)&0xFF,
 354           (sizeof(ReportDescriptor)>>8)&0xFF,
 355           
 356           /**********************输入端点描述符***********************/
 357           //bLength字段。端点描述符长度为7字节。
 358           0x07,
 359           
 360           //bDescriptorType字段。端点描述符编号为0x05。
 361           0x05,
 362           
 363           //bEndpointAddress字段。端点的地址。我们使用D12的输入端点1。
 364           //D7位表示数据方向，输入端点D7为1。所以输入端点1的地址为0x81。
 365           0x81,
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 7   

 366           
 367           //bmAttributes字段。D1~D0为端点传输类型选择。
 368           //该端点为中断端点。中断端点的编号为3。其它位保留为0。
 369           0x03,
 370           
 371           //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。
 372           //注意低字节在先。
 373           0x10,
 374           0x00,
 375           
 376           //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。
 377           0x0A,
 378           
 379           /**********************输出端点描述符***********************/
 380           //bLength字段。端点描述符长度为7字节。
 381           0x07,
 382           
 383           //bDescriptorType字段。端点描述符编号为0x05。
 384           0x05,
 385           
 386           //bEndpointAddress字段。端点的地址。我们使用D12的输出端点1。
 387           //D7位表示数据方向，输出端点D7为0。所以输出端点1的地址为0x01。
 388           0x01,
 389           
 390           //bmAttributes字段。D1~D0为端点传输类型选择。
 391           //该端点为中断端点。中断端点的编号为3。其它位保留为0。
 392           0x03,
 393           
 394           //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。
 395           //注意低字节在先。
 396           0x10,
 397           0x00,
 398           
 399           //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。
 400           0x0A
 401          };
 402          ////////////////////////配置描述符集合完毕//////////////////////////
 403          
 404          /************************语言ID的定义********************/
 405          code uint8 LanguageId[4]=
 406          {
 407           0x04, //本描述符的长度
 408           0x03, //字符串描述符
 409           //0x0409为美式英语的ID
 410           0x09,
 411           0x04
 412          };
 413          ////////////////////////语言ID完毕//////////////////////////////////
 414          
 415          /**************************************************/
 416          /*********        本转换结果来自         **********/
 417          /********* Http://computer00.21ic.org    **********/
 418          /*********        作者: 电脑圈圈         **********/
 419          /*********         欢迎大家使用          **********/
 420          /*********    版权所有，盗版请写明出处   **********/
 421          /**************************************************/
 422          
 423          //http://computer00.21ic.org/user1/2198/archives/2007/42769.html
 424          //字符串“电脑圈圈的USB专区 Http://group.ednchina.com/93/”的Unicode编码
 425          //8位小端格式
 426          code uint8 ManufacturerStringDescriptor[82]={
 427          82,         //该描述符的长度为82字节
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 8   

 428          0x03,       //字符串描述符的类型编码为0x03
 429          0x35, 0x75, //电
 430          0x11, 0x81, //脑
 431          0x08, 0x57, //圈
 432          0x08, 0x57, //圈
 433          0x84, 0x76, //的
 434          0x55, 0x00, //U
 435          0x53, 0x00, //S
 436          0x42, 0x00, //B
 437          0x13, 0x4e, //专
 438          0x3a, 0x53, //区
 439          0x20, 0x00, // 
 440          0x48, 0x00, //H
 441          0x74, 0x00, //t
 442          0x74, 0x00, //t
 443          0x70, 0x00, //p
 444          0x3a, 0x00, //:
 445          0x2f, 0x00, ///
 446          0x2f, 0x00, ///
 447          0x67, 0x00, //g
 448          0x72, 0x00, //r
 449          0x6f, 0x00, //o
 450          0x75, 0x00, //u
 451          0x70, 0x00, //p
 452          0x2e, 0x00, //.
 453          0x65, 0x00, //e
 454          0x64, 0x00, //d
 455          0x6e, 0x00, //n
 456          0x63, 0x00, //c
 457          0x68, 0x00, //h
 458          0x69, 0x00, //i
 459          0x6e, 0x00, //n
 460          0x61, 0x00, //a
 461          0x2e, 0x00, //.
 462          0x63, 0x00, //c
 463          0x6f, 0x00, //o
 464          0x6d, 0x00, //m
 465          0x2f, 0x00, ///
 466          0x39, 0x00, //9
 467          0x33, 0x00, //3
 468          0x2f, 0x00  ///
 469          };
 470          /////////////////////////厂商字符串结束/////////////////////////////
 471          
 472          //字符串“《圈圈教你玩USB》之USB键盘”的Unicode编码
 473          //8位小端格式
 474          code uint8 ProductStringDescriptor[34]={
 475          34,         //该描述符的长度为34字节
 476          0x03,       //字符串描述符的类型编码为0x03
 477          0x0a, 0x30, //《
 478          0x08, 0x57, //圈
 479          0x08, 0x57, //圈
 480          0x59, 0x65, //教
 481          0x60, 0x4f, //你
 482          0xa9, 0x73, //玩
 483          0x55, 0x00, //U
 484          0x53, 0x00, //S
 485          0x42, 0x00, //B
 486          0x0b, 0x30, //》
 487          0x4b, 0x4e, //之
 488          0x55, 0x00, //U
 489          0x53, 0x00, //S
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 9   

 490          0x42, 0x00, //B
 491          0x2e, 0x95, //键
 492          0xd8, 0x76  //盘
 493          };
 494          ////////////////////////产品字符串结束////////////////////////////
 495          
 496          //字符串“2008-07-12”的Unicode编码
 497          //8位小端格式
 498          code uint8 SerialNumberStringDescriptor[22]={
 499          22,         //该描述符的长度为22字节
 500          0x03,       //字符串描述符的类型编码为0x03
 501          0x32, 0x00, //2
 502          0x30, 0x00, //0
 503          0x30, 0x00, //0
 504          0x38, 0x00, //8
 505          0x2d, 0x00, //-
 506          0x30, 0x00, //0
 507          0x37, 0x00, //7
 508          0x2d, 0x00, //-
 509          0x31, 0x00, //1
 510          0x32, 0x00  //2
 511          };
 512          //////////////////////产品序列号字符串结束/////////////////////////
 513          
 514          /********************************************************************
 515          函数功能：延时x毫秒函数。
 516          入口参数：x：延时的毫秒数。
 517          返    回：无。
 518          备    注：无。
 519          ********************************************************************/
 520          void DelayXms(uint16 x)                
 521          {
 522   1       uint16 i;
 523   1       uint16 j;
 524   1       for(i=0;i<x;i++)
 525   1       for(j=0;j<227;j++); //循环语句延时
 526   1      }
 527          ////////////////////////End of function//////////////////////////////
 528          
 529          /********************************************************************
 530          函数功能：USB断开连接函数。
 531          入口参数：无。
 532          返    回：无。
 533          备    注：无。
 534          ********************************************************************/
 535          void UsbDisconnect(void)
 536          {
 537   1      #ifdef DEBUG0
 538   1       Prints("断开USB连接。\r\n");
 539   1      #endif
 540   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 541   1       D12WriteByte(0x06); //设置模式的第一字节
 542   1       D12WriteByte(0x47); //设置模式的第二字节
 543   1       DelayXms(1000);  //延迟1秒
 544   1      }
 545          ////////////////////////End of function//////////////////////////////
 546          
 547          /********************************************************************
 548          函数功能：USB连接函数。
 549          入口参数：无。
 550          返    回：无。
 551          备    注：无。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 10  

 552          ********************************************************************/
 553          void UsbConnect(void)
 554          {
 555   1      #ifdef DEBUG0
 556   1       Prints("连接USB。\r\n");
 557   1      #endif
 558   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 559   1       D12WriteByte(0x16); //设置模式的第一字节
 560   1       D12WriteByte(0x47); //设置模式的第二字节
 561   1      }
 562          ////////////////////////End of function//////////////////////////////
 563          
 564          /********************************************************************
 565          函数功能：总线挂起中断处理函数。
 566          入口参数：无。
 567          返    回：无。
 568          备    注：无。
 569          ********************************************************************/
 570          void UsbBusSuspend(void)
 571          {
 572   1      #ifdef DEBUG0
 573   1       Prints("USB总线挂起。\r\n");
 574   1      #endif
 575   1      }
 576          ////////////////////////End of function//////////////////////////////
 577          
 578          /********************************************************************
 579          函数功能：总线复位中断处理函数。
 580          入口参数：无。
 581          返    回：无。
 582          备    注：无。
 583          ********************************************************************/
 584          void UsbBusReset(void)
 585          {
 586   1      #ifdef DEBUG0
 587   1       Prints("USB总线复位。\r\n");
 588   1      #endif
 589   1       Ep1InIsBusy=0; //复位后端点1输入缓冲区空闲。
 590   1      }
 591          ////////////////////////End of function//////////////////////////////
 592          
 593          /********************************************************************
 594          函数功能：根据pData和SendLength将数据发送到端点0的函数。
 595          入口参数：无。
 596          返    回：无。
 597          备    注：无。
 598          ********************************************************************/
 599          void UsbEp0SendData(void)
 600          {
 601   1       //将数据写到端点中去准备发送
 602   1       //写之前要先判断一下需要发送的数据是否比端点0
 603   1       //最大长度大，如果超过端点大小，则一次只能发送
 604   1       //最大包长的数据。端点0的最大包长在DeviceDescriptor[7]
 605   1       if(SendLength>DeviceDescriptor[7])
 606   1       {
 607   2        //按最大包长度发送
 608   2        D12WriteEndpointBuffer(1,DeviceDescriptor[7],pSendData);
 609   2        //发送后剩余字节数减少最大包长
 610   2        SendLength-=DeviceDescriptor[7];
 611   2        //发送一次后指针位置要调整
 612   2        pSendData+= DeviceDescriptor[7];
 613   2       }
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 11  

 614   1       else
 615   1       {
 616   2        if(SendLength!=0)
 617   2        {
 618   3         //不够最大包长，可以直接发送
 619   3         D12WriteEndpointBuffer(1,SendLength,pSendData);
 620   3         //发送完毕后，SendLength长度变为0
 621   3         SendLength=0;
 622   3        }
 623   2        else //如果要发送的数据包长度为0
 624   2        {
 625   3         if(NeedZeroPacket==1) //如果需要发送0长度数据
 626   3         {
 627   4          D12WriteEndpointBuffer(1,0,pSendData); //发送0长度数据包
 628   4          NeedZeroPacket=0; //清需要发送0长度数据包标志
 629   4         }
 630   3        }
 631   2       }
 632   1      }
 633          ////////////////////////End of function//////////////////////////////
 634          
 635          /********************************************************************
 636          函数功能：端点0输出中断处理函数。
 637          入口参数：无。
 638          返    回：无。
 639          备    注：无。
 640          ********************************************************************/
 641          void UsbEp0Out(void)
 642          {
 643   1      #ifdef DEBUG0
 644   1       Prints("USB端点0输出中断。\r\n");
 645   1      #endif
 646   1       //读取端点0输出最后传输状态，该操作清除中断标志
 647   1       //并判断第5位是否为1，如果是，则说明是建立包
 648   1       if(D12ReadEndpointLastStatus(0)&0x20)
 649   1       {
 650   2        D12ReadEndpointBuffer(0,16,Buffer); //读建立过程数据
 651   2        D12AcknowledgeSetup(); //应答建立包
 652   2        D12ClearBuffer(); //清缓冲区
 653   2        //将缓冲数据填到设备请求的各字段中
 654   2        bmRequestType=Buffer[0];
 655   2        bRequest=Buffer[1];
 656   2        wValue=Buffer[2]+(((uint16)Buffer[3])<<8);
 657   2        wIndex=Buffer[4]+(((uint16)Buffer[5])<<8);
 658   2        wLength=Buffer[6]+(((uint16)Buffer[7])<<8);
 659   2        //下面的代码判断具体的请求，并根据不同的请求进行相关操作
 660   2        //如果D7位为1，则说明是输入请求
 661   2        if((bmRequestType&0x80)==0x80)
 662   2        {
 663   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 664   3         //0为标准请求，1为类请求，2为厂商请求。
 665   3         switch((bmRequestType>>5)&0x03)
 666   3         {
 667   4          case 0:  //标准请求
 668   4           #ifdef DEBUG0
 669   4            Prints("USB标准输入请求：");
 670   4           #endif
 671   4           //USB协议定义了几个标准输入请求，我们实现这些标准请求即可
 672   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 673   4           //事实上，我们还需要对接收者进行散转，因为不同的请求接收者
 674   4           //是不一样的。接收者在bmRequestType的D4~D0位中定义。
 675   4           //我们这里为了简化操作，有些就省略了对接收者的判断。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 12  

 676   4           //例如获取描述符的请求，只根据描述符的类型来区别。
 677   4           switch(bRequest)
 678   4           {
 679   5            case GET_CONFIGURATION: //获取配置
 680   5             #ifdef DEBUG0
 681   5              Prints("获取配置。\r\n");
 682   5             #endif
 683   5            break;
 684   5            
 685   5            case GET_DESCRIPTOR:  //获取描述符
 686   5             #ifdef DEBUG0
 687   5              Prints("获取描述符――");
 688   5             #endif
 689   5             //对描述符类型进行散转，对于全速设备，
 690   5             //标准请求只支持发送到设备的设备、配置、字符串三种描述符
 691   5             switch((wValue>>8)&0xFF)
 692   5              {
 693   6               case DEVICE_DESCRIPTOR: //设备描述符
 694   6                #ifdef DEBUG0
 695   6                 Prints("设备描述符。\r\n");
 696   6                #endif
 697   6                pSendData=DeviceDescriptor;  //需要发送的数据
 698   6                //判断请求的字节数是否比实际需要发送的字节数多
 699   6                //这里请求的是设备描述符，因此数据长度就是
 700   6                //DeviceDescriptor[0]。如果请求的比实际的长，
 701   6                //那么只返回实际长度的数据
 702   6                if(wLength>DeviceDescriptor[0])
 703   6                {
 704   7                 SendLength=DeviceDescriptor[0];
 705   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 706   7                 {
 707   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 708   8                 }
 709   7                }
 710   6                else
 711   6                {
 712   7                 SendLength=wLength;
 713   7                }
 714   6                //将数据通过EP0返回
 715   6                UsbEp0SendData();
 716   6               break;
 717   6               
 718   6               case CONFIGURATION_DESCRIPTOR:  //配置描述符
 719   6                #ifdef DEBUG0
 720   6                 Prints("配置描述符。\r\n");
 721   6                #endif
 722   6                pSendData=ConfigurationDescriptor; //需要发送的数据为配置描述符
 723   6                //判断请求的字节数是否比实际需要发送的字节数多
 724   6                //这里请求的是配置描述符集合，因此数据长度就是
 725   6                //ConfigurationDescriptor[3]*256+ConfigurationDescriptor[2]。
 726   6                //如果请求的比实际的长，那么只返回实际长度的数据
 727   6                SendLength=ConfigurationDescriptor[3];
 728   6                SendLength=SendLength*256+ConfigurationDescriptor[2];
 729   6                if(wLength>SendLength)
 730   6                {
 731   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 732   7                 {
 733   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 734   8                 }
 735   7                }
 736   6                else
 737   6                {
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 13  

 738   7                 SendLength=wLength;
 739   7                }
 740   6                //将数据通过EP0返回
 741   6                UsbEp0SendData();
 742   6               break;
 743   6               
 744   6               case STRING_DESCRIPTOR:  //字符串描述符
 745   6                #ifdef DEBUG0
 746   6                 Prints("字符串描述符");
 747   6                #endif
 748   6                switch(wValue&0xFF)  //根据wValue的低字节（索引值）散转
 749   6                {
 750   7                 case 0:  //获取语言ID
 751   7                  #ifdef DEBUG0
 752   7                   Prints("(语言ID)。\r\n");
 753   7                  #endif
 754   7                  pSendData=LanguageId;
 755   7                  SendLength=LanguageId[0];
 756   7                 break;
 757   7                 
 758   7                 case 1:  //厂商字符串的索引值为1，所以这里为厂商字符串
 759   7                 #ifdef DEBUG0
 760   7                   Prints("(厂商描述)。\r\n");
 761   7                  #endif
 762   7                  pSendData=ManufacturerStringDescriptor;
 763   7                  SendLength=ManufacturerStringDescriptor[0];
 764   7                 break;
 765   7                 
 766   7                 case 2:  //产品字符串的索引值为2，所以这里为产品字符串
 767   7                 #ifdef DEBUG0
 768   7                   Prints("(产品描述)。\r\n");
 769   7                  #endif
 770   7                  pSendData=ProductStringDescriptor;
 771   7                  SendLength=ProductStringDescriptor[0];
 772   7                 break;
 773   7                 
 774   7                 case 3:  //产品序列号的索引值为3，所以这里为序列号
 775   7                 #ifdef DEBUG0
 776   7                   Prints("(产品序列号)。\r\n");
 777   7                  #endif
 778   7                  pSendData=SerialNumberStringDescriptor;
 779   7                  SendLength=SerialNumberStringDescriptor[0];
 780   7                 break;
 781   7                 
 782   7                 default :
 783   7                  #ifdef DEBUG0
 784   7                   Prints("(未知的索引值)。\r\n");
 785   7                  #endif
 786   7                  //对于未知索引值的请求，返回一个0长度的包
 787   7                  SendLength=0;
 788   7                  NeedZeroPacket=1;
 789   7                 break;
 790   7                }
 791   6                //判断请求的字节数是否比实际需要发送的字节数多
 792   6                //如果请求的比实际的长，那么只返回实际长度的数据
 793   6                if(wLength>SendLength)
 794   6                {
 795   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 796   7                 {
 797   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 798   8                 }
 799   7                }
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 14  

 800   6                else
 801   6                {
 802   7                 SendLength=wLength;
 803   7                }
 804   6                //将数据通过EP0返回
 805   6                UsbEp0SendData();         
 806   6               break;
 807   6      
 808   6               case REPORT_DESCRIPTOR:  //报告描述符
 809   6                #ifdef DEBUG0
 810   6                 Prints("报告描述符。\r\n");
 811   6                #endif
 812   6                pSendData=ReportDescriptor; //需要发送的数据为报告描述符
 813   6                SendLength=sizeof(ReportDescriptor); //需要返回的数据长度         
 814   6                //判断请求的字节数是否比实际需要发送的字节数多
 815   6                //如果请求的比实际的长，那么只返回实际长度的数据
 816   6                if(wLength>SendLength)
 817   6                {
 818   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 819   7                 {
 820   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 821   8                 }
 822   7                }
 823   6                else
 824   6                {
 825   7                 SendLength=wLength;
 826   7                }
 827   6                //将数据通过EP0返回
 828   6                UsbEp0SendData();
 829   6               break;
 830   6                       
 831   6               default:  //其它描述符
 832   6                #ifdef DEBUG0
 833   6                 Prints("其他描述符，描述符代码：");
 834   6                 PrintHex((wValue>>8)&0xFF);
 835   6                 Prints("\r\n");
 836   6                #endif
 837   6               break;
 838   6              }
 839   5             break;
 840   5            
 841   5            case GET_INTERFACE: //获取接口
 842   5             #ifdef DEBUG0
 843   5              Prints("获取接口。\r\n");
 844   5             #endif
 845   5            break;
 846   5            
 847   5            case GET_STATUS: //获取状态
 848   5             #ifdef DEBUG0
 849   5              Prints("获取状态。\r\n");
 850   5             #endif
 851   5            break;
 852   5            
 853   5            case SYNCH_FRAME: //同步帧
 854   5             #ifdef DEBUG0
 855   5              Prints("同步帧。\r\n");
 856   5             #endif
 857   5            break;
 858   5            
 859   5            default:  //未定义的标准请求
 860   5             #ifdef DEBUG0
 861   5              Prints("错误：未定义的标准输入请求。\r\n");
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 15  

 862   5             #endif       
 863   5            break;
 864   5           }
 865   4          break;
 866   4          
 867   4          case 1:  //类请求
 868   4           #ifdef DEBUG0
 869   4            Prints("USB类输入请求：\r\n");
 870   4           #endif
 871   4          break;
 872   4          
 873   4          case 2:  //厂商请求
 874   4           #ifdef DEBUG0
 875   4            Prints("USB厂商输入请求：\r\n");
 876   4           #endif
 877   4          break;
 878   4          
 879   4          default: //未定义的请求。这里只显示一个报错信息。
 880   4           #ifdef DEBUG0
 881   4            Prints("错误：未定义的输入请求。\r\n");
 882   4           #endif
 883   4          break;
 884   4         }
 885   3        }
 886   2        //否则说明是输出请求
 887   2        else //if(bmRequestType&0x80==0x80)之else
 888   2        {
 889   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 890   3         //0为标准请求，1为类请求，2为厂商请求。
 891   3         switch((bmRequestType>>5)&0x03)
 892   3         {
 893   4          case 0:  //标准请求
 894   4           #ifdef DEBUG0
 895   4            Prints("USB标准输出请求：");
 896   4           #endif
 897   4           //USB协议定义了几个标准输出请求，我们实现这些标准请求即可
 898   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 899   4           switch(bRequest)
 900   4           {
 901   5            case CLEAR_FEATURE: //清除特性
 902   5             #ifdef DEBUG0
 903   5              Prints("清除特性。\r\n");
 904   5             #endif
 905   5            break;
 906   5            
 907   5            case SET_ADDRESS:  //设置地址
 908   5             #ifdef DEBUG0
 909   5              Prints("设置地址。地址为：");
 910   5              PrintHex(wValue&0xFF); //显示所设置的地址
 911   5              Prints("\r\n");
 912   5             #endif
 913   5             D12SetAddress(wValue&0xFF); //wValue中的低字节是设置的地址值
 914   5             //设置地址没有数据过程，直接进入到状态过程，返回一个0长度的数据包
 915   5             SendLength=0;
 916   5             NeedZeroPacket=1;
 917   5             //将数据通过EP0返回
 918   5             UsbEp0SendData();
 919   5            break;
 920   5            
 921   5            case SET_CONFIGURATION: //设置配置
 922   5             #ifdef DEBUG0
 923   5              Prints("设置配置。\r\n");
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 16  

 924   5             #endif
 925   5             //使能非0端点。非0端点只有在设置为非0的配置后才能使能。
 926   5             //wValue的低字节为配置的值，如果该值为非0，才能使能非0端点。
 927   5             //保存当前配置值
 928   5             ConfigValue=wValue&0xFF;
 929   5             D12SetEndpointEnable(ConfigValue);
 930   5             //返回一个0长度的状态数据包
 931   5             SendLength=0;
 932   5             NeedZeroPacket=1;
 933   5             //将数据通过EP0返回
 934   5             UsbEp0SendData();
 935   5            break;
 936   5            
 937   5            case SET_DESCRIPTOR: //设置描述符
 938   5             #ifdef DEBUG0
 939   5              Prints("设置描述符。\r\n");
 940   5             #endif
 941   5            break;
 942   5            
 943   5            case SET_FEATURE: //设置特性
 944   5             #ifdef DEBUG0
 945   5              Prints("设置特性。\r\n");
 946   5             #endif
 947   5            break;
 948   5      
 949   5            case SET_INTERFACE: //设置接口
 950   5             #ifdef DEBUG0
 951   5              Prints("设置接口。\r\n");
 952   5             #endif
 953   5            break;      
 954   5            
 955   5            default:  //未定义的标准请求
 956   5             #ifdef DEBUG0
 957   5              Prints("错误：未定义的标准输出请求。\r\n");
 958   5             #endif       
 959   5            break;
 960   5           }
 961   4          break;
 962   4          
 963   4          case 1:  //类请求
 964   4           #ifdef DEBUG0
 965   4            Prints("USB类输出请求：");
 966   4           #endif
 967   4           switch(bRequest)
 968   4           {
 969   5            case SET_IDLE:
 970   5             #ifdef DEBUG0
 971   5              Prints("设置空闲。\r\n");
 972   5             #endif
 973   5             //只需要返回一个0长度的数据包即可
 974   5             SendLength=0;
 975   5             NeedZeroPacket=1;
 976   5             //将数据通过EP0返回
 977   5             UsbEp0SendData();
 978   5            break;
 979   5            
 980   5            default:
 981   5             #ifdef DEBUG0
 982   5              Prints("未知请求。\r\n");
 983   5             #endif
 984   5            break;
 985   5           }
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 17  

 986   4          break;
 987   4          
 988   4          case 2:  //厂商请求
 989   4           #ifdef DEBUG0
 990   4            Prints("USB厂商输出请求：\r\n");
 991   4           #endif
 992   4          break;
 993   4          
 994   4          default: //未定义的请求。这里只显示一个报错信息。
 995   4           #ifdef DEBUG0
 996   4            Prints("错误：未定义的输出请求。\r\n");
 997   4           #endif
 998   4          break;
 999   4         }
1000   3        }
1001   2       }
1002   1       //普通数据输出
1003   1       else //if(D12ReadEndpointLastStatus(0)&0x20)之else
1004   1       {
1005   2        D12ReadEndpointBuffer(0,16,Buffer);
1006   2        D12ClearBuffer();
1007   2       }
1008   1      }
1009          ////////////////////////End of function//////////////////////////////
1010          
1011          /********************************************************************
1012          函数功能：端点0输入中断处理函数。
1013          入口参数：无。
1014          返    回：无。
1015          备    注：无。
1016          ********************************************************************/
1017          void UsbEp0In(void)
1018          {
1019   1      #ifdef DEBUG0
1020   1       Prints("USB端点0输入中断。\r\n");
1021   1      #endif
1022   1       //读最后发送状态，这将清除端点0的中断标志位
1023   1       D12ReadEndpointLastStatus(1);
1024   1       //发送剩余的字节数
1025   1       UsbEp0SendData();
1026   1      }
1027          ////////////////////////End of function//////////////////////////////
1028          
1029          /********************************************************************
1030          函数功能：端点1输出中断处理函数。
1031          入口参数：无。
1032          返    回：无。
1033          备    注：无。
1034          ********************************************************************/
1035          void UsbEp1Out(void)
1036          {
1037   1       uint8 Buf[1]; //用来保存1字节的输出报告，控制LED。
1038   1      #ifdef DEBUG0
1039   1       Prints("USB端点1输出中断。\r\n");
1040   1      #endif
1041   1       //读端点最后状态，这将清除端点1输出的中断标志位
1042   1       D12ReadEndpointLastStatus(2);
1043   1       //从端点1输出缓冲读回1字节数据
1044   1       D12ReadEndpointBuffer(2,1,Buf);
1045   1       //清除端点缓冲区
1046   1       D12ClearBuffer();
1047   1       //输出报告1字节为LED状态，某位为1时，表示LED亮。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:31 PAGE 18  

1048   1       LEDs=~Buf[0];
1049   1      }
1050          ////////////////////////End of function//////////////////////////////
1051          
1052          /********************************************************************
1053          函数功能：端点1输入中断处理函数。
1054          入口参数：无。
1055          返    回：无。
1056          备    注：无。
1057          ********************************************************************/
1058          void UsbEp1In(void)
1059          {
1060   1      #ifdef DEBUG0
1061   1       Prints("USB端点1输入中断。\r\n");
1062   1      #endif
1063   1       //读最后发送状态，这将清除端点1输入的中断标志位
1064   1       D12ReadEndpointLastStatus(3);
1065   1       //端点1输入处于空闲状态
1066   1       Ep1InIsBusy=0;
1067   1      }
1068          ////////////////////////End of function//////////////////////////////
1069          
1070          /********************************************************************
1071          函数功能：端点2输出中断处理函数。
1072          入口参数：无。
1073          返    回：无。
1074          备    注：无。
1075          ********************************************************************/
1076          void UsbEp2Out(void)
1077          {
1078   1      #ifdef DEBUG0
1079   1       Prints("USB端点2输出中断。\r\n");
1080   1      #endif
1081   1      }
1082          ////////////////////////End of function//////////////////////////////
1083          
1084          /********************************************************************
1085          函数功能：端点2输入中断处理函数。
1086          入口参数：无。
1087          返    回：无。
1088          备    注：无。
1089          ********************************************************************/
1090          void UsbEp2In(void)
1091          {
1092   1      #ifdef DEBUG0
1093   1       Prints("USB端点2输入中断。\r\n");
1094   1      #endif
1095   1      }
1096          ////////////////////////End of function//////////////////////////////


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1260    ----
   CONSTANT SIZE    =   1020    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16       1
   IDATA SIZE       =     16    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
