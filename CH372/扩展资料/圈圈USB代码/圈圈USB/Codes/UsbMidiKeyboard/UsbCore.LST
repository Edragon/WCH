C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE USBCORE
OBJECT MODULE PLACED IN UsbCore.OBJ
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE UsbCore.c BROWSE DEBUG OBJECTEXTEND TABS(1)

stmt level    source

   1          /******************************************************************
   2             本程序只供学习使用，未经作者许可，不得用于其它任何用途
   3             
   4                  欢迎访问我的USB专区：http://group.ednchina.com/93/
   5                  欢迎访问我的blog：   http://www.ednchina.com/blog/computer00
   6                                       http://computer00.21ic.org
   7          
   8                  感谢PCB赞助商――电子园： http://bbs.cepark.com/
   9          
  10          UsbCore.c file
  11          
  12          作者：电脑圈圈
  13          建立日期: 2008.06.29
  14          修改日期: 2008.08.08（2008北京奥运会开幕式呢）
  15          版本：V1.1
  16          版权所有，盗版必究。
  17          Copyright(C) 电脑圈圈 2008-2018
  18          All rights reserved            
  19          *******************************************************************/
  20          
  21          #include "config.h"
  22          #include "pdiusbd12.h"
  23          #include "uart.h"
  24          #include "usbcore.h"
  25          #include "led.h"
  26          
  27          idata uint8 Buffer[16];  //读端点0用的缓冲区
  28          
  29          //USB设备请求的各字段
  30          uint8  bmRequestType;
  31          uint8  bRequest;
  32          uint16 wValue;
  33          uint16 wIndex;
  34          uint16 wLength;
  35          //当前发送数据的位置
  36          uint8 * pSendData;
  37          //需要发送数据的长度
  38          uint16 SendLength;
  39          //是否需要发送0数据包的标志。在USB控制传输的数据过程中，
  40          //当返回的数据包字节数少于最大包长时，会认为数据过程结束。
  41          //当请求的字节数比实际需要返回的字节数长，而实际返回的字节
  42          //数又刚好是端点0大小的整数倍时，就需要返回一个0长度的数据包
  43          //来结束数据过程。因此这里增加一个标志，供程序决定是否需要返回
  44          //一个0长度的数据包。
  45          uint8 NeedZeroPacket;
  46          
  47          //当前的配置值。只有在设置非0配置后
  48          uint8 ConfigValue;
  49          
  50          //端点1缓冲是否忙的标志。当缓冲区中有数据时，该标志为真。
  51          //当缓冲区中空闲时，该标志为假。
  52          uint8 Ep1InIsBusy;
  53          uint8 Ep2InIsBusy;
  54          
  55          //USB设备描述符的定义
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 2   

  56          code uint8 DeviceDescriptor[0x12]=  //设备描述符为18字节
  57          {
  58          //bLength字段。设备描述符的长度为18(0x12)字节
  59           0x12,
  60           
  61          //bDescriptorType字段。设备描述符的编号为0x01
  62           0x01,
  63           
  64          //bcdUSB字段。这里设置版本为USB1.1，即0x0110。
  65          //由于是小端结构，所以低字节在先，即0x10，0x01。
  66           0x10,
  67           0x01,
  68           
  69          //bDeviceClass字段。我们不在设备描述符中定义设备类，
  70          //而在接口描述符中定义设备类，所以该字段的值为0。
  71           0x00,
  72           
  73          //bDeviceSubClass字段。bDeviceClass字段为0时，该字段也为0。
  74           0x00,
  75           
  76          //bDeviceProtocol字段。bDeviceClass字段为0时，该字段也为0。
  77           0x00,
  78           
  79          //bMaxPacketSize0字段。PDIUSBD12的端点0大小的16字节。
  80           0x10,
  81           
  82          //idVender字段。厂商ID号，我们这里取0x8888，仅供实验用。
  83          //实际产品不能随便使用厂商ID号，必须跟USB协会申请厂商ID号。
  84          //注意小端模式，低字节在先。
  85           0x88,
  86           0x88,
  87           
  88          //idProduct字段。产品ID号，由于是第八个实验，我们这里取0x0008。
  89          //注意小端模式，低字节应该在前。
  90           0x08,
  91           0x00,
  92           
  93          //bcdDevice字段。我们这个USB键盘刚开始做，就叫它1.0版吧，即0x0100。
  94          //小端模式，低字节在先。
  95           0x00,
  96           0x01,
  97           
  98          //iManufacturer字段。厂商字符串的索引值，为了方便记忆和管理，
  99          //字符串索引就从1开始吧。
 100           0x01,
 101          
 102          //iProduct字段。产品字符串的索引值。刚刚用了1，这里就取2吧。
 103          //注意字符串索引值不要使用相同的值。
 104           0x02,
 105           
 106          //iSerialNumber字段。设备的序列号字符串索引值。
 107          //这里取3就可以了。
 108           0x03,
 109          
 110          //bNumConfigurations字段。该设备所具有的配置数。
 111          //我们只需要一种配置就行了，因此该值设置为1。
 112           0x01
 113          };
 114          //////////////////////////设备描述符完毕//////////////////////////////
 115          
 116          //USB配置描述符集合的定义
 117          //配置描述符总长度为9+9+9+9+7+6+6+9+9+7+5+7+5字节
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 3   

 118          code uint8 ConfigurationDescriptor[9+9+9+9+7+6+6+9+9+7+5+7+5]=
 119          {
 120           /***************配置描述符***********************/
 121           //bLength字段。配置描述符的长度为9字节。
 122           0x09,
 123           
 124           //bDescriptorType字段。配置描述符编号为0x02。
 125           0x02,
 126           
 127           //wTotalLength字段。配置描述符集合的总长度，
 128           //包括配置描述符本身、接口描述符、类描述符、端点描述符等。
 129           sizeof(ConfigurationDescriptor)&0xFF, //低字节
 130           (sizeof(ConfigurationDescriptor)>>8)&0xFF, //高字节
 131           
 132           //bNumInterfaces字段。该配置包含的接口数，有2个接口。
 133           0x02,
 134           
 135           //bConfiguration字段。该配置的值为1。
 136           0x01,
 137           
 138           //iConfigurationz字段，该配置的字符串索引。这里没有，为0。
 139           0x00,
 140           
 141           //bmAttributes字段，该设备的属性。由于我们的板子是总线供电的，
 142           //并且我们不想实现远程唤醒的功能，所以该字段的值为0x80。
 143           0x80,
 144           
 145           //bMaxPower字段，该设备需要的最大电流量。由于我们的板子
 146           //需要的电流不到100mA，因此我们这里设置为100mA。由于每单位
 147           //电流为2mA，所以这里设置为50(0x32)。
 148           0x32,
 149           
 150           /*****************音频控制接口描述符*******************/
 151           //bLength字段。接口描述符的长度为9字节。
 152           0x09,
 153           
 154           //bDescriptorType字段。接口描述符的编号为0x04。
 155           0x04,
 156           
 157           //bInterfaceNumber字段。该接口的编号，第一个接口，编号为0。
 158           0x00,
 159           
 160           //bAlternateSetting字段。该接口的备用编号，为0。
 161           0x00,
 162           
 163           //bNumEndpoints字段。非0端点的数目。该接口没有端点
 164           0x00,
 165           
 166           //bInterfaceClass字段。该接口所使用的类。音频接口类的代码为0x01。
 167           0x01,
 168           
 169           //bInterfaceSubClass字段。该接口所使用的子类。音频控制接口的子类代码为0x01。
 170           0x01,
 171           
 172           //bInterfaceProtocol字段。没有使用协议。
 173           0x00,
 174           
 175           //iConfiguration字段。该接口的字符串索引值。这里没有，为0。
 176           0x00,
 177           
 178           
 179           /*************类特殊音频控制接口**********/
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 4   

 180           //bLength字段，该描述符的长度。为9字节。
 181           0x09,
 182           
 183           //bDescriptorType字段，描述符的类型。编号为0x24，CS_INTERFACE_DESCRIPTOR。
 184           0x24,
 185           
 186           //bDescriptorSubtype字段，描述符子类。编号为0x01，HEADER。
 187           0x01,
 188           
 189           //bcdADC字段，协议版本。这里为1.0版。
 190           0x00,
 191           0x01,
 192           
 193           //wTotalLength字段，类特殊描述符的总长度。这里为9字节。
 194           0x09,
 195           0x00,
 196          
 197           //bInCollection字段，流接口的数量。这里仅有一个。
 198           0x01,
 199           
 200           //baInterfaceNr字段，属于此接口的流接口编号。MIDI 流接口1属于此音频控制接口
 201           0x01,
 202          
 203           /*****************MIDI流接口描述符*******************/
 204           //bLength字段。接口描述符的长度为9字节。
 205           0x09,
 206           
 207           //bDescriptorType字段。接口描述符的编号为0x04。
 208           0x04,
 209           
 210           //bInterfaceNumber字段。该接口的编号，第二个接口，编号为1。
 211           0x01,
 212           
 213           //bAlternateSetting字段。该接口的备用编号，为0。
 214           0x00,
 215           
 216           //bNumEndpoints字段。非0端点的数目。MIDI流接口使用一对批量输出/输出端点。
 217           0x02,
 218           
 219           //bInterfaceClass字段。该接口所使用的类。音频接口类的代码为0x01。
 220           0x01,
 221           
 222           //bInterfaceSubClass字段。该接口所使用的子类。MIDI流接口的子类代码为0x03。
 223           0x03,
 224           
 225           //bInterfaceProtocol字段。没有使用协议。
 226           0x00,
 227           
 228           //iConfiguration字段。该接口的字符串索引值。这里没有，为0。
 229           0x00,
 230           
 231           /**********类特殊MIDI流接口描述符*****/
 232           /*******头描述符********/
 233           //bLength字段。该描述符的长度，7字节。
 234           0x07,
 235           
 236           //bDescriptorType字段。该描述符的类型，为CS_INTERFACE。
 237           0x24,
 238           
 239           //bDescriptorSubtype字段。描述符子类，为MS_HEADER
 240           0x01,
 241           
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 5   

 242           //bcdMSC字段。该MIDI流类所使用的协议版本，为1.0
 243           0x00,
 244           0x01,
 245           
 246           //wTotalLengthz字段。整个类特殊MIDI流接口描述符总长度
 247           0x25,
 248           0x00,
 249           
 250           /**********内嵌输入插孔描述符********/
 251           //bLength字段。该描述符的长度，为6字节。
 252           0x06,
 253           
 254           //bDescriptorType字段。该描述符的类型，为CS_INTERFACE。
 255           0x24,
 256           
 257           //bDescriptorSubtype字段。描述符子类，为MIDI_IN_JACK
 258           0x02,
 259           
 260           //bJackType字段。该插孔的类型，为内嵌（EMBEDDED）
 261           0x01,
 262           
 263           //bJackID字段。该插孔的唯一ID，这里取值1
 264           0x01,
 265           
 266           //iJack字段。该插孔的字符串描述符索引，这里没有，为0
 267           0x00,
 268          
 269           /**********外部输入插孔描述符********/
 270           //bLength字段。该描述符的长度，为6字节。
 271           0x06,
 272           
 273           //bDescriptorType字段。该描述符的类型，为CS_INTERFACE。
 274           0x24,
 275           
 276           //bDescriptorSubtype字段。描述符子类，为MIDI_IN_JACK
 277           0x02,
 278           
 279           //bJackType字段。该插孔的类型，为外部（EXTERNAL）
 280           0x02,
 281           
 282           //bJackID字段。该插孔的唯一ID，这里取值2
 283           0x02,
 284           
 285           //iJack字段。该插孔的字符串描述符索引，这里没有，为0
 286           0x00,
 287            
 288           /**********内嵌输出插孔描述符********/
 289           //bLength字段。该描述符的长度，为9字节。
 290           0x09,
 291           
 292           //bDescriptorType字段。该描述符的类型，为CS_INTERFACE。
 293           0x24,
 294           
 295           //bDescriptorSubtype字段。描述符子类，为MIDI_OUT_JACK
 296           0x03,
 297           
 298           //bJackType字段。该插孔的类型，为内嵌（EMBEDDED）
 299           0x01,
 300           
 301           //bJackID字段。该插孔的唯一ID，这里取值3
 302           0x03,
 303           
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 6   

 304           //bNrInputPins字段。该输出插孔的输入引脚数。这里仅有一个。
 305           0x01,
 306           
 307           //baSourceID字段。连接到该插孔输入引脚的输入插孔的ID，选择为外部输入插孔2
 308           0x02,
 309           
 310           //BaSourcePin字段。外部输入插孔连接在该插孔的输入引脚1上
 311           0x01,
 312           
 313           //iJack字段。该插孔的字符串描述符索引，这里没有，为0
 314           0x00, 
 315          
 316           /**********外部输出插孔描述符********/
 317           //bLength字段。该描述符的长度，为9字节。
 318           0x09,
 319           
 320           //bDescriptorType字段。该描述符的类型，为CS_INTERFACE。
 321           0x24,
 322           
 323           //bDescriptorSubtype字段。描述符子类，为MIDI_OUT_JACK
 324           0x03,
 325           
 326           //bJackType字段。该插孔的类型，为外部（EXTERNAL）
 327           0x02,
 328           
 329           //bJackID字段。该插孔的唯一ID，这里取值4
 330           0x04,
 331           
 332           //bNrInputPins字段。该输出插孔的输入引脚数。这里仅有一个。
 333           0x01,
 334           
 335           //baSourceID字段。连接到该插孔输入引脚的输入插孔的ID，选择为内嵌输入插孔
 336           0x01,
 337           
 338           //BaSourcePin字段。内嵌输入插孔连接在该插孔的输入引脚1上
 339           0x01,
 340           
 341           //iJack字段。该插孔的字符串描述符索引，这里没有，为0
 342           0x00,
 343            
 344           /*************标准批量数据输入端点描述符****************/
 345           //bLength字段。端点描述符长度为7字节。
 346           0x07,
 347           
 348           //bDescriptorType字段。端点描述符编号为0x05。
 349           0x05,
 350           
 351           //bEndpointAddress字段。端点的地址。我们使用D12的输入端点2。
 352           //D7位表示数据方向，输入端点D7为1。所以输入端点2的地址为0x82。
 353           0x82,
 354           
 355           //bmAttributes字段。D1~D0为端点传输类型选择。
 356           //该端点为批端点。批量端点的编号为2。其它位保留为0。
 357           0x02,
 358           
 359           //wMaxPacketSize字段。该端点的最大包长。端点2的最大包长为64字节。
 360           //注意低字节在先。
 361           0x40,
 362           0x00,
 363           
 364           //bInterval字段。端点查询的时间，此处无意义。
 365           0x00,
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 7   

 366           
 367           /**********类特殊MIDI流批量数据端点描述符********/
 368           //bLength字段，该描述符的长度。为5字节。
 369           0x05,
 370           
 371           //bDescriptorType字段，该描述符的类型，为类特殊端点描述符（CS_ENDPOINT）
 372           0x25,
 373           
 374           //bDescriptorSubType字段，该描述符的子类型，为MS_GENERAL
 375           0x01,
 376           
 377           //bNumEmbMIDIJack字段，该端点的内嵌输出插孔的数量，这里只有1个
 378           0x01,
 379           
 380           //baAssocJackID字段，该端点的内嵌输出插孔的ID号。
 381           //我们在前面定义了一个内嵌输出插孔，ID号为3。
 382           0x03,
 383           
 384           /*************标准批量数据输出端点描述符****************/
 385           //bLength字段。端点描述符长度为7字节。
 386           0x07,
 387           
 388           //bDescriptorType字段。端点描述符编号为0x05。
 389           0x05,
 390           
 391           //bEndpointAddress字段。端点的地址。我们使用D12的输出端点2。
 392           //D7位表示数据方向，输出端点D7为0。所以输出端点2的地址为0x02。
 393           0x02,
 394           
 395           //bmAttributes字段。D1~D0为端点传输类型选择。
 396           //该端点为批端点。批量端点的编号为2。其它位保留为0。
 397           0x02,
 398           
 399           //wMaxPacketSize字段。该端点的最大包长。端点2的最大包长为64字节。
 400           //注意低字节在先。
 401           0x40,
 402           0x00,
 403           
 404           //bInterval字段。端点查询的时间，此处无意义。
 405           0x00,
 406          
 407           /**********类特殊MIDI流批量数据端点描述符********/
 408           //bLength字段，该描述符的长度。为5字节。
 409           0x05,
 410           
 411           //bDescriptorType字段，该描述符的类型，为类特殊端点描述符（CS_ENDPOINT）
 412           0x25,
 413           
 414           //bDescriptorSubType字段，该描述符的子类型，为MS_GENERAL
 415           0x01,
 416           
 417           //bNumEmbMIDIJack字段，该端点的内嵌输入插孔的数量，这里只有1个
 418           0x01,
 419           
 420           //baAssocJackID字段，该端点的内嵌输入插孔的ID号。
 421           //我们在前面定义了一个内嵌输入插孔，ID号为1。
 422           0x01
 423          };
 424          ////////////////////////配置描述符集合完毕//////////////////////////
 425          
 426          /************************语言ID的定义********************/
 427          code uint8 LanguageId[4]=
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 8   

 428          {
 429           0x04, //本描述符的长度
 430           0x03, //字符串描述符
 431           //0x0409为美式英语的ID
 432           0x09,
 433           0x04
 434          };
 435          ////////////////////////语言ID完毕//////////////////////////////////
 436          
 437          /**************************************************/
 438          /*********        本转换结果来自         **********/
 439          /********* Http://computer00.21ic.org    **********/
 440          /*********        作者: 电脑圈圈         **********/
 441          /*********         欢迎大家使用          **********/
 442          /*********    版权所有，盗版请写明出处   **********/
 443          /**************************************************/
 444          
 445          //http://computer00.21ic.org/user1/2198/archives/2007/42769.html
 446          //字符串“电脑圈圈的USB专区 Http://group.ednchina.com/93/”的Unicode编码
 447          //8位小端格式
 448          code uint8 ManufacturerStringDescriptor[82]={
 449          82,         //该描述符的长度为82字节
 450          0x03,       //字符串描述符的类型编码为0x03
 451          0x35, 0x75, //电
 452          0x11, 0x81, //脑
 453          0x08, 0x57, //圈
 454          0x08, 0x57, //圈
 455          0x84, 0x76, //的
 456          0x55, 0x00, //U
 457          0x53, 0x00, //S
 458          0x42, 0x00, //B
 459          0x13, 0x4e, //专
 460          0x3a, 0x53, //区
 461          0x20, 0x00, // 
 462          0x48, 0x00, //H
 463          0x74, 0x00, //t
 464          0x74, 0x00, //t
 465          0x70, 0x00, //p
 466          0x3a, 0x00, //:
 467          0x2f, 0x00, ///
 468          0x2f, 0x00, ///
 469          0x67, 0x00, //g
 470          0x72, 0x00, //r
 471          0x6f, 0x00, //o
 472          0x75, 0x00, //u
 473          0x70, 0x00, //p
 474          0x2e, 0x00, //.
 475          0x65, 0x00, //e
 476          0x64, 0x00, //d
 477          0x6e, 0x00, //n
 478          0x63, 0x00, //c
 479          0x68, 0x00, //h
 480          0x69, 0x00, //i
 481          0x6e, 0x00, //n
 482          0x61, 0x00, //a
 483          0x2e, 0x00, //.
 484          0x63, 0x00, //c
 485          0x6f, 0x00, //o
 486          0x6d, 0x00, //m
 487          0x2f, 0x00, ///
 488          0x39, 0x00, //9
 489          0x33, 0x00, //3
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 9   

 490          0x2f, 0x00  ///
 491          };
 492          /////////////////////////厂商字符串结束/////////////////////////////
 493          
 494          //字符串“《圈圈教你玩USB》之USB MIDI键盘”的Unicode编码
 495          //8位小端格式
 496          code uint8 ProductStringDescriptor[44]={
 497          44,         //该描述符的长度为44字节
 498          0x03,       //字符串描述符的类型编码为0x03
 499          0x0a, 0x30, //《
 500          0x08, 0x57, //圈
 501          0x08, 0x57, //圈
 502          0x59, 0x65, //教
 503          0x60, 0x4f, //你
 504          0xa9, 0x73, //玩
 505          0x55, 0x00, //U
 506          0x53, 0x00, //S
 507          0x42, 0x00, //B
 508          0x0b, 0x30, //》
 509          0x4b, 0x4e, //之
 510          0x55, 0x00, //U
 511          0x53, 0x00, //S
 512          0x42, 0x00, //B
 513          0x20, 0x00, // 
 514          0x4d, 0x00, //M
 515          0x49, 0x00, //I
 516          0x44, 0x00, //D
 517          0x49, 0x00, //I
 518          0x2e, 0x95, //键
 519          0xd8, 0x76  //盘
 520          };
 521          ////////////////////////产品字符串结束////////////////////////////
 522          
 523          //字符串“2008-08-08”的Unicode编码
 524          //8位小端格式
 525          code uint8 SerialNumberStringDescriptor[22]={
 526          22,         //该描述符的长度为22字节
 527          0x03,       //字符串描述符的类型编码为0x03
 528          0x32, 0x00, //2
 529          0x30, 0x00, //0
 530          0x30, 0x00, //0
 531          0x38, 0x00, //8
 532          0x2d, 0x00, //-
 533          0x30, 0x00, //0
 534          0x38, 0x00, //8
 535          0x2d, 0x00, //-
 536          0x30, 0x00, //0
 537          0x38, 0x00  //8
 538          };
 539          //////////////////////产品序列号字符串结束/////////////////////////
 540          
 541          /********************************************************************
 542          函数功能：延时x毫秒函数。
 543          入口参数：x：延时的毫秒数。
 544          返    回：无。
 545          备    注：无。
 546          ********************************************************************/
 547          void DelayXms(uint16 x)                
 548          {
 549   1       uint16 i;
 550   1       uint16 j;
 551   1       for(i=0;i<x;i++)
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 10  

 552   1       for(j=0;j<227;j++); //循环语句延时
 553   1      }
 554          ////////////////////////End of function//////////////////////////////
 555          
 556          /********************************************************************
 557          函数功能：USB断开连接函数。
 558          入口参数：无。
 559          返    回：无。
 560          备    注：无。
 561          ********************************************************************/
 562          void UsbDisconnect(void)
 563          {
 564   1      #ifdef DEBUG0
               Prints("断开USB连接。\r\n");
              #endif
 567   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 568   1       D12WriteByte(0x06); //设置模式的第一字节
 569   1       D12WriteByte(0x47); //设置模式的第二字节
 570   1       DelayXms(1000);  //延迟1秒
 571   1      }
 572          ////////////////////////End of function//////////////////////////////
 573          
 574          /********************************************************************
 575          函数功能：USB连接函数。
 576          入口参数：无。
 577          返    回：无。
 578          备    注：无。
 579          ********************************************************************/
 580          void UsbConnect(void)
 581          {
 582   1      #ifdef DEBUG0
               Prints("连接USB。\r\n");
              #endif
 585   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 586   1       D12WriteByte(0x16); //设置模式的第一字节
 587   1       D12WriteByte(0x47); //设置模式的第二字节
 588   1      }
 589          ////////////////////////End of function//////////////////////////////
 590          
 591          /********************************************************************
 592          函数功能：总线挂起中断处理函数。
 593          入口参数：无。
 594          返    回：无。
 595          备    注：无。
 596          ********************************************************************/
 597          void UsbBusSuspend(void)
 598          {
 599   1      #ifdef DEBUG0
               Prints("USB总线挂起。\r\n");
              #endif
 602   1      }
 603          ////////////////////////End of function//////////////////////////////
 604          
 605          /********************************************************************
 606          函数功能：总线复位中断处理函数。
 607          入口参数：无。
 608          返    回：无。
 609          备    注：无。
 610          ********************************************************************/
 611          void UsbBusReset(void)
 612          {
 613   1      #ifdef DEBUG0
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 11  

               Prints("USB总线复位。\r\n");
              #endif
 616   1       Ep1InIsBusy=0; //复位后端点1输入缓冲区空闲。
 617   1       Ep2InIsBusy=0; //复位后端点2输入缓冲区空闲。
 618   1      }
 619          ////////////////////////End of function//////////////////////////////
 620          
 621          /********************************************************************
 622          函数功能：根据pData和SendLength将数据发送到端点0的函数。
 623          入口参数：无。
 624          返    回：无。
 625          备    注：无。
 626          ********************************************************************/
 627          void UsbEp0SendData(void)
 628          {
 629   1       //将数据写到端点中去准备发送
 630   1       //写之前要先判断一下需要发送的数据是否比端点0
 631   1       //最大长度大，如果超过端点大小，则一次只能发送
 632   1       //最大包长的数据。端点0的最大包长在DeviceDescriptor[7]
 633   1       if(SendLength>DeviceDescriptor[7])
 634   1       {
 635   2        //按最大包长度发送
 636   2        D12WriteEndpointBuffer(1,DeviceDescriptor[7],pSendData);
 637   2        //发送后剩余字节数减少最大包长
 638   2        SendLength-=DeviceDescriptor[7];
 639   2        //发送一次后指针位置要调整
 640   2        pSendData+= DeviceDescriptor[7];
 641   2       }
 642   1       else
 643   1       {
 644   2        if(SendLength!=0)
 645   2        {
 646   3         //不够最大包长，可以直接发送
 647   3         D12WriteEndpointBuffer(1,SendLength,pSendData);
 648   3         //发送完毕后，SendLength长度变为0
 649   3         SendLength=0;
 650   3        }
 651   2        else //如果要发送的数据包长度为0
 652   2        {
 653   3         if(NeedZeroPacket==1) //如果需要发送0长度数据
 654   3         {
 655   4          D12WriteEndpointBuffer(1,0,pSendData); //发送0长度数据包
 656   4          NeedZeroPacket=0; //清需要发送0长度数据包标志
 657   4         }
 658   3        }
 659   2       }
 660   1      }
 661          ////////////////////////End of function//////////////////////////////
 662          
 663          /********************************************************************
 664          函数功能：端点0输出中断处理函数。
 665          入口参数：无。
 666          返    回：无。
 667          备    注：无。
 668          ********************************************************************/
 669          void UsbEp0Out(void)
 670          {
 671   1      #ifdef DEBUG0
               Prints("USB端点0输出中断。\r\n");
              #endif
 674   1       //读取端点0输出最后传输状态，该操作清除中断标志
 675   1       //并判断第5位是否为1，如果是，则说明是建立包
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 12  

 676   1       if(D12ReadEndpointLastStatus(0)&0x20)
 677   1       {
 678   2        D12ReadEndpointBuffer(0,16,Buffer); //读建立过程数据
 679   2        D12AcknowledgeSetup(); //应答建立包
 680   2        D12ClearBuffer(); //清缓冲区
 681   2        //将缓冲数据填到设备请求的各字段中
 682   2        bmRequestType=Buffer[0];
 683   2        bRequest=Buffer[1];
 684   2        wValue=Buffer[2]+(((uint16)Buffer[3])<<8);
 685   2        wIndex=Buffer[4]+(((uint16)Buffer[5])<<8);
 686   2        wLength=Buffer[6]+(((uint16)Buffer[7])<<8);
 687   2        //下面的代码判断具体的请求，并根据不同的请求进行相关操作
 688   2        //如果D7位为1，则说明是输入请求
 689   2        if((bmRequestType&0x80)==0x80)
 690   2        {
 691   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 692   3         //0为标准请求，1为类请求，2为厂商请求。
 693   3         switch((bmRequestType>>5)&0x03)
 694   3         {
 695   4          case 0:  //标准请求
 696   4           #ifdef DEBUG0
                    Prints("USB标准输入请求：");
                   #endif
 699   4           //USB协议定义了几个标准输入请求，我们实现这些标准请求即可
 700   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 701   4           //事实上，我们还需要对接收者进行散转，因为不同的请求接收者
 702   4           //是不一样的。接收者在bmRequestType的D4~D0位中定义。
 703   4           //我们这里为了简化操作，有些就省略了对接收者的判断。
 704   4           //例如获取描述符的请求，只根据描述符的类型来区别。
 705   4           switch(bRequest)
 706   4           {
 707   5            case GET_CONFIGURATION: //获取配置
 708   5             #ifdef DEBUG0
                      Prints("获取配置。\r\n");
                     #endif
 711   5            break;
 712   5            
 713   5            case GET_DESCRIPTOR:  //获取描述符
 714   5             #ifdef DEBUG0
                      Prints("获取描述符――");
                     #endif
 717   5             //对描述符类型进行散转，对于全速设备，
 718   5             //标准请求只支持发送到设备的设备、配置、字符串三种描述符
 719   5             switch((wValue>>8)&0xFF)
 720   5              {
 721   6               case DEVICE_DESCRIPTOR: //设备描述符
 722   6                #ifdef DEBUG0
                         Prints("设备描述符。\r\n");
                        #endif
 725   6                pSendData=DeviceDescriptor;  //需要发送的数据
 726   6                //判断请求的字节数是否比实际需要发送的字节数多
 727   6                //这里请求的是设备描述符，因此数据长度就是
 728   6                //DeviceDescriptor[0]。如果请求的比实际的长，
 729   6                //那么只返回实际长度的数据
 730   6                if(wLength>DeviceDescriptor[0])
 731   6                {
 732   7                 SendLength=DeviceDescriptor[0];
 733   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 734   7                 {
 735   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 736   8                 }
 737   7                }
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 13  

 738   6                else
 739   6                {
 740   7                 SendLength=wLength;
 741   7                }
 742   6                //将数据通过EP0返回
 743   6                UsbEp0SendData();
 744   6               break;
 745   6               
 746   6               case CONFIGURATION_DESCRIPTOR:  //配置描述符
 747   6                #ifdef DEBUG0
                         Prints("配置描述符。\r\n");
                        #endif
 750   6                pSendData=ConfigurationDescriptor; //需要发送的数据为配置描述符
 751   6                //判断请求的字节数是否比实际需要发送的字节数多
 752   6                //这里请求的是配置描述符集合，因此数据长度就是
 753   6                //ConfigurationDescriptor[3]*256+ConfigurationDescriptor[2]。
 754   6                //如果请求的比实际的长，那么只返回实际长度的数据
 755   6                SendLength=ConfigurationDescriptor[3];
 756   6                SendLength=SendLength*256+ConfigurationDescriptor[2];
 757   6                if(wLength>SendLength)
 758   6                {
 759   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 760   7                 {
 761   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 762   8                 }
 763   7                }
 764   6                else
 765   6                {
 766   7                 SendLength=wLength;
 767   7                }
 768   6                //将数据通过EP0返回
 769   6                UsbEp0SendData();
 770   6               break;
 771   6               
 772   6               case STRING_DESCRIPTOR:  //字符串描述符
 773   6                #ifdef DEBUG0
                         Prints("字符串描述符");
                        #endif
 776   6                switch(wValue&0xFF)  //根据wValue的低字节（索引值）散转
 777   6                {
 778   7                 case 0:  //获取语言ID
 779   7                  #ifdef DEBUG0
                           Prints("(语言ID)。\r\n");
                          #endif
 782   7                  pSendData=LanguageId;
 783   7                  SendLength=LanguageId[0];
 784   7                 break;
 785   7                 
 786   7                 case 1:  //厂商字符串的索引值为1，所以这里为厂商字符串
 787   7                 #ifdef DEBUG0
                           Prints("(厂商描述)。\r\n");
                          #endif
 790   7                  pSendData=ManufacturerStringDescriptor;
 791   7                  SendLength=ManufacturerStringDescriptor[0];
 792   7                 break;
 793   7                 
 794   7                 case 2:  //产品字符串的索引值为2，所以这里为产品字符串
 795   7                 #ifdef DEBUG0
                           Prints("(产品描述)。\r\n");
                          #endif
 798   7                  pSendData=ProductStringDescriptor;
 799   7                  SendLength=ProductStringDescriptor[0];
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 14  

 800   7                 break;
 801   7                 
 802   7                 case 3:  //产品序列号的索引值为3，所以这里为序列号
 803   7                 #ifdef DEBUG0
                           Prints("(产品序列号)。\r\n");
                          #endif
 806   7                  pSendData=SerialNumberStringDescriptor;
 807   7                  SendLength=SerialNumberStringDescriptor[0];
 808   7                 break;
 809   7                 
 810   7                 default :
 811   7                  #ifdef DEBUG0
                           Prints("(未知的索引值)。\r\n");
                          #endif
 814   7                  //对于未知索引值的请求，返回一个0长度的包
 815   7                  SendLength=0;
 816   7                  NeedZeroPacket=1;
 817   7                 break;
 818   7                }
 819   6                //判断请求的字节数是否比实际需要发送的字节数多
 820   6                //如果请求的比实际的长，那么只返回实际长度的数据
 821   6                if(wLength>SendLength)
 822   6                {
 823   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 824   7                 {
 825   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 826   8                 }
 827   7                }
 828   6                else
 829   6                {
 830   7                 SendLength=wLength;
 831   7                }
 832   6                //将数据通过EP0返回
 833   6                UsbEp0SendData();         
 834   6               break;
 835   6      
 836   6               case REPORT_DESCRIPTOR:  //报告描述符
 837   6                #ifdef DEBUG0
                         Prints("报告描述符。\r\n");
                        #endif
 840   6               break;
 841   6                       
 842   6               default:  //其它描述符
 843   6                #ifdef DEBUG0
                         Prints("其他描述符，描述符代码：");
                         PrintHex((wValue>>8)&0xFF);
                         Prints("\r\n");
                        #endif
 848   6               break;
 849   6              }
 850   5             break;
 851   5            
 852   5            case GET_INTERFACE: //获取接口
 853   5             #ifdef DEBUG0
                      Prints("获取接口。\r\n");
                     #endif
 856   5            break;
 857   5            
 858   5            case GET_STATUS: //获取状态
 859   5             #ifdef DEBUG0
                      Prints("获取状态。\r\n");
                     #endif
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 15  

 862   5            break;
 863   5            
 864   5            case SYNCH_FRAME: //同步帧
 865   5             #ifdef DEBUG0
                      Prints("同步帧。\r\n");
                     #endif
 868   5            break;
 869   5            
 870   5            default:  //未定义的标准请求
 871   5             #ifdef DEBUG0
                      Prints("错误：未定义的标准输入请求。\r\n");
                     #endif       
 874   5            break;
 875   5           }
 876   4          break;
 877   4          
 878   4          case 1:  //类请求
 879   4           #ifdef DEBUG0
                    Prints("USB类输入请求：\r\n");
                   #endif
 882   4          break;
 883   4          
 884   4          case 2:  //厂商请求
 885   4           #ifdef DEBUG0
                    Prints("USB厂商输入请求：\r\n");
                   #endif
 888   4          break;
 889   4          
 890   4          default: //未定义的请求。这里只显示一个报错信息。
 891   4           #ifdef DEBUG0
                    Prints("错误：未定义的输入请求。\r\n");
                   #endif
 894   4          break;
 895   4         }
 896   3        }
 897   2        //否则说明是输出请求
 898   2        else //if(bmRequestType&0x80==0x80)之else
 899   2        {
 900   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 901   3         //0为标准请求，1为类请求，2为厂商请求。
 902   3         switch((bmRequestType>>5)&0x03)
 903   3         {
 904   4          case 0:  //标准请求
 905   4           #ifdef DEBUG0
                    Prints("USB标准输出请求：");
                   #endif
 908   4           //USB协议定义了几个标准输出请求，我们实现这些标准请求即可
 909   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 910   4           switch(bRequest)
 911   4           {
 912   5            case CLEAR_FEATURE: //清除特性
 913   5             #ifdef DEBUG0
                      Prints("清除特性。\r\n");
                     #endif
 916   5            break;
 917   5            
 918   5            case SET_ADDRESS:  //设置地址
 919   5             #ifdef DEBUG0
                      Prints("设置地址。地址为：");
                      PrintHex(wValue&0xFF); //显示所设置的地址
                      Prints("\r\n");
                     #endif
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 16  

 924   5             D12SetAddress(wValue&0xFF); //wValue中的低字节是设置的地址值
 925   5             //设置地址没有数据过程，直接进入到状态过程，返回一个0长度的数据包
 926   5             SendLength=0;
 927   5             NeedZeroPacket=1;
 928   5             //将数据通过EP0返回
 929   5             UsbEp0SendData();
 930   5            break;
 931   5            
 932   5            case SET_CONFIGURATION: //设置配置
 933   5             #ifdef DEBUG0
                      Prints("设置配置。\r\n");
                     #endif
 936   5             //使能非0端点。非0端点只有在设置为非0的配置后才能使能。
 937   5             //wValue的低字节为配置的值，如果该值为非0，才能使能非0端点。
 938   5             //保存当前配置值
 939   5             ConfigValue=wValue&0xFF;
 940   5             D12SetEndpointEnable(ConfigValue);
 941   5             //返回一个0长度的状态数据包
 942   5             SendLength=0;
 943   5             NeedZeroPacket=1;
 944   5             //将数据通过EP0返回
 945   5             UsbEp0SendData();
 946   5            break;
 947   5            
 948   5            case SET_DESCRIPTOR: //设置描述符
 949   5             #ifdef DEBUG0
                      Prints("设置描述符。\r\n");
                     #endif
 952   5            break;
 953   5            
 954   5            case SET_FEATURE: //设置特性
 955   5             #ifdef DEBUG0
                      Prints("设置特性。\r\n");
                     #endif
 958   5            break;
 959   5      
 960   5            case SET_INTERFACE: //设置接口
 961   5             #ifdef DEBUG0
                      Prints("设置接口。\r\n");
                     #endif
 964   5            break;      
 965   5            
 966   5            default:  //未定义的标准请求
 967   5             #ifdef DEBUG0
                      Prints("错误：未定义的标准输出请求。\r\n");
                     #endif       
 970   5            break;
 971   5           }
 972   4          break;
 973   4          
 974   4          case 1:  //类请求
 975   4           #ifdef DEBUG0
                    Prints("USB类输出请求：");
                   #endif
 978   4           switch(bRequest)
 979   4           {
 980   5            case SET_IDLE:
 981   5             #ifdef DEBUG0
                      Prints("设置空闲。\r\n");
                     #endif
 984   5             //只需要返回一个0长度的数据包即可
 985   5             SendLength=0;
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 17  

 986   5             NeedZeroPacket=1;
 987   5             //将数据通过EP0返回
 988   5             UsbEp0SendData();
 989   5            break;
 990   5            
 991   5            default:
 992   5             #ifdef DEBUG0
                      Prints("未知请求。\r\n");
                     #endif
 995   5            break;
 996   5           }
 997   4          break;
 998   4          
 999   4          case 2:  //厂商请求
1000   4           #ifdef DEBUG0
                    Prints("USB厂商输出请求：\r\n");
                   #endif
1003   4          break;
1004   4          
1005   4          default: //未定义的请求。这里只显示一个报错信息。
1006   4           #ifdef DEBUG0
                    Prints("错误：未定义的输出请求。\r\n");
                   #endif
1009   4          break;
1010   4         }
1011   3        }
1012   2       }
1013   1       //普通数据输出
1014   1       else //if(D12ReadEndpointLastStatus(0)&0x20)之else
1015   1       {
1016   2        D12ReadEndpointBuffer(0,16,Buffer);
1017   2        D12ClearBuffer();
1018   2       }
1019   1      }
1020          ////////////////////////End of function//////////////////////////////
1021          
1022          /********************************************************************
1023          函数功能：端点0输入中断处理函数。
1024          入口参数：无。
1025          返    回：无。
1026          备    注：无。
1027          ********************************************************************/
1028          void UsbEp0In(void)
1029          {
1030   1      #ifdef DEBUG0
               Prints("USB端点0输入中断。\r\n");
              #endif
1033   1       //读最后发送状态，这将清除端点0的中断标志位
1034   1       D12ReadEndpointLastStatus(1);
1035   1       //发送剩余的字节数
1036   1       UsbEp0SendData();
1037   1      }
1038          ////////////////////////End of function//////////////////////////////
1039          
1040          /********************************************************************
1041          函数功能：端点1输出中断处理函数。
1042          入口参数：无。
1043          返    回：无。
1044          备    注：无。
1045          ********************************************************************/
1046          void UsbEp1Out(void)
1047          {
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 18  

1048   1      #ifdef DEBUG0
               Prints("USB端点1输出中断。\r\n");
              #endif
1051   1       //读端点最后状态，这将清除端点1输出的中断标志位
1052   1       D12ReadEndpointLastStatus(2);
1053   1       //清除端点缓冲区
1054   1       D12ClearBuffer();
1055   1      }
1056          ////////////////////////End of function//////////////////////////////
1057          
1058          /********************************************************************
1059          函数功能：端点1输入中断处理函数。
1060          入口参数：无。
1061          返    回：无。
1062          备    注：无。
1063          ********************************************************************/
1064          void UsbEp1In(void)
1065          {
1066   1      #ifdef DEBUG0
               Prints("USB端点1输入中断。\r\n");
              #endif
1069   1       //读最后发送状态，这将清除端点1输入的中断标志位
1070   1       D12ReadEndpointLastStatus(3);
1071   1       //端点1输入处于空闲状态
1072   1       Ep1InIsBusy=0;
1073   1      }
1074          ////////////////////////End of function//////////////////////////////
1075          
1076          /********************************************************************
1077          函数功能：端点2输出中断处理函数。
1078          入口参数：无。
1079          返    回：无。
1080          备    注：无。
1081          ********************************************************************/
1082          void UsbEp2Out(void)
1083          {
1084   1       uint8 Buf[4];
1085   1       uint8 Len;
1086   1       
1087   1      #ifdef DEBUG0
               Prints("USB端点2输出中断。\r\n");
              #endif
1090   1      /* 旧版代码，有BUG。修改在函数返回时清除中断
1091   1       //当双缓冲没有全满时，可以清除中断标志
1092   1       if((D12ReadEndpointStatus(4)&0x60)!=0x60)
1093   1       {
1094   1        //读最后发送状态，这将清除端点2输入的中断标志位
1095   1        D12ReadEndpointLastStatus(4);
1096   1       }
1097   1      */
1098   1       //读回数据
1099   1       Len=D12ReadEndpointBuffer(4,4,Buf);
1100   1       //清除端点缓冲区
1101   1       D12ClearBuffer();
1102   1       
1103   1       //可以在此增加对输出数据的处理。注意处理速度不能太慢，
1104   1       //太慢会让应用程序停止响应，甚至让操作系统崩溃。
1105   1      
1106   1       //当两个缓冲区中都没有数据时，才能清除中断标志
1107   1       if(!(D12ReadEndpointStatus(4)&0x60))
1108   1       {
1109   2        //读最后发送状态，这将清除端点2输入的中断标志位
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:40 PAGE 19  

1110   2        D12ReadEndpointLastStatus(4);
1111   2       }
1112   1      }
1113          ////////////////////////End of function//////////////////////////////
1114          
1115          /********************************************************************
1116          函数功能：端点2输入中断处理函数。
1117          入口参数：无。
1118          返    回：无。
1119          备    注：无。
1120          ********************************************************************/
1121          void UsbEp2In(void)
1122          {
1123   1      #ifdef DEBUG0
               Prints("USB端点2输入中断。\r\n");
              #endif
1126   1       //读最后发送状态，这将清除端点2输入的中断标志位
1127   1       D12ReadEndpointLastStatus(5);
1128   1       //端点2输入处于空闲状态
1129   1       Ep2InIsBusy=0;
1130   1      }
1131          ////////////////////////End of function//////////////////////////////


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    742    ----
   CONSTANT SIZE    =    267    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17       5
   IDATA SIZE       =     16    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
