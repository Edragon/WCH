C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE USBCORE
OBJECT MODULE PLACED IN UsbCore.OBJ
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE UsbCore.c BROWSE DEBUG OBJECTEXTEND TABS(1)

stmt level    source

   1          /******************************************************************
   2             本程序只供学习使用，未经作者许可，不得用于其它任何用途
   3             
   4                  欢迎访问我的USB专区：http://group.ednchina.com/93/
   5                  欢迎访问我的blog：   http://www.ednchina.com/blog/computer00
   6                                       http://computer00.21ic.org
   7          
   8                  感谢PCB赞助商――电子园： http://bbs.cepark.com/
   9          
  10          UsbCore.c file
  11          
  12          作者：电脑圈圈
  13          建立日期: 2008.06.29
  14          修改日期: 2008.07.16
  15          版本：V1.1
  16          版权所有，盗版必究。
  17          Copyright(C) 电脑圈圈 2008-2018
  18          All rights reserved            
  19          *******************************************************************/
  20          
  21          #include "config.h"
  22          #include "pdiusbd12.h"
  23          #include "uart.h"
  24          #include "usbcore.h"
  25          #include "led.h"
  26          
  27          idata uint8 Buffer[16];  //读端点0用的缓冲区
  28          
  29          //USB设备请求的各字段
  30          uint8  bmRequestType;
  31          uint8  bRequest;
  32          uint16 wValue;
  33          uint16 wIndex;
  34          uint16 wLength;
  35          //当前发送数据的位置
  36          uint8 * pSendData;
  37          //需要发送数据的长度
  38          uint16 SendLength;
  39          //是否需要发送0数据包的标志。在USB控制传输的数据过程中，
  40          //当返回的数据包字节数少于最大包长时，会认为数据过程结束。
  41          //当请求的字节数比实际需要返回的字节数长，而实际返回的字节
  42          //数又刚好是端点0大小的整数倍时，就需要返回一个0长度的数据包
  43          //来结束数据过程。因此这里增加一个标志，供程序决定是否需要返回
  44          //一个0长度的数据包。
  45          uint8 NeedZeroPacket;
  46          
  47          //当前的配置值。只有在设置非0配置后
  48          uint8 ConfigValue;
  49          
  50          //端点1缓冲是否忙的标志。当缓冲区中有数据时，该标志为真。
  51          //当缓冲区中空闲时，该标志为假。
  52          uint8 Ep1InIsBusy;
  53          
  54          //端点2缓冲是否忙的标志。当缓冲区中有数据时，该标志为真。
  55          //当缓冲区中空闲时，该标志为假。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 2   

  56          uint8 Ep2InIsBusy;
  57          
  58          //USB设备描述符的定义
  59          code uint8 DeviceDescriptor[0x12]=  //设备描述符为18字节
  60          {
  61          //bLength字段。设备描述符的长度为18(0x12)字节
  62           0x12,
  63           
  64          //bDescriptorType字段。设备描述符的编号为0x01
  65           0x01,
  66           
  67          //bcdUSB字段。这里设置版本为USB1.1，即0x0110。
  68          //由于是小端结构，所以低字节在先，即0x10，0x01。
  69           0x10,
  70           0x01,
  71           
  72          //bDeviceClass字段。我们不在设备描述符中定义设备类，
  73          //而在接口描述符中定义设备类，所以该字段的值为0。
  74           0x00,
  75           
  76          //bDeviceSubClass字段。bDeviceClass字段为0时，该字段也为0。
  77           0x00,
  78           
  79          //bDeviceProtocol字段。bDeviceClass字段为0时，该字段也为0。
  80           0x00,
  81           
  82          //bMaxPacketSize0字段。PDIUSBD12的端点0大小的16字节。
  83           0x10,
  84           
  85          //idVender字段。厂商ID号，我们这里取0x8888，仅供实验用。
  86          //实际产品不能随便使用厂商ID号，必须跟USB协会申请厂商ID号。
  87          //注意小端模式，低字节在先。
  88           0x88,
  89           0x88,
  90           
  91          //idProduct字段。产品ID号，由于是第四个实验，我们这里取0x0004。
  92          //注意小端模式，低字节应该在前。
  93           0x04,
  94           0x00,
  95           
  96          //bcdDevice字段。取1.0版，即0x0100。
  97          //小端模式，低字节在先。
  98           0x00,
  99           0x01,
 100           
 101          //iManufacturer字段。厂商字符串的索引值，为了方便记忆和管理，
 102          //字符串索引就从1开始。
 103           0x01,
 104          
 105          //iProduct字段。产品字符串的索引值。刚刚用了1，这里就取2吧。
 106          //注意字符串索引值不要使用相同的值。
 107           0x02,
 108           
 109          //iSerialNumber字段。设备的序列号字符串索引值。
 110          //这里取3就可以了。
 111           0x03,
 112          
 113          //bNumConfigurations字段。该设备所具有的配置数。
 114          //我们只需要一种配置就行了，因此该值设置为1。
 115           0x01
 116          };
 117          //////////////////////////设备描述符完毕//////////////////////////////
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 3   

 118          
 119          //USB键盘报告描述符的定义
 120          code uint8 KeyboardReportDescriptor[]=
 121          {
 122           //每行开始的第一字节为该条目的前缀，前缀的格式为：
 123           //D7~D4：bTag。D3~D2：bType；D1~D0：bSize。以下分别对每个条目注释。
 124           
 125           //这是一个全局（bType为1）条目，将用途页选择为普通桌面Generic Desktop Page(0x01)
 126           //后面跟一字节数据（bSize为1），后面的字节数就不注释了，
 127           //自己根据bSize来判断。
 128           0x05, 0x01, // USAGE_PAGE (Generic Desktop)
 129           
 130           //这是一个局部（bType为2）条目，说明接下来的集合用途用于键盘
 131           0x09, 0x06, // USAGE (Keyboard)
 132           
 133           //这是一个主条目（bType为0）条目，开集合，后面跟的数据0x01表示
 134           //该集合是一个应用集合。它的性质在前面由用途页和用途定义为
 135           //普通桌面用的键盘。
 136           0xa1, 0x01, // COLLECTION (Application)
 137           
 138           //报告ID，这里定义键盘报告的ID为1（报告ID 0是保留的）
 139           //为了减少程序的修改量，这里依然定义一个报告ID。
 140           0x85, 0x01, //Report ID (1)
 141           
 142           //这是一个全局条目，选择用途页为键盘（Keyboard/Keypad(0x07)）
 143           0x05, 0x07, //     USAGE_PAGE (Keyboard/Keypad)
 144          
 145           //这是一个局部条目，说明用途的最小值为0xe0。实际上是键盘左Ctrl键。
 146           //具体的用途值可在HID用途表中查看。
 147           0x19, 0xe0, //     USAGE_MINIMUM (Keyboard LeftControl)
 148           
 149           //这是一个局部条目，说明用途的最大值为0xe7。实际上是键盘右GUI键。
 150           0x29, 0xe7, //     USAGE_MAXIMUM (Keyboard Right GUI)
 151           
 152           //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值）
 153           //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。
 154           0x15, 0x00, //     LOGICAL_MINIMUM (0)
 155           
 156           //这是一个全局条目，说明逻辑值最大为1。
 157           0x25, 0x01, //     LOGICAL_MAXIMUM (1)
 158           
 159           //这是一个全局条目，说明数据域的数量为八个。
 160           0x95, 0x08, //     REPORT_COUNT (8)
 161           
 162           //这是一个全局条目，说明每个数据域的长度为1个bit。
 163           0x75, 0x01, //     REPORT_SIZE (1)
 164           
 165           //这是一个主条目，说明有8个长度为1bit的数据域（数量和长度
 166           //由前面的两个全局条目所定义）用来做为输入，
 167           //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示
 168           //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。
 169           //这样定义的结果就是，当某个域的值为1时，就表示对应的键按下。
 170           //bit0就对应着用途最小值0xe0，bit7对应着用途最大值0xe7。
 171           0x81, 0x02, //     INPUT (Data,Var,Abs)
 172           
 173           //这是一个全局条目，说明数据域数量为1个
 174           0x95, 0x01, //     REPORT_COUNT (1)
 175           
 176           //这是一个全局条目，说明每个数据域的长度为8bit。
 177           0x75, 0x08, //     REPORT_SIZE (8)
 178           
 179           //这是一个主条目，输入用，由前面两个全局条目可知，长度为8bit，
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 4   

 180           //数量为1个。它的属性为常量（即返回的数据一直是0）。
 181           //该字节是保留字节（保留给OEM使用）。
 182           0x81, 0x03, //     INPUT (Cnst,Var,Abs)
 183           
 184           //这是一个全局条目。定义位域数量为6个。
 185           0x95, 0x06, //   REPORT_COUNT (6)
 186           
 187           //这是一个全局条目。定义每个位域长度为8bit。
 188           //其实这里这个条目不要也是可以的，因为在前面已经有一个定义
 189           //长度为8bit的全局条目了。
 190           0x75, 0x08, //   REPORT_SIZE (8)
 191           
 192           //这是一个全局条目，定义逻辑最小值为0。
 193           //同上，这里这个全局条目也是可以不要的，因为前面已经有一个
 194           //定义逻辑最小值为0的全局条目了。
 195           0x15, 0x00, //   LOGICAL_MINIMUM (0)
 196           
 197           //这是一个全局条目，定义逻辑最大值为255。
 198           0x25, 0xFF, //   LOGICAL_MAXIMUM (255)
 199           
 200           //这是一个全局条目，选择用途页为键盘。
 201           //前面已经选择过用途页为键盘了，所以该条目不要也可以。
 202           0x05, 0x07, //   USAGE_PAGE (Keyboard/Keypad)
 203           
 204           //这是一个局部条目，定义用途最小值为0（0表示没有键按下）
 205           0x19, 0x00, //   USAGE_MINIMUM (Reserved (no event indicated))
 206           
 207           //这是一个局部条目，定义用途最大值为0x65
 208           0x29, 0x65, //   USAGE_MAXIMUM (Keyboard Application)
 209           
 210           //这是一个主条目。它说明这六个8bit的数据域是输入用的，
 211           //属性为：Data,Ary,Abs。Data说明数据是可以变的，Ary说明
 212           //这些数据域是一个数组，即每个8bit都可以表示某个键值，
 213           //如果按下的键太多（例如超过这里定义的长度或者键盘本身无法
 214           //扫描出按键情况时），则这些数据返回全1（二进制），表示按键无效。
 215           //Abs表示这些值是绝对值。
 216           0x81, 0x00, //     INPUT (Data,Ary,Abs)
 217          
 218           //以下为输出报告的描述
 219           //逻辑最小值前面已经有定义为0了，这里可以省略。 
 220           //这是一个全局条目，说明逻辑值最大为1。
 221           0x25, 0x01, //     LOGICAL_MAXIMUM (1)
 222           
 223           //这是一个全局条目，说明数据域数量为5个。 
 224           0x95, 0x05, //   REPORT_COUNT (5)
 225           
 226           //这是一个全局条目，说明数据域的长度为1bit。
 227           0x75, 0x01, //   REPORT_SIZE (1)
 228           
 229           //这是一个全局条目，说明使用的用途页为指示灯（LED）
 230           0x05, 0x08, //   USAGE_PAGE (LEDs)
 231           
 232           //这是一个局部条目，说明用途最小值为数字键盘灯。
 233           0x19, 0x01, //   USAGE_MINIMUM (Num Lock)
 234           
 235           //这是一个局部条目，说明用途最大值为Kana灯。
 236           0x29, 0x05, //   USAGE_MAXIMUM (Kana)
 237           
 238           //这是一个主条目。定义输出数据，即前面定义的5个LED。
 239           0x91, 0x02, //   OUTPUT (Data,Var,Abs)
 240           
 241           //这是一个全局条目。定义位域数量为1个。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 5   

 242           0x95, 0x01, //   REPORT_COUNT (1)
 243           
 244           //这是一个全局条目。定义位域长度为3bit。
 245           0x75, 0x03, //   REPORT_SIZE (3)
 246           
 247           //这是一个主条目，定义输出常量，前面用了5bit，所以这里需要
 248           //3个bit来凑成一字节。
 249           0x91, 0x03, //   OUTPUT (Cnst,Var,Abs)
 250           
 251           //下面这个主条目用来关闭前面的集合。bSize为0，所以后面没数据。
 252           0xc0,        // END_COLLECTION
 253          //以下注释不包括第一字节报告ID。
 254          //通过上面的报告描述符的定义，我们知道返回的输入报告具有8字节。
 255          //第一字节的8个bit用来表示特殊键是否按下（例如Shift、Alt等键）。
 256          //第二字节为保留值，值为常量0。第三到第八字节是一个普通键键值的
 257          //数组，当没有键按下时，全部6个字节值都为0。当只有一个普通键按下时，
 258          //这六个字节中的第一字节值即为该按键的键值（具体的键值请看HID的
 259          //用途表文档），当有多个普通键同时按下时，则同时返回这些键的键值。
 260          //如果按下的键太多，则这六个字节都为0xFF（不能返回0x00，这样会让
 261          //操作系统认为所有键都已经释放）。至于键值在数组中的先后顺序是
 262          //无所谓的，操作系统会负责检查是否有新键按下。我们应该在中断端点1
 263          //中按照上面的格式返回实际的键盘数据。另外，报告中还定义了一个字节
 264          //的输出报告，是用来控制LED情况的。只使用了低7位，高1位是保留值0。
 265          //当某位的值为1时，则表示对应的LED要点亮。操作系统会负责同步各个
 266          //键盘之间的LED，例如你有两块键盘，一块的数字键盘灯亮时，另一块
 267          //也会跟着亮。键盘本身不需要判断各种LED应该何时亮，它只是等待主机
 268          //发送报告给它，然后根据报告值来点亮相应的LED。我们在端点1输出中断
 269          //中读出这1字节的输出报告，然后对它取反（因为学习板上的LED是低电平时
 270          //亮），直接发送到LED上。这样main函数中按键点亮LED的代码就不需要了。
 271          };
 272          ///////////////////////////键盘报告描述符完毕////////////////////////////
 273          
 274          //USB鼠标报告描述符的定义
 275          code uint8 MouseReportDescriptor[]=
 276          {
 277           //这是一个全局（bType为1）条目，选择用途页为普通桌面Generic Desktop Page(0x01)
 278           0x05, 0x01, // USAGE_PAGE (Generic Desktop)
 279           
 280           //这是一个局部（bType为2）条目，说明接下来的应用集合用途用于鼠标
 281           0x09, 0x02, // USAGE (Mouse)
 282           
 283           //这是一个主条目（bType为0）条目，开集合，后面跟的数据0x01表示
 284           //该集合是一个应用集合。它的性质在前面由用途页和用途定义为
 285           //普通桌面用的鼠标。
 286           0xa1, 0x01, // COLLECTION (Application)
 287           
 288           //报告ID，这里定义鼠标报告的ID为1
 289           //为了减少程序修改量，这里依然保留报告ID。
 290           //事实上，该报告只有一个，所以可以不用报告ID。
 291           0x85, 0x01, //Report ID (1)
 292           
 293           //这是一个局部条目。说明用途为指针集合
 294           0x09, 0x01, //   USAGE (Pointer)
 295           
 296           //这是一个主条目，开集合，后面跟的数据0x00表示该集合是一个
 297           //物理集合，用途由前面的局部条目定义为指针集合。
 298           0xa1, 0x00, //   COLLECTION (Physical)
 299           
 300           //这是一个全局条目，选择用途页为按键（Button Page(0x09)）
 301           0x05, 0x09, //     USAGE_PAGE (Button)
 302           
 303           //这是一个局部条目，说明用途的最小值为1。实际上是鼠标左键。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 6   

 304           0x19, 0x01, //     USAGE_MINIMUM (Button 1)
 305           
 306           //这是一个局部条目，说明用途的最大值为3。实际上是鼠标中键。
 307           0x29, 0x03, //     USAGE_MAXIMUM (Button 3)
 308           
 309           //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值啦）
 310           //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。
 311           0x15, 0x00, //     LOGICAL_MINIMUM (0)
 312           
 313           //这是一个全局条目，说明逻辑值最大为1。
 314           0x25, 0x01, //     LOGICAL_MAXIMUM (1)
 315           
 316           //这是一个全局条目，说明数据域的数量为三个。
 317           0x95, 0x03, //     REPORT_COUNT (3)
 318           
 319           //这是一个全局条目，说明每个数据域的长度为1个bit。
 320           0x75, 0x01, //     REPORT_SIZE (1)
 321           
 322           //这是一个主条目，说明有3个长度为1bit的数据域（数量和长度
 323           //由前面的两个全局条目所定义）用来做为输入，
 324           //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示
 325           //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。
 326           //这样定义的结果就是，第一个数据域bit0表示按键1（左键）是否按下，
 327           //第二个数据域bit1表示按键2（右键）是否按下，第三个数据域bit2表示
 328           //按键3（中键）是否按下。
 329           0x81, 0x02, //     INPUT (Data,Var,Abs)
 330           
 331           //这是一个全局条目，说明数据域数量为1个
 332           0x95, 0x01, //     REPORT_COUNT (1)
 333           
 334           //这是一个全局条目，说明每个数据域的长度为5bit。
 335           0x75, 0x05, //     REPORT_SIZE (5)
 336           
 337           //这是一个主条目，输入用，由前面两个全局条目可知，长度为5bit，
 338           //数量为1个。它的属性为常量（即返回的数据一直是0）。
 339           //这个只是为了凑齐一个字节（前面用了3个bit）而填充的一些数据
 340           //而已，所以它是没有实际用途的。
 341           0x81, 0x03, //     INPUT (Cnst,Var,Abs)
 342           
 343           //这是一个全局条目，选择用途页为普通桌面Generic Desktop Page(0x01)
 344           0x05, 0x01, //     USAGE_PAGE (Generic Desktop)
 345           
 346           //这是一个局部条目，说明用途为X轴
 347           0x09, 0x30, //     USAGE (X)
 348           
 349           //这是一个局部条目，说明用途为Y轴
 350           0x09, 0x31, //     USAGE (Y)
 351           
 352           //这是一个局部条目，说明用途为滚轮
 353           0x09, 0x38, //     USAGE (Wheel)
 354           
 355           //下面两个为全局条目，说明返回的逻辑最小和最大值。
 356           //因为鼠标指针移动时，通常是用相对值来表示的，
 357           //相对值的意思就是，当指针移动时，只发送移动量。
 358           //往右移动时，X值为正；往下移动时，Y值为正。
 359           //对于滚轮，当滚轮往上滚时，值为正。
 360           0x15, 0x81, //     LOGICAL_MINIMUM (-127)
 361           0x25, 0x7f, //     LOGICAL_MAXIMUM (127)
 362           
 363           //这是一个全局条目，说明数据域的长度为8bit。
 364           0x75, 0x08, //     REPORT_SIZE (8)
 365           
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 7   

 366           //这是一个全局条目，说明数据域的个数为3个。
 367           0x95, 0x03, //     REPORT_COUNT (3)
 368           
 369           //这是一个主条目。它说明这三个8bit的数据域是输入用的，
 370           //属性为：Data,Var,Rel。Data说明数据是可以变的，Var说明
 371           //这些数据域是独立的，即第一个8bit表示X轴，第二个8bit表示
 372           //Y轴，第三个8bit表示滚轮。Rel表示这些值是相对值。
 373           0x81, 0x06, //     INPUT (Data,Var,Rel)
 374           
 375           //下面这两个主条目用来关闭前面的集合用。
 376           //我们开了两个集合，所以要关两次。bSize为0，所以后面没数据。
 377           0xc0,       //   END_COLLECTION
 378           0xc0        // END_COLLECTION
 379          ////以下注释不包括第一字节报告ID。
 380          //通过上面的报告描述符的定义，我们知道返回的输入报告具有4字节。
 381          //第一字节的低3位用来表示按键是否按下的，高5位为常数0，无用。
 382          //第二字节表示X轴改的变量，第三字节表示Y轴的改变量，第四字节表示
 383          //滚轮的改变量。我们在中断端点1中应该要按照上面的格式返回实际的
 384          //鼠标数据。
 385          };
 386          ///////////////////////////报告描述符完毕////////////////////////////
 387          
 388          //USB配置描述符集合的定义
 389          //配置描述符总长度为9+9+9+7+7+9+9+7字节
 390          code uint8 ConfigurationDescriptor[9+9+9+7+7+9+9+7]=
 391          {
 392           /***************配置描述符***********************/
 393           //bLength字段。配置描述符的长度为9字节。
 394           0x09,
 395           
 396           //bDescriptorType字段。配置描述符编号为0x02。
 397           0x02,
 398           
 399           //wTotalLength字段。配置描述符集合的总长度，
 400           //包括配置描述符本身、接口描述符、类描述符、端点描述符等。
 401           sizeof(ConfigurationDescriptor)&0xFF, //低字节
 402           (sizeof(ConfigurationDescriptor)>>8)&0xFF, //高字节
 403           
 404           //bNumInterfaces字段。该配置包含的接口数，有两个接口。
 405           0x02,
 406           
 407           //bConfiguration字段。该配置的值为1。
 408           0x01,
 409           
 410           //iConfigurationz字段，该配置的字符串索引。这里没有，为0。
 411           0x00,
 412           
 413           //bmAttributes字段，该设备的属性。由于我们的板子是总线供电的，
 414           //并且我们不想实现远程唤醒的功能，所以该字段的值为0x80。
 415           0x80,
 416           
 417           //bMaxPower字段，该设备需要的最大电流量。由于我们的板子
 418           //需要的电流不到100mA，因此我们这里设置为100mA。由于每单位
 419           //电流为2mA，所以这里设置为50(0x32)。
 420           0x32,
 421           
 422           /*******************第一个接口描述符*********************/
 423           //bLength字段。接口描述符的长度为9字节。
 424           0x09,
 425           
 426           //bDescriptorType字段。接口描述符的编号为0x04。
 427           0x04,
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 8   

 428           
 429           //bInterfaceNumber字段。该接口的编号，第一个接口，编号为0。
 430           0x00,
 431           
 432           //bAlternateSetting字段。该接口的备用编号，为0。
 433           0x00,
 434           
 435           //bNumEndpoints字段。非0端点的数目。由于USB键盘需要二个
 436           //中断端点（一个输入一个输出），因此该值为2。
 437           0x02,
 438           
 439           //bInterfaceClass字段。该接口所使用的类。USB键盘是HID类，
 440           //HID类的编码为0x03。
 441           0x03,
 442           
 443           //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中，
 444           //只规定了一种子类：支持BIOS引导启动的子类。
 445           //USB键盘、鼠标属于该子类，子类代码为0x01。
 446           0x01,
 447           
 448           //bInterfaceProtocol字段。如果子类为支持引导启动的子类，
 449           //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。
 450           0x01,
 451           
 452           //iConfiguration字段。该接口的字符串索引值。这里没有，为0。
 453           0x00,
 454           
 455           /******************HID描述符************************/
 456           //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。
 457           0x09,
 458           
 459           //bDescriptorType字段。HID描述符的编号为0x21。
 460           0x21,
 461           
 462           //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。
 463           0x10,
 464           0x01,
 465           
 466           //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。
 467           0x21,
 468           
 469           //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。
 470           0x01,
 471           
 472           //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。
 473           0x22,
 474           
 475           //bDescriptorLength字段。
 476           //下级描述符的长度。下级描述符为键盘报告描述符。
 477           sizeof(KeyboardReportDescriptor)&0xFF,
 478           (sizeof(KeyboardReportDescriptor)>>8)&0xFF,
 479           
 480           /**********************输入端点描述符***********************/
 481           //bLength字段。端点描述符长度为7字节。
 482           0x07,
 483           
 484           //bDescriptorType字段。端点描述符编号为0x05。
 485           0x05,
 486           
 487           //bEndpointAddress字段。端点的地址。我们使用D12的输入端点1。
 488           //D7位表示数据方向，输入端点D7为1。所以输入端点1的地址为0x81。
 489           0x81,
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 9   

 490           
 491           //bmAttributes字段。D1~D0为端点传输类型选择。
 492           //该端点为中断端点。中断端点的编号为3。其它位保留为0。
 493           0x03,
 494           
 495           //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。
 496           //注意低字节在先。
 497           0x10,
 498           0x00,
 499           
 500           //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。
 501           0x0A,
 502           
 503           /**********************输出端点描述符***********************/
 504           //bLength字段。端点描述符长度为7字节。
 505           0x07,
 506           
 507           //bDescriptorType字段。端点描述符编号为0x05。
 508           0x05,
 509           
 510           //bEndpointAddress字段。端点的地址。我们使用D12的输出端点1。
 511           //D7位表示数据方向，输出端点D7为0。所以输出端点1的地址为0x01。
 512           0x01,
 513           
 514           //bmAttributes字段。D1~D0为端点传输类型选择。
 515           //该端点为中断端点。中断端点的编号为3。其它位保留为0。
 516           0x03,
 517           
 518           //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。
 519           //注意低字节在先。
 520           0x10,
 521           0x00,
 522           
 523           //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。
 524           0x0A,
 525          
 526           /*******************第二个接口描述符*********************/
 527           //bLength字段。接口描述符的长度为9字节。
 528           0x09,
 529           
 530           //bDescriptorType字段。接口描述符的编号为0x04。
 531           0x04,
 532           
 533           //bInterfaceNumber字段。该接口的编号，第二个接口，编号为1。
 534           0x01,
 535           
 536           //bAlternateSetting字段。该接口的备用编号，为0。
 537           0x00,
 538           
 539           //bNumEndpoints字段。非0端点的数目。由于USB鼠标需要一个
 540           //中断输入端点，因此该值为1。
 541           0x01,
 542           
 543           //bInterfaceClass字段。该接口所使用的类。USB键盘是HID类，
 544           //HID类的编码为0x03。
 545           0x03,
 546           
 547           //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中，
 548           //只规定了一种子类：支持BIOS引导启动的子类。
 549           //USB键盘、鼠标属于该子类，子类代码为0x01。
 550           0x01,
 551           
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 10  

 552           //bInterfaceProtocol字段。如果子类为支持引导启动的子类，
 553           //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。
 554           0x02,
 555           
 556           //iConfiguration字段。该接口的字符串索引值。这里没有，为0。
 557           0x00,
 558           
 559           /******************HID描述符************************/
 560           //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。
 561           0x09,
 562           
 563           //bDescriptorType字段。HID描述符的编号为0x21。
 564           0x21,
 565           
 566           //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。
 567           0x10,
 568           0x01,
 569           
 570           //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。
 571           0x21,
 572           
 573           //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。
 574           0x01,
 575           
 576           //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。
 577           0x22,
 578           
 579           //bDescriptorLength字段。
 580           //下级描述符的长度。下级描述符为鼠标报告描述符。
 581           sizeof(MouseReportDescriptor)&0xFF,
 582           (sizeof(MouseReportDescriptor)>>8)&0xFF,
 583           
 584           /**********************输入端点描述符***********************/
 585           //bLength字段。端点描述符长度为7字节。
 586           0x07,
 587           
 588           //bDescriptorType字段。端点描述符编号为0x05。
 589           0x05,
 590           
 591           //bEndpointAddress字段。端点的地址。我们使用D12的输入端点2。
 592           //D7位表示数据方向，输入端点D7为1。所以输入端点2的地址为0x82。
 593           0x82,
 594           
 595           //bmAttributes字段。D1~D0为端点传输类型选择。
 596           //该端点为中断端点。中断端点的编号为3。其它位保留为0。
 597           0x03,
 598           
 599           //wMaxPacketSize字段。该端点的最大包长。端点2的最大包长为64字节。
 600           //注意低字节在先。
 601           0x40,
 602           0x00,
 603           
 604           //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。
 605           0x0A
 606          };
 607          ////////////////////////配置描述符集合完毕//////////////////////////
 608          
 609          /************************语言ID的定义********************/
 610          code uint8 LanguageId[4]=
 611          {
 612           0x04, //本描述符的长度
 613           0x03, //字符串描述符
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 11  

 614           //0x0409为美式英语的ID
 615           0x09,
 616           0x04
 617          };
 618          ////////////////////////语言ID完毕//////////////////////////////////
 619          
 620          /**************************************************/
 621          /*********        本转换结果来自         **********/
 622          /********* Http://computer00.21ic.org    **********/
 623          /*********        作者: 电脑圈圈         **********/
 624          /*********         欢迎大家使用          **********/
 625          /*********    版权所有，盗版请写明出处   **********/
 626          /**************************************************/
 627          
 628          //http://computer00.21ic.org/user1/2198/archives/2007/42769.html
 629          //字符串“电脑圈圈的USB专区 Http://group.ednchina.com/93/”的Unicode编码
 630          //8位小端格式
 631          code uint8 ManufacturerStringDescriptor[82]={
 632          82,         //该描述符的长度为82字节
 633          0x03,       //字符串描述符的类型编码为0x03
 634          0x35, 0x75, //电
 635          0x11, 0x81, //脑
 636          0x08, 0x57, //圈
 637          0x08, 0x57, //圈
 638          0x84, 0x76, //的
 639          0x55, 0x00, //U
 640          0x53, 0x00, //S
 641          0x42, 0x00, //B
 642          0x13, 0x4e, //专
 643          0x3a, 0x53, //区
 644          0x20, 0x00, // 
 645          0x48, 0x00, //H
 646          0x74, 0x00, //t
 647          0x74, 0x00, //t
 648          0x70, 0x00, //p
 649          0x3a, 0x00, //:
 650          0x2f, 0x00, ///
 651          0x2f, 0x00, ///
 652          0x67, 0x00, //g
 653          0x72, 0x00, //r
 654          0x6f, 0x00, //o
 655          0x75, 0x00, //u
 656          0x70, 0x00, //p
 657          0x2e, 0x00, //.
 658          0x65, 0x00, //e
 659          0x64, 0x00, //d
 660          0x6e, 0x00, //n
 661          0x63, 0x00, //c
 662          0x68, 0x00, //h
 663          0x69, 0x00, //i
 664          0x6e, 0x00, //n
 665          0x61, 0x00, //a
 666          0x2e, 0x00, //.
 667          0x63, 0x00, //c
 668          0x6f, 0x00, //o
 669          0x6d, 0x00, //m
 670          0x2f, 0x00, ///
 671          0x39, 0x00, //9
 672          0x33, 0x00, //3
 673          0x2f, 0x00  ///
 674          };
 675          /////////////////////////厂商字符串结束/////////////////////////////
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 12  

 676          
 677          //字符串“《圈圈教你玩USB》之带鼠标的USB键盘”的Unicode编码
 678          //8位小端格式
 679          code uint8 ProductStringDescriptor[56]={
 680          56,         //该描述符的长度为56字节
 681          0x03,       //字符串描述符的类型编码为0x03
 682          0x0a, 0x30, //《
 683          0x08, 0x57, //圈
 684          0x08, 0x57, //圈
 685          0x59, 0x65, //教
 686          0x60, 0x4f, //你
 687          0xa9, 0x73, //玩
 688          0x55, 0x00, //U
 689          0x53, 0x00, //S
 690          0x42, 0x00, //B
 691          0x0b, 0x30, //》
 692          0x4b, 0x4e, //之
 693          0x26, 0x5e, //带
 694          0x20, 0x9f, //鼠
 695          0x07, 0x68, //标
 696          0x84, 0x76, //的
 697          0x55, 0x00, //U
 698          0x53, 0x00, //S
 699          0x42, 0x00, //B
 700          0x2e, 0x95, //键
 701          0xd8, 0x76, //盘
 702          0x08, 0xff, //（
 703          0xcc, 0x53, //双
 704          0xa5, 0x63, //接
 705          0xe3, 0x53, //口
 706          0x9e, 0x5b, //实
 707          0xb0, 0x73, //现
 708          0x09, 0xff //）
 709          };
 710          ////////////////////////产品字符串结束////////////////////////////
 711          
 712          //字符串“2008-07-16”的Unicode编码
 713          //8位小端格式
 714          code uint8 SerialNumberStringDescriptor[22]={
 715          22,         //该描述符的长度为22字节
 716          0x03,       //字符串描述符的类型编码为0x03
 717          0x32, 0x00, //2
 718          0x30, 0x00, //0
 719          0x30, 0x00, //0
 720          0x38, 0x00, //8
 721          0x2d, 0x00, //-
 722          0x30, 0x00, //0
 723          0x37, 0x00, //7
 724          0x2d, 0x00, //-
 725          0x31, 0x00, //1
 726          0x36, 0x00  //6
 727          };
 728          //////////////////////产品序列号字符串结束/////////////////////////
 729          
 730          /********************************************************************
 731          函数功能：延时x毫秒函数。
 732          入口参数：x：延时的毫秒数。
 733          返    回：无。
 734          备    注：无。
 735          ********************************************************************/
 736          void DelayXms(uint16 x)                
 737          {
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 13  

 738   1       uint16 i;
 739   1       uint16 j;
 740   1       for(i=0;i<x;i++)
 741   1       for(j=0;j<227;j++); //循环语句延时
 742   1      }
 743          ////////////////////////End of function//////////////////////////////
 744          
 745          /********************************************************************
 746          函数功能：USB断开连接函数。
 747          入口参数：无。
 748          返    回：无。
 749          备    注：无。
 750          ********************************************************************/
 751          void UsbDisconnect(void)
 752          {
 753   1      #ifdef DEBUG0
 754   1       Prints("断开USB连接。\r\n");
 755   1      #endif
 756   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 757   1       D12WriteByte(0x06); //设置模式的第一字节
 758   1       D12WriteByte(0x47); //设置模式的第二字节
 759   1       DelayXms(1000);  //延迟1秒
 760   1      }
 761          ////////////////////////End of function//////////////////////////////
 762          
 763          /********************************************************************
 764          函数功能：USB连接函数。
 765          入口参数：无。
 766          返    回：无。
 767          备    注：无。
 768          ********************************************************************/
 769          void UsbConnect(void)
 770          {
 771   1      #ifdef DEBUG0
 772   1       Prints("连接USB。\r\n");
 773   1      #endif
 774   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 775   1       D12WriteByte(0x16); //设置模式的第一字节
 776   1       D12WriteByte(0x47); //设置模式的第二字节
 777   1      }
 778          ////////////////////////End of function//////////////////////////////
 779          
 780          /********************************************************************
 781          函数功能：总线挂起中断处理函数。
 782          入口参数：无。
 783          返    回：无。
 784          备    注：无。
 785          ********************************************************************/
 786          void UsbBusSuspend(void)
 787          {
 788   1      #ifdef DEBUG0
 789   1       Prints("USB总线挂起。\r\n");
 790   1      #endif
 791   1      }
 792          ////////////////////////End of function//////////////////////////////
 793          
 794          /********************************************************************
 795          函数功能：总线复位中断处理函数。
 796          入口参数：无。
 797          返    回：无。
 798          备    注：无。
 799          ********************************************************************/
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 14  

 800          void UsbBusReset(void)
 801          {
 802   1      #ifdef DEBUG0
 803   1       Prints("USB总线复位。\r\n");
 804   1      #endif
 805   1       Ep1InIsBusy=0; //复位后端点1输入缓冲区空闲。
 806   1       Ep2InIsBusy=0; //复位后端点2输入缓冲区空闲。
 807   1      }
 808          ////////////////////////End of function//////////////////////////////
 809          
 810          /********************************************************************
 811          函数功能：根据pData和SendLength将数据发送到端点0的函数。
 812          入口参数：无。
 813          返    回：无。
 814          备    注：无。
 815          ********************************************************************/
 816          void UsbEp0SendData(void)
 817          {
 818   1       //将数据写到端点中去准备发送
 819   1       //写之前要先判断一下需要发送的数据是否比端点0
 820   1       //最大长度大，如果超过端点大小，则一次只能发送
 821   1       //最大包长的数据。端点0的最大包长在DeviceDescriptor[7]
 822   1       if(SendLength>DeviceDescriptor[7])
 823   1       {
 824   2        //按最大包长度发送
 825   2        D12WriteEndpointBuffer(1,DeviceDescriptor[7],pSendData);
 826   2        //发送后剩余字节数减少最大包长
 827   2        SendLength-=DeviceDescriptor[7];
 828   2        //发送一次后指针位置要调整
 829   2        pSendData+= DeviceDescriptor[7];
 830   2       }
 831   1       else
 832   1       {
 833   2        if(SendLength!=0)
 834   2        {
 835   3         //不够最大包长，可以直接发送
 836   3         D12WriteEndpointBuffer(1,SendLength,pSendData);
 837   3         //发送完毕后，SendLength长度变为0
 838   3         SendLength=0;
 839   3        }
 840   2        else //如果要发送的数据包长度为0
 841   2        {
 842   3         if(NeedZeroPacket==1) //如果需要发送0长度数据
 843   3         {
 844   4          D12WriteEndpointBuffer(1,0,pSendData); //发送0长度数据包
 845   4          NeedZeroPacket=0; //清需要发送0长度数据包标志
 846   4         }
 847   3        }
 848   2       }
 849   1      }
 850          ////////////////////////End of function//////////////////////////////
 851          
 852          /********************************************************************
 853          函数功能：端点0输出中断处理函数。
 854          入口参数：无。
 855          返    回：无。
 856          备    注：无。
 857          ********************************************************************/
 858          void UsbEp0Out(void)
 859          {
 860   1      #ifdef DEBUG0
 861   1       Prints("USB端点0输出中断。\r\n");
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 15  

 862   1      #endif
 863   1       //读取端点0输出最后传输状态，该操作清除中断标志
 864   1       //并判断第5位是否为1，如果是，则说明是建立包
 865   1       if(D12ReadEndpointLastStatus(0)&0x20)
 866   1       {
 867   2        D12ReadEndpointBuffer(0,16,Buffer); //读建立过程数据
 868   2        D12AcknowledgeSetup(); //应答建立包
 869   2        D12ClearBuffer(); //清缓冲区
 870   2        //将缓冲数据填到设备请求的各字段中
 871   2        bmRequestType=Buffer[0];
 872   2        bRequest=Buffer[1];
 873   2        wValue=Buffer[2]+(((uint16)Buffer[3])<<8);
 874   2        wIndex=Buffer[4]+(((uint16)Buffer[5])<<8);
 875   2        wLength=Buffer[6]+(((uint16)Buffer[7])<<8);
 876   2        //下面的代码判断具体的请求，并根据不同的请求进行相关操作
 877   2        //如果D7位为1，则说明是输入请求
 878   2        if((bmRequestType&0x80)==0x80)
 879   2        {
 880   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 881   3         //0为标准请求，1为类请求，2为厂商请求。
 882   3         switch((bmRequestType>>5)&0x03)
 883   3         {
 884   4          case 0:  //标准请求
 885   4           #ifdef DEBUG0
 886   4            Prints("USB标准输入请求：");
 887   4           #endif
 888   4           //USB协议定义了几个标准输入请求，我们实现这些标准请求即可
 889   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 890   4           //事实上，我们还需要对接收者进行散转，因为不同的请求接收者
 891   4           //是不一样的。接收者在bmRequestType的D4~D0位中定义。
 892   4           //我们这里为了简化操作，有些就省略了对接收者的判断。
 893   4           //例如获取描述符的请求，只根据描述符的类型来区别。
 894   4           switch(bRequest)
 895   4           {
 896   5            case GET_CONFIGURATION: //获取配置
 897   5             #ifdef DEBUG0
 898   5              Prints("获取配置。\r\n");
 899   5             #endif
 900   5            break;
 901   5            
 902   5            case GET_DESCRIPTOR:  //获取描述符
 903   5             #ifdef DEBUG0
 904   5              Prints("获取描述符――");
 905   5             #endif
 906   5             //对描述符类型进行散转，对于全速设备，
 907   5             //标准请求只支持发送到设备的设备、配置、字符串三种描述符
 908   5             switch((wValue>>8)&0xFF)
 909   5              {
 910   6               case DEVICE_DESCRIPTOR: //设备描述符
 911   6                #ifdef DEBUG0
 912   6                 Prints("设备描述符。\r\n");
 913   6                #endif
 914   6                pSendData=DeviceDescriptor;  //需要发送的数据
 915   6                //判断请求的字节数是否比实际需要发送的字节数多
 916   6                //这里请求的是设备描述符，因此数据长度就是
 917   6                //DeviceDescriptor[0]。如果请求的比实际的长，
 918   6                //那么只返回实际长度的数据
 919   6                if(wLength>DeviceDescriptor[0])
 920   6                {
 921   7                 SendLength=DeviceDescriptor[0];
 922   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 923   7                 {
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 16  

 924   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 925   8                 }
 926   7                }
 927   6                else
 928   6                {
 929   7                 SendLength=wLength;
 930   7                }
 931   6                //将数据通过EP0返回
 932   6                UsbEp0SendData();
 933   6               break;
 934   6               
 935   6               case CONFIGURATION_DESCRIPTOR:  //配置描述符
 936   6                #ifdef DEBUG0
 937   6                 Prints("配置描述符。\r\n");
 938   6                #endif
 939   6                pSendData=ConfigurationDescriptor; //需要发送的数据为配置描述符
 940   6                //判断请求的字节数是否比实际需要发送的字节数多
 941   6                //这里请求的是配置描述符集合，因此数据长度就是
 942   6                //ConfigurationDescriptor[3]*256+ConfigurationDescriptor[2]。
 943   6                //如果请求的比实际的长，那么只返回实际长度的数据
 944   6                SendLength=ConfigurationDescriptor[3];
 945   6                SendLength=SendLength*256+ConfigurationDescriptor[2];
 946   6                if(wLength>SendLength)
 947   6                {
 948   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 949   7                 {
 950   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 951   8                 }
 952   7                }
 953   6                else
 954   6                {
 955   7                 SendLength=wLength;
 956   7                }
 957   6                //将数据通过EP0返回
 958   6                UsbEp0SendData();
 959   6               break;
 960   6               
 961   6               case STRING_DESCRIPTOR:  //字符串描述符
 962   6                #ifdef DEBUG0
 963   6                 Prints("字符串描述符");
 964   6                #endif
 965   6                switch(wValue&0xFF)  //根据wValue的低字节（索引值）散转
 966   6                {
 967   7                 case 0:  //获取语言ID
 968   7                  #ifdef DEBUG0
 969   7                   Prints("(语言ID)。\r\n");
 970   7                  #endif
 971   7                  pSendData=LanguageId;
 972   7                  SendLength=LanguageId[0];
 973   7                 break;
 974   7                 
 975   7                 case 1:  //厂商字符串的索引值为1，所以这里为厂商字符串
 976   7                 #ifdef DEBUG0
 977   7                   Prints("(厂商描述)。\r\n");
 978   7                  #endif
 979   7                  pSendData=ManufacturerStringDescriptor;
 980   7                  SendLength=ManufacturerStringDescriptor[0];
 981   7                 break;
 982   7                 
 983   7                 case 2:  //产品字符串的索引值为2，所以这里为产品字符串
 984   7                 #ifdef DEBUG0
 985   7                   Prints("(产品描述)。\r\n");
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 17  

 986   7                  #endif
 987   7                  pSendData=ProductStringDescriptor;
 988   7                  SendLength=ProductStringDescriptor[0];
 989   7                 break;
 990   7                 
 991   7                 case 3:  //产品序列号的索引值为3，所以这里为序列号
 992   7                 #ifdef DEBUG0
 993   7                   Prints("(产品序列号)。\r\n");
 994   7                  #endif
 995   7                  pSendData=SerialNumberStringDescriptor;
 996   7                  SendLength=SerialNumberStringDescriptor[0];
 997   7                 break;
 998   7                 
 999   7                 default :
1000   7                  #ifdef DEBUG0
1001   7                   Prints("(未知的索引值)。\r\n");
1002   7                  #endif
1003   7                  //对于未知索引值的请求，返回一个0长度的包
1004   7                  SendLength=0;
1005   7                  NeedZeroPacket=1;
1006   7                 break;
1007   7                }
1008   6                //判断请求的字节数是否比实际需要发送的字节数多
1009   6                //如果请求的比实际的长，那么只返回实际长度的数据
1010   6                if(wLength>SendLength)
1011   6                {
1012   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
1013   7                 {
1014   8                  NeedZeroPacket=1; //需要返回0长度的数据包
1015   8                 }
1016   7                }
1017   6                else
1018   6                {
1019   7                 SendLength=wLength;
1020   7                }
1021   6                //将数据通过EP0返回
1022   6                UsbEp0SendData();         
1023   6               break;
1024   6      
1025   6               case REPORT_DESCRIPTOR:  //报告描述符
1026   6                #ifdef DEBUG0
1027   6                 Prints("报告描述符。\r\n");
1028   6                #endif
1029   6                //获取报告描述符时，wIndex中保存的是请求的接口号。
1030   6                //我们这里有两个接口，接口0用来实现键盘，接口1实现鼠标。
1031   6                switch(wIndex)
1032   6                {
1033   7                 case 0:    //发送到接口0的请求
1034   7                  pSendData=KeyboardReportDescriptor; //需要发送的数据为报告描述符
1035   7                  SendLength=sizeof(KeyboardReportDescriptor); //需要返回的数据长度
1036   7                 break;
1037   7                 
1038   7                 case 1:    //发送到接口1的请求
1039   7                  pSendData=MouseReportDescriptor; //需要发送的数据为报告描述符
1040   7                  SendLength=sizeof(MouseReportDescriptor); //需要返回的数据长度
1041   7                 break;
1042   7                 
1043   7                 default : //其它为未定义的接口，返回0长度数据包
1044   7                  SendLength=0;
1045   7                  NeedZeroPacket=1;
1046   7                 break;
1047   7                }
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 18  

1048   6                //判断请求的字节数是否比实际需要发送的字节数多
1049   6                //如果请求的比实际的长，那么只返回实际长度的数据
1050   6                if(wLength>SendLength)
1051   6                {
1052   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
1053   7                 {
1054   8                  NeedZeroPacket=1; //需要返回0长度的数据包
1055   8                 }
1056   7                }
1057   6                else
1058   6                {
1059   7                 SendLength=wLength;
1060   7                }
1061   6                //将数据通过EP0返回
1062   6                UsbEp0SendData();
1063   6               break;
1064   6                       
1065   6               default:  //其它描述符
1066   6                #ifdef DEBUG0
1067   6                 Prints("其他描述符，描述符代码：");
1068   6                 PrintHex((wValue>>8)&0xFF);
1069   6                 Prints("\r\n");
1070   6                #endif
1071   6               break;
1072   6              }
1073   5             break;
1074   5            
1075   5            case GET_INTERFACE: //获取接口
1076   5             #ifdef DEBUG0
1077   5              Prints("获取接口。\r\n");
1078   5             #endif
1079   5            break;
1080   5            
1081   5            case GET_STATUS: //获取状态
1082   5             #ifdef DEBUG0
1083   5              Prints("获取状态。\r\n");
1084   5             #endif
1085   5            break;
1086   5            
1087   5            case SYNCH_FRAME: //同步帧
1088   5             #ifdef DEBUG0
1089   5              Prints("同步帧。\r\n");
1090   5             #endif
1091   5            break;
1092   5            
1093   5            default:  //未定义的标准请求
1094   5             #ifdef DEBUG0
1095   5              Prints("错误：未定义的标准输入请求。\r\n");
1096   5             #endif       
1097   5            break;
1098   5           }
1099   4          break;
1100   4          
1101   4          case 1:  //类请求
1102   4           #ifdef DEBUG0
1103   4            Prints("USB类输入请求：\r\n");
1104   4           #endif
1105   4          break;
1106   4          
1107   4          case 2:  //厂商请求
1108   4           #ifdef DEBUG0
1109   4            Prints("USB厂商输入请求：\r\n");
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 19  

1110   4           #endif
1111   4          break;
1112   4          
1113   4          default: //未定义的请求。这里只显示一个报错信息。
1114   4           #ifdef DEBUG0
1115   4            Prints("错误：未定义的输入请求。\r\n");
1116   4           #endif
1117   4          break;
1118   4         }
1119   3        }
1120   2        //否则说明是输出请求
1121   2        else //if(bmRequestType&0x80==0x80)之else
1122   2        {
1123   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
1124   3         //0为标准请求，1为类请求，2为厂商请求。
1125   3         switch((bmRequestType>>5)&0x03)
1126   3         {
1127   4          case 0:  //标准请求
1128   4           #ifdef DEBUG0
1129   4            Prints("USB标准输出请求：");
1130   4           #endif
1131   4           //USB协议定义了几个标准输出请求，我们实现这些标准请求即可
1132   4           //请求的代码在bRequest中，对不同的请求代码进行散转
1133   4           switch(bRequest)
1134   4           {
1135   5            case CLEAR_FEATURE: //清除特性
1136   5             #ifdef DEBUG0
1137   5              Prints("清除特性。\r\n");
1138   5             #endif
1139   5            break;
1140   5            
1141   5            case SET_ADDRESS:  //设置地址
1142   5             #ifdef DEBUG0
1143   5              Prints("设置地址。地址为：");
1144   5              PrintHex(wValue&0xFF); //显示所设置的地址
1145   5              Prints("\r\n");
1146   5             #endif
1147   5             D12SetAddress(wValue&0xFF); //wValue中的低字节是设置的地址值
1148   5             //设置地址没有数据过程，直接进入到状态过程，返回一个0长度的数据包
1149   5             SendLength=0;
1150   5             NeedZeroPacket=1;
1151   5             //将数据通过EP0返回
1152   5             UsbEp0SendData();
1153   5            break;
1154   5            
1155   5            case SET_CONFIGURATION: //设置配置
1156   5             #ifdef DEBUG0
1157   5              Prints("设置配置。\r\n");
1158   5             #endif
1159   5             //使能非0端点。非0端点只有在设置为非0的配置后才能使能。
1160   5             //wValue的低字节为配置的值，如果该值为非0，才能使能非0端点。
1161   5             //保存当前配置值
1162   5             ConfigValue=wValue&0xFF;
1163   5             D12SetEndpointEnable(ConfigValue);
1164   5             //返回一个0长度的状态数据包
1165   5             SendLength=0;
1166   5             NeedZeroPacket=1;
1167   5             //将数据通过EP0返回
1168   5             UsbEp0SendData();
1169   5            break;
1170   5            
1171   5            case SET_DESCRIPTOR: //设置描述符
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 20  

1172   5             #ifdef DEBUG0
1173   5              Prints("设置描述符。\r\n");
1174   5             #endif
1175   5            break;
1176   5            
1177   5            case SET_FEATURE: //设置特性
1178   5             #ifdef DEBUG0
1179   5              Prints("设置特性。\r\n");
1180   5             #endif
1181   5            break;
1182   5      
1183   5            case SET_INTERFACE: //设置接口
1184   5             #ifdef DEBUG0
1185   5              Prints("设置接口。\r\n");
1186   5             #endif
1187   5            break;      
1188   5            
1189   5            default:  //未定义的标准请求
1190   5             #ifdef DEBUG0
1191   5              Prints("错误：未定义的标准输出请求。\r\n");
1192   5             #endif       
1193   5            break;
1194   5           }
1195   4          break;
1196   4          
1197   4          case 1:  //类请求
1198   4           #ifdef DEBUG0
1199   4            Prints("USB类输出请求：");
1200   4           #endif
1201   4           switch(bRequest)
1202   4           {
1203   5            case SET_IDLE:
1204   5             #ifdef DEBUG0
1205   5              Prints("设置空闲。\r\n");
1206   5             #endif
1207   5             //只需要返回一个0长度的数据包即可
1208   5             SendLength=0;
1209   5             NeedZeroPacket=1;
1210   5             //将数据通过EP0返回
1211   5             UsbEp0SendData();
1212   5            break;
1213   5            
1214   5            default:
1215   5             #ifdef DEBUG0
1216   5              Prints("未知请求。\r\n");
1217   5             #endif
1218   5            break;
1219   5           }
1220   4          break;
1221   4          
1222   4          case 2:  //厂商请求
1223   4           #ifdef DEBUG0
1224   4            Prints("USB厂商输出请求：\r\n");
1225   4           #endif
1226   4          break;
1227   4          
1228   4          default: //未定义的请求。这里只显示一个报错信息。
1229   4           #ifdef DEBUG0
1230   4            Prints("错误：未定义的输出请求。\r\n");
1231   4           #endif
1232   4          break;
1233   4         }
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 21  

1234   3        }
1235   2       }
1236   1       //普通数据输出
1237   1       else //if(D12ReadEndpointLastStatus(0)&0x20)之else
1238   1       {
1239   2        D12ReadEndpointBuffer(0,16,Buffer);
1240   2        D12ClearBuffer();
1241   2       }
1242   1      }
1243          ////////////////////////End of function//////////////////////////////
1244          
1245          /********************************************************************
1246          函数功能：端点0输入中断处理函数。
1247          入口参数：无。
1248          返    回：无。
1249          备    注：无。
1250          ********************************************************************/
1251          void UsbEp0In(void)
1252          {
1253   1      #ifdef DEBUG0
1254   1       Prints("USB端点0输入中断。\r\n");
1255   1      #endif
1256   1       //读最后发送状态，这将清除端点0的中断标志位
1257   1       D12ReadEndpointLastStatus(1);
1258   1       //发送剩余的字节数
1259   1       UsbEp0SendData();
1260   1      }
1261          ////////////////////////End of function//////////////////////////////
1262          
1263          /********************************************************************
1264          函数功能：端点1输出中断处理函数。
1265          入口参数：无。
1266          返    回：无。
1267          备    注：无。
1268          ********************************************************************/
1269          void UsbEp1Out(void)
1270          {
1271   1       uint8 Buf[2]; //用来保存2字节的输出报告，控制LED。
1272   1      #ifdef DEBUG0
1273   1       Prints("USB端点1输出中断。\r\n");
1274   1      #endif
1275   1       //读端点最后状态，这将清除端点1输出的中断标志位
1276   1       D12ReadEndpointLastStatus(2);
1277   1       //从端点1输出缓冲读回2字节数据
1278   1       D12ReadEndpointBuffer(2,2,Buf);
1279   1       //清除端点缓冲区
1280   1       D12ClearBuffer();
1281   1       //注意输出报告也增加了一字节的报告ID。
1282   1       //第1字节为报告ID，第2字节为LED状态，某位为1时，表示LED亮。
1283   1       //我们定义的键盘的报告ID为1，所以这里判断一下报告ID是否为1。
1284   1       if(Buf[0]==0x01)  //报告ID为1，即键盘的输出报告
1285   1       {
1286   2        LEDs=~Buf[1];
1287   2       }
1288   1      }
1289          ////////////////////////End of function//////////////////////////////
1290          
1291          /********************************************************************
1292          函数功能：端点1输入中断处理函数。
1293          入口参数：无。
1294          返    回：无。
1295          备    注：无。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:36 PAGE 22  

1296          ********************************************************************/
1297          void UsbEp1In(void)
1298          {
1299   1      #ifdef DEBUG0
1300   1       Prints("USB端点1输入中断。\r\n");
1301   1      #endif
1302   1       //读最后发送状态，这将清除端点1输入的中断标志位
1303   1       D12ReadEndpointLastStatus(3);
1304   1       //端点1输入处于空闲状态
1305   1       Ep1InIsBusy=0;
1306   1      }
1307          ////////////////////////End of function//////////////////////////////
1308          
1309          /********************************************************************
1310          函数功能：端点2输出中断处理函数。
1311          入口参数：无。
1312          返    回：无。
1313          备    注：无。
1314          ********************************************************************/
1315          void UsbEp2Out(void)
1316          {
1317   1      #ifdef DEBUG0
1318   1       Prints("USB端点2输出中断。\r\n");
1319   1      #endif
1320   1      }
1321          ////////////////////////End of function//////////////////////////////
1322          
1323          /********************************************************************
1324          函数功能：端点2输入中断处理函数。
1325          入口参数：无。
1326          返    回：无。
1327          备    注：无。
1328          ********************************************************************/
1329          void UsbEp2In(void)
1330          {
1331   1      #ifdef DEBUG0
1332   1       Prints("USB端点2输入中断。\r\n");
1333   1      #endif
1334   1       //读最后发送状态，这将清除端点2输入的中断标志位
1335   1       D12ReadEndpointLastStatus(5);
1336   1       //端点2输入处于空闲状态
1337   1       Ep2InIsBusy=0;
1338   1      }
1339          ////////////////////////End of function//////////////////////////////


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1315    ----
   CONSTANT SIZE    =   1123    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17       2
   IDATA SIZE       =     16    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
