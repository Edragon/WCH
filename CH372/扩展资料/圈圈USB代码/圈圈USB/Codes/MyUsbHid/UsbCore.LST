C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE USBCORE
OBJECT MODULE PLACED IN UsbCore.OBJ
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE UsbCore.c BROWSE DEBUG OBJECTEXTEND TABS(1)

stmt level    source

   1          /******************************************************************
   2             本程序只供学习使用，未经作者许可，不得用于其它任何用途
   3             
   4                  欢迎访问我的USB专区：http://group.ednchina.com/93/
   5                  欢迎访问我的blog：   http://www.ednchina.com/blog/computer00
   6                                       http://computer00.21ic.org
   7          
   8                  感谢PCB赞助商――电子园： http://bbs.cepark.com/
   9          
  10          UsbCore.c file
  11          
  12          作者：电脑圈圈
  13          建立日期: 2008.06.29
  14          修改日期: 2008.07.14
  15          版本：V1.1
  16          版权所有，盗版必究。
  17          Copyright(C) 电脑圈圈 2008-2018
  18          All rights reserved            
  19          *******************************************************************/
  20          
  21          #include "config.h"
  22          #include "pdiusbd12.h"
  23          #include "uart.h"
  24          #include "usbcore.h"
  25          #include "led.h"
  26          
  27          idata uint8 Buffer[16];  //读端点0用的缓冲区
  28          
  29          //USB设备请求的各字段
  30          uint8  bmRequestType;
  31          uint8  bRequest;
  32          uint16 wValue;
  33          uint16 wIndex;
  34          uint16 wLength;
  35          //当前发送数据的位置
  36          uint8 * pSendData;
  37          //需要发送数据的长度
  38          uint16 SendLength;
  39          //是否需要发送0数据包的标志。在USB控制传输的数据过程中，
  40          //当返回的数据包字节数少于最大包长时，会认为数据过程结束。
  41          //当请求的字节数比实际需要返回的字节数长，而实际返回的字节
  42          //数又刚好是端点0大小的整数倍时，就需要返回一个0长度的数据包
  43          //来结束数据过程。因此这里增加一个标志，供程序决定是否需要返回
  44          //一个0长度的数据包。
  45          uint8 NeedZeroPacket;
  46          
  47          //当前的配置值。只有在设置非0配置后
  48          uint8 ConfigValue;
  49          
  50          //端点1缓冲是否忙的标志。当缓冲区中有数据时，该标志为真。
  51          //当缓冲区中空闲时，该标志为假。
  52          uint8 Ep1InIsBusy;
  53          
  54          //返回了多少次报告的计数器
  55          uint32 Count=0;
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 2   

  56          
  57          //USB设备描述符的定义
  58          code uint8 DeviceDescriptor[0x12]=  //设备描述符为18字节
  59          {
  60          //bLength字段。设备描述符的长度为18(0x12)字节
  61           0x12,
  62           
  63          //bDescriptorType字段。设备描述符的编号为0x01
  64           0x01,
  65           
  66          //bcdUSB字段。这里设置版本为USB1.1，即0x0110。
  67          //由于是小端结构，所以低字节在先，即0x10，0x01。
  68           0x10,
  69           0x01,
  70           
  71          //bDeviceClass字段。我们不在设备描述符中定义设备类，
  72          //而在接口描述符中定义设备类，所以该字段的值为0。
  73           0x00,
  74           
  75          //bDeviceSubClass字段。bDeviceClass字段为0时，该字段也为0。
  76           0x00,
  77           
  78          //bDeviceProtocol字段。bDeviceClass字段为0时，该字段也为0。
  79           0x00,
  80           
  81          //bMaxPacketSize0字段。PDIUSBD12的端点0大小的16字节。
  82           0x10,
  83           
  84          //idVender字段。厂商ID号，我们这里取0x8888，仅供实验用。
  85          //实际产品不能随便使用厂商ID号，必须跟USB协会申请厂商ID号。
  86          //注意小端模式，低字节在先。
  87           0x88,
  88           0x88,
  89           
  90          //idProduct字段。产品ID号，由于是第六个实验，我们这里取0x0006。
  91          //注意小端模式，低字节应该在前。
  92           0x06,
  93           0x00,
  94           
  95          //bcdDevice字段。设备版本号，取1.0版，即0x0100。
  96          //小端模式，低字节在先。
  97           0x00,
  98           0x01,
  99           
 100          //iManufacturer字段。厂商字符串的索引值，为了方便记忆和管理，
 101          //字符串索引就从1开始吧。
 102           0x01,
 103          
 104          //iProduct字段。产品字符串的索引值。刚刚用了1，这里就取2吧。
 105          //注意字符串索引值不要使用相同的值。
 106           0x02,
 107           
 108          //iSerialNumber字段。设备的序列号字符串索引值。
 109          //这里取3就可以了。
 110           0x03,
 111          
 112          //bNumConfigurations字段。该设备所具有的配置数。
 113          //我们只需要一种配置就行了，因此该值设置为1。
 114           0x01
 115          };
 116          //////////////////////////设备描述符完毕//////////////////////////////
 117          
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 3   

 118          //USB报告描述符的定义
 119          code uint8 ReportDescriptor[]=
 120          {
 121           //每行开始的第一字节为该条目的前缀，前缀的格式为：
 122           //D7~D4：bTag。D3~D2：bType；D1~D0：bSize。以下分别对每个条目注释。
 123           
 124           //这是一个全局（bType为1）条目，将用途页选择为普通桌面Generic Desktop Page。
 125           //后面跟1字节数据（bSize为1），后面的字节数就不注释了，自己根据bSize来判断。
 126           0x05, 0x01, // USAGE_PAGE (Generic Desktop)
 127           
 128           //这是一个局部（bType为2）条目，用途选择为0x00。在普通桌面页中，
 129           //该用途是未定义的，如果使用该用途来开集合，那么系统将不会把它
 130           //当作标准系统设备，从而就成了一个用户自定义的HID设备。
 131           0x09, 0x00, // USAGE (0)
 132           
 133           //这是一个主条目（bType为0）条目，开集合，后面跟的数据0x01表示
 134           //该集合是一个应用集合。它的性质在前面由用途页和用途定义为
 135           //用户自定义。
 136           0xa1, 0x01, // COLLECTION (Application)
 137          
 138           //这是一个全局条目，说明逻辑值最小值为0。
 139           0x15, 0x00, //     LOGICAL_MINIMUM (0)
 140           
 141           //这是一个全局条目，说明逻辑值最大为255。
 142           0x25, 0xff, //     LOGICAL_MAXIMUM (255)
 143           
 144           //这是一个局部条目，说明用途的最小值为1。
 145           0x19, 0x01, //     USAGE_MINIMUM (1)
 146           
 147           //这是一个局部条目，说明用途的最大值8。
 148           0x29, 0x08, //     USAGE_MAXIMUM (8) 
 149           
 150           //这是一个全局条目，说明数据域的数量为八个。
 151           0x95, 0x08, //     REPORT_COUNT (8)
 152           
 153           //这是一个全局条目，说明每个数据域的长度为8bit，即1字节。
 154           0x75, 0x08, //     REPORT_SIZE (8)
 155           
 156           //这是一个主条目，说明有8个长度为8bit的数据域做为输入。
 157           0x81, 0x02, //     INPUT (Data,Var,Abs)
 158           
 159           //这是一个局部条目，说明用途的最小值为1。
 160           0x19, 0x01, //     USAGE_MINIMUM (1)
 161           
 162           //这是一个局部条目，说明用途的最大值8。
 163           0x29, 0x08, //     USAGE_MAXIMUM (8) 
 164           
 165           //这是一个主条目。定义输出数据（8字节，注意前面的全局条目）。
 166           0x91, 0x02, //   OUTPUT (Data,Var,Abs)
 167           
 168           //下面这个主条目用来关闭前面的集合。bSize为0，所以后面没数据。
 169           0xc0        // END_COLLECTION
 170          };
 171          //通过上面的报告描述符的定义，我们知道返回的输入报告具有8字节。
 172          //输出报告也有8字节。至于这8字节的数据是干什么用的，就要由用户
 173          //自己来决定了。像我们这个实验，输入报告的第一字节用来描述8个按键
 174          //的状态，第二到第五字节返回返回报告的次数（增加一个长整型的变量Count，
 175          //每发送一次报告就加1）。而输出报告的第一字节则用来控制板上8个LED
 176          //的状态，第二字节（非0时）用来清除上面的报告计数器Count。
 177          ///////////////////////////报告描述符完毕////////////////////////////
 178          
 179          //USB配置描述符集合的定义
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 4   

 180          //配置描述符总长度为9+9+9+7+7字节
 181          code uint8 ConfigurationDescriptor[9+9+9+7+7]=
 182          {
 183           /***************配置描述符***********************/
 184           //bLength字段。配置描述符的长度为9字节。
 185           0x09,
 186           
 187           //bDescriptorType字段。配置描述符编号为0x02。
 188           0x02,
 189           
 190           //wTotalLength字段。配置描述符集合的总长度，
 191           //包括配置描述符本身、接口描述符、类描述符、端点描述符等。
 192           sizeof(ConfigurationDescriptor)&0xFF, //低字节
 193           (sizeof(ConfigurationDescriptor)>>8)&0xFF, //高字节
 194           
 195           //bNumInterfaces字段。该配置包含的接口数，只有一个接口。
 196           0x01,
 197           
 198           //bConfiguration字段。该配置的值为1。
 199           0x01,
 200           
 201           //iConfigurationz字段，该配置的字符串索引。这里没有，为0。
 202           0x00,
 203           
 204           //bmAttributes字段，该设备的属性。由于我们的板子是总线供电的，
 205           //并且我们不想实现远程唤醒的功能，所以该字段的值为0x80。
 206           0x80,
 207           
 208           //bMaxPower字段，该设备需要的最大电流量。由于我们的板子
 209           //需要的电流不到100mA，因此我们这里设置为100mA。由于每单位
 210           //电流为2mA，所以这里设置为50(0x32)。
 211           0x32,
 212           
 213           /*******************接口描述符*********************/
 214           //bLength字段。接口描述符的长度为9字节。
 215           0x09,
 216           
 217           //bDescriptorType字段。接口描述符的编号为0x04。
 218           0x04,
 219           
 220           //bInterfaceNumber字段。该接口的编号，第一个接口，编号为0。
 221           0x00,
 222           
 223           //bAlternateSetting字段。该接口的备用编号，为0。
 224           0x00,
 225           
 226           //bNumEndpoints字段。非0端点的数目。本实例需要二个
 227           //中断端点（一个输入一个输出），因此该值为2。
 228           0x02,
 229           
 230           //bInterfaceClass字段。该接口所使用的类。本实例是HID类，
 231           //HID类的编码为0x03。
 232           0x03,
 233           
 234           //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中，
 235           //只规定了一种子类：支持BIOS引导启动的子类。
 236           //USB键盘、鼠标属于该子类，子类代码为0x01。
 237           //但这里我们是自定义的HID设备，所以不使用子类。
 238           0x00,
 239           
 240           //bInterfaceProtocol字段。如果子类为支持引导启动的子类，
 241           //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 5   

 242           //自定义的HID设备，也不使用协议。
 243           0x00,
 244           
 245           //iConfiguration字段。该接口的字符串索引值。这里没有，为0。
 246           0x00,
 247           
 248           /******************HID描述符************************/
 249           //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。
 250           0x09,
 251           
 252           //bDescriptorType字段。HID描述符的编号为0x21。
 253           0x21,
 254           
 255           //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。
 256           0x10,
 257           0x01,
 258           
 259           //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。
 260           0x21,
 261           
 262           //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。
 263           0x01,
 264           
 265           //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。
 266           0x22,
 267           
 268           //bDescriptorLength字段。下级描述符的长度。下级描述符为报告描述符。
 269           sizeof(ReportDescriptor)&0xFF,
 270           (sizeof(ReportDescriptor)>>8)&0xFF,
 271           
 272           /**********************输入端点描述符***********************/
 273           //bLength字段。端点描述符长度为7字节。
 274           0x07,
 275           
 276           //bDescriptorType字段。端点描述符编号为0x05。
 277           0x05,
 278           
 279           //bEndpointAddress字段。端点的地址。我们使用D12的输入端点1。
 280           //D7位表示数据方向，输入端点D7为1。所以输入端点1的地址为0x81。
 281           0x81,
 282           
 283           //bmAttributes字段。D1~D0为端点传输类型选择。
 284           //该端点为中断端点。中断端点的编号为3。其它位保留为0。
 285           0x03,
 286           
 287           //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。
 288           //注意低字节在先。
 289           0x10,
 290           0x00,
 291           
 292           //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。
 293           0x0A,
 294           
 295           /**********************输出端点描述符***********************/
 296           //bLength字段。端点描述符长度为7字节。
 297           0x07,
 298           
 299           //bDescriptorType字段。端点描述符编号为0x05。
 300           0x05,
 301           
 302           //bEndpointAddress字段。端点的地址。我们使用D12的输出端点1。
 303           //D7位表示数据方向，输出端点D7为0。所以输出端点1的地址为0x01。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 6   

 304           0x01,
 305           
 306           //bmAttributes字段。D1~D0为端点传输类型选择。
 307           //该端点为中断端点。中断端点的编号为3。其它位保留为0。
 308           0x03,
 309           
 310           //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。
 311           //注意低字节在先。
 312           0x10,
 313           0x00,
 314           
 315           //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。
 316           0x0A
 317          };
 318          ////////////////////////配置描述符集合完毕//////////////////////////
 319          
 320          /************************语言ID的定义********************/
 321          code uint8 LanguageId[4]=
 322          {
 323           0x04, //本描述符的长度
 324           0x03, //字符串描述符
 325           //0x0409为美式英语的ID
 326           0x09,
 327           0x04
 328          };
 329          ////////////////////////语言ID完毕//////////////////////////////////
 330          
 331          /**************************************************/
 332          /*********        本转换结果来自         **********/
 333          /********* Http://computer00.21ic.org    **********/
 334          /*********        作者: 电脑圈圈         **********/
 335          /*********         欢迎大家使用          **********/
 336          /*********    版权所有，盗版请写明出处   **********/
 337          /**************************************************/
 338          
 339          //http://computer00.21ic.org/user1/2198/archives/2007/42769.html
 340          //字符串“电脑圈圈的USB专区 Http://group.ednchina.com/93/”的Unicode编码
 341          //8位小端格式
 342          code uint8 ManufacturerStringDescriptor[82]={
 343          82,         //该描述符的长度为82字节
 344          0x03,       //字符串描述符的类型编码为0x03
 345          0x35, 0x75, //电
 346          0x11, 0x81, //脑
 347          0x08, 0x57, //圈
 348          0x08, 0x57, //圈
 349          0x84, 0x76, //的
 350          0x55, 0x00, //U
 351          0x53, 0x00, //S
 352          0x42, 0x00, //B
 353          0x13, 0x4e, //专
 354          0x3a, 0x53, //区
 355          0x20, 0x00, // 
 356          0x48, 0x00, //H
 357          0x74, 0x00, //t
 358          0x74, 0x00, //t
 359          0x70, 0x00, //p
 360          0x3a, 0x00, //:
 361          0x2f, 0x00, ///
 362          0x2f, 0x00, ///
 363          0x67, 0x00, //g
 364          0x72, 0x00, //r
 365          0x6f, 0x00, //o
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 7   

 366          0x75, 0x00, //u
 367          0x70, 0x00, //p
 368          0x2e, 0x00, //.
 369          0x65, 0x00, //e
 370          0x64, 0x00, //d
 371          0x6e, 0x00, //n
 372          0x63, 0x00, //c
 373          0x68, 0x00, //h
 374          0x69, 0x00, //i
 375          0x6e, 0x00, //n
 376          0x61, 0x00, //a
 377          0x2e, 0x00, //.
 378          0x63, 0x00, //c
 379          0x6f, 0x00, //o
 380          0x6d, 0x00, //m
 381          0x2f, 0x00, ///
 382          0x39, 0x00, //9
 383          0x33, 0x00, //3
 384          0x2f, 0x00  ///
 385          };
 386          /////////////////////////厂商字符串结束/////////////////////////////
 387          
 388          //字符串“《圈圈教你玩USB》之用户自定义的USB HID设备”的Unicode编码
 389          //8位小端格式
 390          code uint8 ProductStringDescriptor[54]={
 391          54,         //该描述符的长度为54字节
 392          0x03,       //字符串描述符的类型编码为0x03
 393          0x0a, 0x30, //《
 394          0x08, 0x57, //圈
 395          0x08, 0x57, //圈
 396          0x59, 0x65, //教
 397          0x60, 0x4f, //你
 398          0xa9, 0x73, //玩
 399          0x55, 0x00, //U
 400          0x53, 0x00, //S
 401          0x42, 0x00, //B
 402          0x0b, 0x30, //》
 403          0x4b, 0x4e, //之
 404          0x28, 0x75, //用
 405          0x37, 0x62, //户
 406          0xea, 0x81, //自
 407          0x9a, 0x5b, //定
 408          0x49, 0x4e, //义
 409          0x84, 0x76, //的
 410          0x55, 0x00, //U
 411          0x53, 0x00, //S
 412          0x42, 0x00, //B
 413          0x20, 0x00, // 
 414          0x48, 0x00, //H
 415          0x49, 0x00, //I
 416          0x44, 0x00, //D
 417          0xbe, 0x8b, //设
 418          0x07, 0x59  //备
 419          };
 420          ////////////////////////产品字符串结束////////////////////////////
 421          
 422          //字符串“2008-07-19”的Unicode编码
 423          //8位小端格式
 424          code uint8 SerialNumberStringDescriptor[22]={
 425          22,         //该描述符的长度为22字节
 426          0x03,       //字符串描述符的类型编码为0x03
 427          0x32, 0x00, //2
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 8   

 428          0x30, 0x00, //0
 429          0x30, 0x00, //0
 430          0x38, 0x00, //8
 431          0x2d, 0x00, //-
 432          0x30, 0x00, //0
 433          0x37, 0x00, //7
 434          0x2d, 0x00, //-
 435          0x31, 0x00, //1
 436          0x39, 0x00  //9
 437          };
 438          //////////////////////产品序列号字符串结束/////////////////////////
 439          
 440          /********************************************************************
 441          函数功能：延时x毫秒函数。
 442          入口参数：x：延时的毫秒数。
 443          返    回：无。
 444          备    注：无。
 445          ********************************************************************/
 446          void DelayXms(uint16 x)                
 447          {
 448   1       uint16 i;
 449   1       uint16 j;
 450   1       for(i=0;i<x;i++)
 451   1       for(j=0;j<227;j++); //循环语句延时
 452   1      }
 453          ////////////////////////End of function//////////////////////////////
 454          
 455          /********************************************************************
 456          函数功能：USB断开连接函数。
 457          入口参数：无。
 458          返    回：无。
 459          备    注：无。
 460          ********************************************************************/
 461          void UsbDisconnect(void)
 462          {
 463   1      #ifdef DEBUG0
 464   1       Prints("断开USB连接。\r\n");
 465   1      #endif
 466   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 467   1       D12WriteByte(0x06); //设置模式的第一字节
 468   1       D12WriteByte(0x47); //设置模式的第二字节
 469   1       DelayXms(1000);  //延迟1秒
 470   1      }
 471          ////////////////////////End of function//////////////////////////////
 472          
 473          /********************************************************************
 474          函数功能：USB连接函数。
 475          入口参数：无。
 476          返    回：无。
 477          备    注：无。
 478          ********************************************************************/
 479          void UsbConnect(void)
 480          {
 481   1      #ifdef DEBUG0
 482   1       Prints("连接USB。\r\n");
 483   1      #endif
 484   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 485   1       D12WriteByte(0x16); //设置模式的第一字节
 486   1       D12WriteByte(0x47); //设置模式的第二字节
 487   1      }
 488          ////////////////////////End of function//////////////////////////////
 489          
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 9   

 490          /********************************************************************
 491          函数功能：总线挂起中断处理函数。
 492          入口参数：无。
 493          返    回：无。
 494          备    注：无。
 495          ********************************************************************/
 496          void UsbBusSuspend(void)
 497          {
 498   1      #ifdef DEBUG0
 499   1       Prints("USB总线挂起。\r\n");
 500   1      #endif
 501   1      }
 502          ////////////////////////End of function//////////////////////////////
 503          
 504          /********************************************************************
 505          函数功能：总线复位中断处理函数。
 506          入口参数：无。
 507          返    回：无。
 508          备    注：无。
 509          ********************************************************************/
 510          void UsbBusReset(void)
 511          {
 512   1      #ifdef DEBUG0
 513   1       Prints("USB总线复位。\r\n");
 514   1      #endif
 515   1       Ep1InIsBusy=0; //复位后端点1输入缓冲区空闲。
 516   1      }
 517          ////////////////////////End of function//////////////////////////////
 518          
 519          /********************************************************************
 520          函数功能：根据pData和SendLength将数据发送到端点0的函数。
 521          入口参数：无。
 522          返    回：无。
 523          备    注：无。
 524          ********************************************************************/
 525          void UsbEp0SendData(void)
 526          {
 527   1       //将数据写到端点中去准备发送
 528   1       //写之前要先判断一下需要发送的数据是否比端点0
 529   1       //最大长度大，如果超过端点大小，则一次只能发送
 530   1       //最大包长的数据。端点0的最大包长在DeviceDescriptor[7]
 531   1       if(SendLength>DeviceDescriptor[7])
 532   1       {
 533   2        //按最大包长度发送
 534   2        D12WriteEndpointBuffer(1,DeviceDescriptor[7],pSendData);
 535   2        //发送后剩余字节数减少最大包长
 536   2        SendLength-=DeviceDescriptor[7];
 537   2        //发送一次后指针位置要调整
 538   2        pSendData+= DeviceDescriptor[7];
 539   2       }
 540   1       else
 541   1       {
 542   2        if(SendLength!=0)
 543   2        {
 544   3         //不够最大包长，可以直接发送
 545   3         D12WriteEndpointBuffer(1,SendLength,pSendData);
 546   3         //发送完毕后，SendLength长度变为0
 547   3         SendLength=0;
 548   3        }
 549   2        else //如果要发送的数据包长度为0
 550   2        {
 551   3         if(NeedZeroPacket==1) //如果需要发送0长度数据
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 10  

 552   3         {
 553   4          D12WriteEndpointBuffer(1,0,pSendData); //发送0长度数据包
 554   4          NeedZeroPacket=0; //清需要发送0长度数据包标志
 555   4         }
 556   3        }
 557   2       }
 558   1      }
 559          ////////////////////////End of function//////////////////////////////
 560          
 561          /********************************************************************
 562          函数功能：端点0输出中断处理函数。
 563          入口参数：无。
 564          返    回：无。
 565          备    注：无。
 566          ********************************************************************/
 567          void UsbEp0Out(void)
 568          {
 569   1      #ifdef DEBUG0
 570   1       Prints("USB端点0输出中断。\r\n");
 571   1      #endif
 572   1       //读取端点0输出最后传输状态，该操作清除中断标志
 573   1       //并判断第5位是否为1，如果是，则说明是建立包
 574   1       if(D12ReadEndpointLastStatus(0)&0x20)
 575   1       {
 576   2        D12ReadEndpointBuffer(0,16,Buffer); //读建立过程数据
 577   2        D12AcknowledgeSetup(); //应答建立包
 578   2        D12ClearBuffer(); //清缓冲区
 579   2        //将缓冲数据填到设备请求的各字段中
 580   2        bmRequestType=Buffer[0];
 581   2        bRequest=Buffer[1];
 582   2        wValue=Buffer[2]+(((uint16)Buffer[3])<<8);
 583   2        wIndex=Buffer[4]+(((uint16)Buffer[5])<<8);
 584   2        wLength=Buffer[6]+(((uint16)Buffer[7])<<8);
 585   2        //下面的代码判断具体的请求，并根据不同的请求进行相关操作
 586   2        //如果D7位为1，则说明是输入请求
 587   2        if((bmRequestType&0x80)==0x80)
 588   2        {
 589   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 590   3         //0为标准请求，1为类请求，2为厂商请求。
 591   3         switch((bmRequestType>>5)&0x03)
 592   3         {
 593   4          case 0:  //标准请求
 594   4           #ifdef DEBUG0
 595   4            Prints("USB标准输入请求：");
 596   4           #endif
 597   4           //USB协议定义了几个标准输入请求，我们实现这些标准请求即可
 598   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 599   4           //事实上，我们还需要对接收者进行散转，因为不同的请求接收者
 600   4           //是不一样的。接收者在bmRequestType的D4~D0位中定义。
 601   4           //我们这里为了简化操作，有些就省略了对接收者的判断。
 602   4           //例如获取描述符的请求，只根据描述符的类型来区别。
 603   4           switch(bRequest)
 604   4           {
 605   5            case GET_CONFIGURATION: //获取配置
 606   5             #ifdef DEBUG0
 607   5              Prints("获取配置。\r\n");
 608   5             #endif
 609   5            break;
 610   5            
 611   5            case GET_DESCRIPTOR:  //获取描述符
 612   5             #ifdef DEBUG0
 613   5              Prints("获取描述符――");
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 11  

 614   5             #endif
 615   5             //对描述符类型进行散转，对于全速设备，
 616   5             //标准请求只支持发送到设备的设备、配置、字符串三种描述符
 617   5             switch((wValue>>8)&0xFF)
 618   5              {
 619   6               case DEVICE_DESCRIPTOR: //设备描述符
 620   6                #ifdef DEBUG0
 621   6                 Prints("设备描述符。\r\n");
 622   6                #endif
 623   6                pSendData=DeviceDescriptor;  //需要发送的数据
 624   6                //判断请求的字节数是否比实际需要发送的字节数多
 625   6                //这里请求的是设备描述符，因此数据长度就是
 626   6                //DeviceDescriptor[0]。如果请求的比实际的长，
 627   6                //那么只返回实际长度的数据
 628   6                if(wLength>DeviceDescriptor[0])
 629   6                {
 630   7                 SendLength=DeviceDescriptor[0];
 631   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 632   7                 {
 633   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 634   8                 }
 635   7                }
 636   6                else
 637   6                {
 638   7                 SendLength=wLength;
 639   7                }
 640   6                //将数据通过EP0返回
 641   6                UsbEp0SendData();
 642   6               break;
 643   6               
 644   6               case CONFIGURATION_DESCRIPTOR:  //配置描述符
 645   6                #ifdef DEBUG0
 646   6                 Prints("配置描述符。\r\n");
 647   6                #endif
 648   6                pSendData=ConfigurationDescriptor; //需要发送的数据为配置描述符
 649   6                //判断请求的字节数是否比实际需要发送的字节数多
 650   6                //这里请求的是配置描述符集合，因此数据长度就是
 651   6                //ConfigurationDescriptor[3]*256+ConfigurationDescriptor[2]。
 652   6                //如果请求的比实际的长，那么只返回实际长度的数据
 653   6                SendLength=ConfigurationDescriptor[3];
 654   6                SendLength=SendLength*256+ConfigurationDescriptor[2];
 655   6                if(wLength>SendLength)
 656   6                {
 657   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 658   7                 {
 659   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 660   8                 }
 661   7                }
 662   6                else
 663   6                {
 664   7                 SendLength=wLength;
 665   7                }
 666   6                //将数据通过EP0返回
 667   6                UsbEp0SendData();
 668   6               break;
 669   6               
 670   6               case STRING_DESCRIPTOR:  //字符串描述符
 671   6                #ifdef DEBUG0
 672   6                 Prints("字符串描述符");
 673   6                #endif
 674   6                switch(wValue&0xFF)  //根据wValue的低字节（索引值）散转
 675   6                {
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 12  

 676   7                 case 0:  //获取语言ID
 677   7                  #ifdef DEBUG0
 678   7                   Prints("(语言ID)。\r\n");
 679   7                  #endif
 680   7                  pSendData=LanguageId;
 681   7                  SendLength=LanguageId[0];
 682   7                 break;
 683   7                 
 684   7                 case 1:  //厂商字符串的索引值为1，所以这里为厂商字符串
 685   7                 #ifdef DEBUG0
 686   7                   Prints("(厂商描述)。\r\n");
 687   7                  #endif
 688   7                  pSendData=ManufacturerStringDescriptor;
 689   7                  SendLength=ManufacturerStringDescriptor[0];
 690   7                 break;
 691   7                 
 692   7                 case 2:  //产品字符串的索引值为2，所以这里为产品字符串
 693   7                 #ifdef DEBUG0
 694   7                   Prints("(产品描述)。\r\n");
 695   7                  #endif
 696   7                  pSendData=ProductStringDescriptor;
 697   7                  SendLength=ProductStringDescriptor[0];
 698   7                 break;
 699   7                 
 700   7                 case 3:  //产品序列号的索引值为3，所以这里为序列号
 701   7                 #ifdef DEBUG0
 702   7                   Prints("(产品序列号)。\r\n");
 703   7                  #endif
 704   7                  pSendData=SerialNumberStringDescriptor;
 705   7                  SendLength=SerialNumberStringDescriptor[0];
 706   7                 break;
 707   7                 
 708   7                 default :
 709   7                  #ifdef DEBUG0
 710   7                   Prints("(未知的索引值)。\r\n");
 711   7                  #endif
 712   7                  //对于未知索引值的请求，返回一个0长度的包
 713   7                  SendLength=0;
 714   7                  NeedZeroPacket=1;
 715   7                 break;
 716   7                }
 717   6                //判断请求的字节数是否比实际需要发送的字节数多
 718   6                //如果请求的比实际的长，那么只返回实际长度的数据
 719   6                if(wLength>SendLength)
 720   6                {
 721   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 722   7                 {
 723   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 724   8                 }
 725   7                }
 726   6                else
 727   6                {
 728   7                 SendLength=wLength;
 729   7                }
 730   6                //将数据通过EP0返回
 731   6                UsbEp0SendData();         
 732   6               break;
 733   6      
 734   6               case REPORT_DESCRIPTOR:  //报告描述符
 735   6                #ifdef DEBUG0
 736   6                 Prints("报告描述符。\r\n");
 737   6                #endif
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 13  

 738   6                pSendData=ReportDescriptor; //需要发送的数据为报告描述符
 739   6                SendLength=sizeof(ReportDescriptor); //需要返回的数据长度         
 740   6                //判断请求的字节数是否比实际需要发送的字节数多
 741   6                //如果请求的比实际的长，那么只返回实际长度的数据
 742   6                if(wLength>SendLength)
 743   6                {
 744   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 745   7                 {
 746   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 747   8                 }
 748   7                }
 749   6                else
 750   6                {
 751   7                 SendLength=wLength;
 752   7                }
 753   6                //将数据通过EP0返回
 754   6                UsbEp0SendData();
 755   6               break;
 756   6                       
 757   6               default:  //其它描述符
 758   6                #ifdef DEBUG0
 759   6                 Prints("其他描述符，描述符代码：");
 760   6                 PrintHex((wValue>>8)&0xFF);
 761   6                 Prints("\r\n");
 762   6                #endif
 763   6               break;
 764   6              }
 765   5             break;
 766   5            
 767   5            case GET_INTERFACE: //获取接口
 768   5             #ifdef DEBUG0
 769   5              Prints("获取接口。\r\n");
 770   5             #endif
 771   5            break;
 772   5            
 773   5            case GET_STATUS: //获取状态
 774   5             #ifdef DEBUG0
 775   5              Prints("获取状态。\r\n");
 776   5             #endif
 777   5            break;
 778   5            
 779   5            case SYNCH_FRAME: //同步帧
 780   5             #ifdef DEBUG0
 781   5              Prints("同步帧。\r\n");
 782   5             #endif
 783   5            break;
 784   5            
 785   5            default:  //未定义的标准请求
 786   5             #ifdef DEBUG0
 787   5              Prints("错误：未定义的标准输入请求。\r\n");
 788   5             #endif       
 789   5            break;
 790   5           }
 791   4          break;
 792   4          
 793   4          case 1:  //类请求
 794   4           #ifdef DEBUG0
 795   4            Prints("USB类输入请求：\r\n");
 796   4           #endif
 797   4          break;
 798   4          
 799   4          case 2:  //厂商请求
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 14  

 800   4           #ifdef DEBUG0
 801   4            Prints("USB厂商输入请求：\r\n");
 802   4           #endif
 803   4          break;
 804   4          
 805   4          default: //未定义的请求。这里只显示一个报错信息。
 806   4           #ifdef DEBUG0
 807   4            Prints("错误：未定义的输入请求。\r\n");
 808   4           #endif
 809   4          break;
 810   4         }
 811   3        }
 812   2        //否则说明是输出请求
 813   2        else //if(bmRequestType&0x80==0x80)之else
 814   2        {
 815   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 816   3         //0为标准请求，1为类请求，2为厂商请求。
 817   3         switch((bmRequestType>>5)&0x03)
 818   3         {
 819   4          case 0:  //标准请求
 820   4           #ifdef DEBUG0
 821   4            Prints("USB标准输出请求：");
 822   4           #endif
 823   4           //USB协议定义了几个标准输出请求，我们实现这些标准请求即可
 824   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 825   4           switch(bRequest)
 826   4           {
 827   5            case CLEAR_FEATURE: //清除特性
 828   5             #ifdef DEBUG0
 829   5              Prints("清除特性。\r\n");
 830   5             #endif
 831   5            break;
 832   5            
 833   5            case SET_ADDRESS:  //设置地址
 834   5             #ifdef DEBUG0
 835   5              Prints("设置地址。地址为：");
 836   5              PrintHex(wValue&0xFF); //显示所设置的地址
 837   5              Prints("\r\n");
 838   5             #endif
 839   5             D12SetAddress(wValue&0xFF); //wValue中的低字节是设置的地址值
 840   5             //设置地址没有数据过程，直接进入到状态过程，返回一个0长度的数据包
 841   5             SendLength=0;
 842   5             NeedZeroPacket=1;
 843   5             //将数据通过EP0返回
 844   5             UsbEp0SendData();
 845   5            break;
 846   5            
 847   5            case SET_CONFIGURATION: //设置配置
 848   5             #ifdef DEBUG0
 849   5              Prints("设置配置。\r\n");
 850   5             #endif
 851   5             //使能非0端点。非0端点只有在设置为非0的配置后才能使能。
 852   5             //wValue的低字节为配置的值，如果该值为非0，才能使能非0端点。
 853   5             //保存当前配置值
 854   5             ConfigValue=wValue&0xFF;
 855   5             D12SetEndpointEnable(ConfigValue);
 856   5             //返回一个0长度的状态数据包
 857   5             SendLength=0;
 858   5             NeedZeroPacket=1;
 859   5             //将数据通过EP0返回
 860   5             UsbEp0SendData();
 861   5            break;
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 15  

 862   5            
 863   5            case SET_DESCRIPTOR: //设置描述符
 864   5             #ifdef DEBUG0
 865   5              Prints("设置描述符。\r\n");
 866   5             #endif
 867   5            break;
 868   5            
 869   5            case SET_FEATURE: //设置特性
 870   5             #ifdef DEBUG0
 871   5              Prints("设置特性。\r\n");
 872   5             #endif
 873   5            break;
 874   5      
 875   5            case SET_INTERFACE: //设置接口
 876   5             #ifdef DEBUG0
 877   5              Prints("设置接口。\r\n");
 878   5             #endif
 879   5            break;      
 880   5            
 881   5            default:  //未定义的标准请求
 882   5             #ifdef DEBUG0
 883   5              Prints("错误：未定义的标准输出请求。\r\n");
 884   5             #endif       
 885   5            break;
 886   5           }
 887   4          break;
 888   4          
 889   4          case 1:  //类请求
 890   4           #ifdef DEBUG0
 891   4            Prints("USB类输出请求：");
 892   4           #endif
 893   4           switch(bRequest)
 894   4           {
 895   5            case SET_IDLE:
 896   5             #ifdef DEBUG0
 897   5              Prints("设置空闲。\r\n");
 898   5             #endif
 899   5             //只需要返回一个0长度的数据包即可
 900   5             SendLength=0;
 901   5             NeedZeroPacket=1;
 902   5             //将数据通过EP0返回
 903   5             UsbEp0SendData();
 904   5            break;
 905   5            
 906   5            default:
 907   5             #ifdef DEBUG0
 908   5              Prints("未知请求。\r\n");
 909   5             #endif
 910   5            break;
 911   5           }
 912   4          break;
 913   4          
 914   4          case 2:  //厂商请求
 915   4           #ifdef DEBUG0
 916   4            Prints("USB厂商输出请求：\r\n");
 917   4           #endif
 918   4          break;
 919   4          
 920   4          default: //未定义的请求。这里只显示一个报错信息。
 921   4           #ifdef DEBUG0
 922   4            Prints("错误：未定义的输出请求。\r\n");
 923   4           #endif
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 16  

 924   4          break;
 925   4         }
 926   3        }
 927   2       }
 928   1       //普通数据输出
 929   1       else //if(D12ReadEndpointLastStatus(0)&0x20)之else
 930   1       {
 931   2        D12ReadEndpointBuffer(0,16,Buffer);
 932   2        D12ClearBuffer();
 933   2       }
 934   1      }
 935          ////////////////////////End of function//////////////////////////////
 936          
 937          /********************************************************************
 938          函数功能：端点0输入中断处理函数。
 939          入口参数：无。
 940          返    回：无。
 941          备    注：无。
 942          ********************************************************************/
 943          void UsbEp0In(void)
 944          {
 945   1      #ifdef DEBUG0
 946   1       Prints("USB端点0输入中断。\r\n");
 947   1      #endif
 948   1       //读最后发送状态，这将清除端点0的中断标志位
 949   1       D12ReadEndpointLastStatus(1);
 950   1       //发送剩余的字节数
 951   1       UsbEp0SendData();
 952   1      }
 953          ////////////////////////End of function//////////////////////////////
 954          
 955          /********************************************************************
 956          函数功能：端点1输出中断处理函数。
 957          入口参数：无。
 958          返    回：无。
 959          备    注：无。
 960          ********************************************************************/
 961          void UsbEp1Out(void)
 962          {
 963   1       uint8 Buf[8]; //用来保存8字节的输出报告。
 964   1      #ifdef DEBUG0
 965   1       Prints("USB端点1输出中断。\r\n");
 966   1      #endif
 967   1       //读端点最后状态，这将清除端点1输出的中断标志位
 968   1       D12ReadEndpointLastStatus(2);
 969   1       //从端点1输出缓冲读回8字节数据
 970   1       D12ReadEndpointBuffer(2,8,Buf);
 971   1       //清除端点缓冲区
 972   1       D12ClearBuffer();
 973   1       
 974   1       //输出报告第一字节为LED状态，某位为1时，表示LED亮。
 975   1       LEDs=~Buf[0];
 976   1       
 977   1       //输出报告的第二字节非0时，清除发送计数器Count。
 978   1       if(Buf[1]!=0)
 979   1       {
 980   2        Count=0;
 981   2       }
 982   1      }
 983          ////////////////////////End of function//////////////////////////////
 984          
 985          /********************************************************************
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:55 PAGE 17  

 986          函数功能：端点1输入中断处理函数。
 987          入口参数：无。
 988          返    回：无。
 989          备    注：无。
 990          ********************************************************************/
 991          void UsbEp1In(void)
 992          {
 993   1      #ifdef DEBUG0
 994   1       Prints("USB端点1输入中断。\r\n");
 995   1      #endif
 996   1       //读最后发送状态，这将清除端点1输入的中断标志位
 997   1       D12ReadEndpointLastStatus(3);
 998   1       //端点1输入处于空闲状态
 999   1       Ep1InIsBusy=0;
1000   1      }
1001          ////////////////////////End of function//////////////////////////////
1002          
1003          /********************************************************************
1004          函数功能：端点2输出中断处理函数。
1005          入口参数：无。
1006          返    回：无。
1007          备    注：无。
1008          ********************************************************************/
1009          void UsbEp2Out(void)
1010          {
1011   1      #ifdef DEBUG0
1012   1       Prints("USB端点2输出中断。\r\n");
1013   1      #endif
1014   1      }
1015          ////////////////////////End of function//////////////////////////////
1016          
1017          /********************************************************************
1018          函数功能：端点2输入中断处理函数。
1019          入口参数：无。
1020          返    回：无。
1021          备    注：无。
1022          ********************************************************************/
1023          void UsbEp2In(void)
1024          {
1025   1      #ifdef DEBUG0
1026   1       Prints("USB端点2输入中断。\r\n");
1027   1      #endif
1028   1      }
1029          ////////////////////////End of function//////////////////////////////


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1273    ----
   CONSTANT SIZE    =   1002    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20       8
   IDATA SIZE       =     16    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
