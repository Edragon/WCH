C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE USBCORE
OBJECT MODULE PLACED IN UsbCore.OBJ
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE UsbCore.c BROWSE DEBUG OBJECTEXTEND TABS(1)

stmt level    source

   1          /******************************************************************
   2             本程序只供学习使用，未经作者许可，不得用于其它任何用途
   3             
   4                  欢迎访问我的USB专区：http://group.ednchina.com/93/
   5                  欢迎访问我的blog：   http://www.ednchina.com/blog/computer00
   6                                       http://computer00.21ic.org
   7          
   8                  感谢PCB赞助商――电子园： http://bbs.cepark.com/
   9          
  10          UsbCore.c file
  11          
  12          作者：电脑圈圈
  13          建立日期: 2008.06.29
  14          修改日期: 2008.07.15
  15          版本：V1.1
  16          版权所有，盗版必究。
  17          Copyright(C) 电脑圈圈 2008-2018
  18          All rights reserved            
  19          *******************************************************************/
  20          
  21          #include "config.h"
  22          #include "pdiusbd12.h"
  23          #include "uart.h"
  24          #include "usbcore.h"
  25          #include "led.h"
  26          
  27          idata uint8 Buffer[16];  //读端点0用的缓冲区
  28          
  29          //USB设备请求的各字段
  30          uint8  bmRequestType;
  31          uint8  bRequest;
  32          uint16 wValue;
  33          uint16 wIndex;
  34          uint16 wLength;
  35          //当前发送数据的位置
  36          uint8 * pSendData;
  37          //需要发送数据的长度
  38          uint16 SendLength;
  39          //是否需要发送0数据包的标志。在USB控制传输的数据过程中，
  40          //当返回的数据包字节数少于最大包长时，会认为数据过程结束。
  41          //当请求的字节数比实际需要返回的字节数长，而实际返回的字节
  42          //数又刚好是端点0大小的整数倍时，就需要返回一个0长度的数据包
  43          //来结束数据过程。因此这里增加一个标志，供程序决定是否需要返回
  44          //一个0长度的数据包。
  45          uint8 NeedZeroPacket;
  46          
  47          //当前的配置值。只有在设置非0配置后
  48          uint8 ConfigValue;
  49          
  50          //端点1缓冲是否忙的标志。当缓冲区中有数据时，该标志为真。
  51          //当缓冲区中空闲时，该标志为假。
  52          uint8 Ep1InIsBusy;
  53          
  54          //USB设备描述符的定义
  55          code uint8 DeviceDescriptor[0x12]=  //设备描述符为18字节
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 2   

  56          {
  57          //bLength字段。设备描述符的长度为18(0x12)字节
  58           0x12,
  59           
  60          //bDescriptorType字段。设备描述符的编号为0x01
  61           0x01,
  62           
  63          //bcdUSB字段。这里设置版本为USB1.1，即0x0110。
  64          //由于是小端结构，所以低字节在先，即0x10，0x01。
  65           0x10,
  66           0x01,
  67           
  68          //bDeviceClass字段。我们不在设备描述符中定义设备类，
  69          //而在接口描述符中定义设备类，所以该字段的值为0。
  70           0x00,
  71           
  72          //bDeviceSubClass字段。bDeviceClass字段为0时，该字段也为0。
  73           0x00,
  74           
  75          //bDeviceProtocol字段。bDeviceClass字段为0时，该字段也为0。
  76           0x00,
  77           
  78          //bMaxPacketSize0字段。PDIUSBD12的端点0大小的16字节。
  79           0x10,
  80           
  81          //idVender字段。厂商ID号，我们这里取0x8888，仅供实验用。
  82          //实际产品不能随便使用厂商ID号，必须跟USB协会申请厂商ID号。
  83          //注意小端模式，低字节在先。
  84           0x88,
  85           0x88,
  86           
  87          //idProduct字段。产品ID号，由于是第三个实验，我们这里取0x0003。
  88          //注意小端模式，低字节应该在前。
  89           0x03,
  90           0x00,
  91           
  92          //bcdDevice字段。取1.0版，即0x0100。
  93          //小端模式，低字节在先。
  94           0x00,
  95           0x01,
  96           
  97          //iManufacturer字段。厂商字符串的索引值，为了方便记忆和管理，
  98          //字符串索引就从1开始。
  99           0x01,
 100          
 101          //iProduct字段。产品字符串的索引值。刚刚用了1，这里就取2吧。
 102          //注意字符串索引值不要使用相同的值。
 103           0x02,
 104           
 105          //iSerialNumber字段。设备的序列号字符串索引值。
 106          //这里取3就可以了。
 107           0x03,
 108          
 109          //bNumConfigurations字段。该设备所具有的配置数。
 110          //我们只需要一种配置就行了，因此该值设置为1。
 111           0x01
 112          };
 113          //////////////////////////设备描述符完毕//////////////////////////////
 114          
 115          //USB报告描述符的定义
 116          //该报告描述符定义了两个顶层应用集合――键盘和鼠标。
 117          code uint8 ReportDescriptor[]=
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 3   

 118          {
 119           //每行开始的第一字节为该条目的前缀，前缀的格式为：
 120           //D7~D4：bTag。D3~D2：bType；D1~D0：bSize。以下分别对每个条目注释。
 121           
 122          /************************USB键盘部分报告描述符**********************/
 123          /*******************************************************************/
 124           //这是一个全局（bType为1）条目，将用途页选择为普通桌面Generic Desktop Page(0x01)
 125           //后面跟一字节数据（bSize为1），后面的字节数就不注释了，
 126           //自己根据bSize来判断。
 127           0x05, 0x01, // USAGE_PAGE (Generic Desktop)
 128           
 129           //这是一个局部（bType为2）条目，说明接下来的集合用途用于键盘
 130           0x09, 0x06, // USAGE (Keyboard)
 131           
 132           //这是一个主条目（bType为0）条目，开集合，后面跟的数据0x01表示
 133           //该集合是一个应用集合。它的性质在前面由用途页和用途定义为
 134           //普通桌面用的键盘。
 135           0xa1, 0x01, // COLLECTION (Application)
 136           
 137           //报告ID，这里定义键盘报告的ID为1（报告ID 0是保留的）
 138           0x85, 0x01, //Report ID (1)
 139           
 140           //这是一个全局条目，选择用途页为键盘（Keyboard/Keypad(0x07)）
 141           0x05, 0x07, //     USAGE_PAGE (Keyboard/Keypad)
 142          
 143           //这是一个局部条目，说明用途的最小值为0xe0。实际上是键盘左Ctrl键。
 144           //具体的用途值可在HID用途表中查看。
 145           0x19, 0xe0, //     USAGE_MINIMUM (Keyboard LeftControl)
 146           
 147           //这是一个局部条目，说明用途的最大值为0xe7。实际上是键盘右GUI键。
 148           0x29, 0xe7, //     USAGE_MAXIMUM (Keyboard Right GUI)
 149           
 150           //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值）
 151           //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。
 152           0x15, 0x00, //     LOGICAL_MINIMUM (0)
 153           
 154           //这是一个全局条目，说明逻辑值最大为1。
 155           0x25, 0x01, //     LOGICAL_MAXIMUM (1)
 156           
 157           //这是一个全局条目，说明数据域的数量为八个。
 158           0x95, 0x08, //     REPORT_COUNT (8)
 159           
 160           //这是一个全局条目，说明每个数据域的长度为1个bit。
 161           0x75, 0x01, //     REPORT_SIZE (1)
 162           
 163           //这是一个主条目，说明有8个长度为1bit的数据域（数量和长度
 164           //由前面的两个全局条目所定义）用来做为输入，
 165           //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示
 166           //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。
 167           //这样定义的结果就是，当某个域的值为1时，就表示对应的键按下。
 168           //bit0就对应着用途最小值0xe0，bit7对应着用途最大值0xe7。
 169           0x81, 0x02, //     INPUT (Data,Var,Abs)
 170           
 171           //这是一个全局条目，说明数据域数量为1个
 172           0x95, 0x01, //     REPORT_COUNT (1)
 173           
 174           //这是一个全局条目，说明每个数据域的长度为8bit。
 175           0x75, 0x08, //     REPORT_SIZE (8)
 176           
 177           //这是一个主条目，输入用，由前面两个全局条目可知，长度为8bit，
 178           //数量为1个。它的属性为常量（即返回的数据一直是0）。
 179           //该字节是保留字节（保留给OEM使用）。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 4   

 180           0x81, 0x03, //     INPUT (Cnst,Var,Abs)
 181           
 182           //这是一个全局条目。定义位域数量为6个。
 183           0x95, 0x06, //   REPORT_COUNT (6)
 184           
 185           //这是一个全局条目。定义每个位域长度为8bit。
 186           //其实这里这个条目不要也是可以的，因为在前面已经有一个定义
 187           //长度为8bit的全局条目了。
 188           0x75, 0x08, //   REPORT_SIZE (8)
 189           
 190           //这是一个全局条目，定义逻辑最小值为0。
 191           //同上，这里这个全局条目也是可以不要的，因为前面已经有一个
 192           //定义逻辑最小值为0的全局条目了。
 193           0x15, 0x00, //   LOGICAL_MINIMUM (0)
 194           
 195           //这是一个全局条目，定义逻辑最大值为255。
 196           0x25, 0xFF, //   LOGICAL_MAXIMUM (255)
 197           
 198           //这是一个全局条目，选择用途页为键盘。
 199           //前面已经选择过用途页为键盘了，所以该条目不要也可以。
 200           0x05, 0x07, //   USAGE_PAGE (Keyboard/Keypad)
 201           
 202           //这是一个局部条目，定义用途最小值为0（0表示没有键按下）
 203           0x19, 0x00, //   USAGE_MINIMUM (Reserved (no event indicated))
 204           
 205           //这是一个局部条目，定义用途最大值为0x65
 206           0x29, 0x65, //   USAGE_MAXIMUM (Keyboard Application)
 207           
 208           //这是一个主条目。它说明这六个8bit的数据域是输入用的，
 209           //属性为：Data,Ary,Abs。Data说明数据是可以变的，Ary说明
 210           //这些数据域是一个数组，即每个8bit都可以表示某个键值，
 211           //如果按下的键太多（例如超过这里定义的长度或者键盘本身无法
 212           //扫描出按键情况时），则这些数据返回全1（二进制），表示按键无效。
 213           //Abs表示这些值是绝对值。
 214           0x81, 0x00, //     INPUT (Data,Ary,Abs)
 215          
 216           //以下为输出报告的描述
 217           //逻辑最小值前面已经有定义为0了，这里可以省略。 
 218           //这是一个全局条目，说明逻辑值最大为1。
 219           0x25, 0x01, //     LOGICAL_MAXIMUM (1)
 220           
 221           //这是一个全局条目，说明数据域数量为5个。 
 222           0x95, 0x05, //   REPORT_COUNT (5)
 223           
 224           //这是一个全局条目，说明数据域的长度为1bit。
 225           0x75, 0x01, //   REPORT_SIZE (1)
 226           
 227           //这是一个全局条目，说明使用的用途页为指示灯（LED）
 228           0x05, 0x08, //   USAGE_PAGE (LEDs)
 229           
 230           //这是一个局部条目，说明用途最小值为数字键盘灯。
 231           0x19, 0x01, //   USAGE_MINIMUM (Num Lock)
 232           
 233           //这是一个局部条目，说明用途最大值为Kana灯。
 234           0x29, 0x05, //   USAGE_MAXIMUM (Kana)
 235           
 236           //这是一个主条目。定义输出数据，即前面定义的5个LED。
 237           0x91, 0x02, //   OUTPUT (Data,Var,Abs)
 238           
 239           //这是一个全局条目。定义位域数量为1个。
 240           0x95, 0x01, //   REPORT_COUNT (1)
 241           
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 5   

 242           //这是一个全局条目。定义位域长度为3bit。
 243           0x75, 0x03, //   REPORT_SIZE (3)
 244           
 245           //这是一个主条目，定义输出常量，前面用了5bit，所以这里需要
 246           //3个bit来凑成一字节。
 247           0x91, 0x03, //   OUTPUT (Cnst,Var,Abs)
 248           
 249           //下面这个主条目用来关闭前面的集合。bSize为0，所以后面没数据。
 250           0xc0,        // END_COLLECTION
 251          //以下注释不包括第一字节报告ID。
 252          //通过上面的报告描述符的定义，我们知道返回的输入报告具有8字节。
 253          //第一字节的8个bit用来表示特殊键是否按下（例如Shift、Alt等键）。
 254          //第二字节为保留值，值为常量0。第三到第八字节是一个普通键键值的
 255          //数组，当没有键按下时，全部6个字节值都为0。当只有一个普通键按下时，
 256          //这六个字节中的第一字节值即为该按键的键值（具体的键值请看HID的
 257          //用途表文档），当有多个普通键同时按下时，则同时返回这些键的键值。
 258          //如果按下的键太多，则这六个字节都为0xFF（不能返回0x00，这样会让
 259          //操作系统认为所有键都已经释放）。至于键值在数组中的先后顺序是
 260          //无所谓的，操作系统会负责检查是否有新键按下。我们应该在中断端点1
 261          //中按照上面的格式返回实际的键盘数据。另外，报告中还定义了一个字节
 262          //的输出报告，是用来控制LED情况的。只使用了低7位，高1位是保留值0。
 263          //当某位的值为1时，则表示对应的LED要点亮。操作系统会负责同步各个
 264          //键盘之间的LED，例如你有两块键盘，一块的数字键盘灯亮时，另一块
 265          //也会跟着亮。键盘本身不需要判断各种LED应该何时亮，它只是等待主机
 266          //发送报告给它，然后根据报告值来点亮相应的LED。我们在端点1输出中断
 267          //中读出这1字节的输出报告，然后对它取反（因为学习板上的LED是低电平时
 268          //亮），直接发送到LED上。这样main函数中按键点亮LED的代码就不需要了。
 269          
 270          /************************USB鼠标部分报告描述符**********************/
 271          /*******************************************************************/
 272          
 273           //这是一个全局（bType为1）条目，选择用途页为普通桌面Generic Desktop Page(0x01)
 274           0x05, 0x01, // USAGE_PAGE (Generic Desktop)
 275           
 276           //这是一个局部（bType为2）条目，说明接下来的应用集合用途用于鼠标
 277           0x09, 0x02, // USAGE (Mouse)
 278           
 279           //这是一个主条目（bType为0）条目，开集合，后面跟的数据0x01表示
 280           //该集合是一个应用集合。它的性质在前面由用途页和用途定义为
 281           //普通桌面用的鼠标。
 282           0xa1, 0x01, // COLLECTION (Application)
 283           
 284           //报告ID，这里定义鼠标报告的ID为2
 285           0x85, 0x02, //Report ID (2)
 286           
 287           //这是一个局部条目。说明用途为指针集合
 288           0x09, 0x01, //   USAGE (Pointer)
 289           
 290           //这是一个主条目，开集合，后面跟的数据0x00表示该集合是一个
 291           //物理集合，用途由前面的局部条目定义为指针集合。
 292           0xa1, 0x00, //   COLLECTION (Physical)
 293           
 294           //这是一个全局条目，选择用途页为按键（Button Page(0x09)）
 295           0x05, 0x09, //     USAGE_PAGE (Button)
 296           
 297           //这是一个局部条目，说明用途的最小值为1。实际上是鼠标左键。
 298           0x19, 0x01, //     USAGE_MINIMUM (Button 1)
 299           
 300           //这是一个局部条目，说明用途的最大值为3。实际上是鼠标中键。
 301           0x29, 0x03, //     USAGE_MAXIMUM (Button 3)
 302           
 303           //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值啦）
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 6   

 304           //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。
 305           0x15, 0x00, //     LOGICAL_MINIMUM (0)
 306           
 307           //这是一个全局条目，说明逻辑值最大为1。
 308           0x25, 0x01, //     LOGICAL_MAXIMUM (1)
 309           
 310           //这是一个全局条目，说明数据域的数量为三个。
 311           0x95, 0x03, //     REPORT_COUNT (3)
 312           
 313           //这是一个全局条目，说明每个数据域的长度为1个bit。
 314           0x75, 0x01, //     REPORT_SIZE (1)
 315           
 316           //这是一个主条目，说明有3个长度为1bit的数据域（数量和长度
 317           //由前面的两个全局条目所定义）用来做为输入，
 318           //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示
 319           //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。
 320           //这样定义的结果就是，第一个数据域bit0表示按键1（左键）是否按下，
 321           //第二个数据域bit1表示按键2（右键）是否按下，第三个数据域bit2表示
 322           //按键3（中键）是否按下。
 323           0x81, 0x02, //     INPUT (Data,Var,Abs)
 324           
 325           //这是一个全局条目，说明数据域数量为1个
 326           0x95, 0x01, //     REPORT_COUNT (1)
 327           
 328           //这是一个全局条目，说明每个数据域的长度为5bit。
 329           0x75, 0x05, //     REPORT_SIZE (5)
 330           
 331           //这是一个主条目，输入用，由前面两个全局条目可知，长度为5bit，
 332           //数量为1个。它的属性为常量（即返回的数据一直是0）。
 333           //这个只是为了凑齐一个字节（前面用了3个bit）而填充的一些数据
 334           //而已，所以它是没有实际用途的。
 335           0x81, 0x03, //     INPUT (Cnst,Var,Abs)
 336           
 337           //这是一个全局条目，选择用途页为普通桌面Generic Desktop Page(0x01)
 338           0x05, 0x01, //     USAGE_PAGE (Generic Desktop)
 339           
 340           //这是一个局部条目，说明用途为X轴
 341           0x09, 0x30, //     USAGE (X)
 342           
 343           //这是一个局部条目，说明用途为Y轴
 344           0x09, 0x31, //     USAGE (Y)
 345           
 346           //这是一个局部条目，说明用途为滚轮
 347           0x09, 0x38, //     USAGE (Wheel)
 348           
 349           //下面两个为全局条目，说明返回的逻辑最小和最大值。
 350           //因为鼠标指针移动时，通常是用相对值来表示的，
 351           //相对值的意思就是，当指针移动时，只发送移动量。
 352           //往右移动时，X值为正；往下移动时，Y值为正。
 353           //对于滚轮，当滚轮往上滚时，值为正。
 354           0x15, 0x81, //     LOGICAL_MINIMUM (-127)
 355           0x25, 0x7f, //     LOGICAL_MAXIMUM (127)
 356           
 357           //这是一个全局条目，说明数据域的长度为8bit。
 358           0x75, 0x08, //     REPORT_SIZE (8)
 359           
 360           //这是一个全局条目，说明数据域的个数为3个。
 361           0x95, 0x03, //     REPORT_COUNT (3)
 362           
 363           //这是一个主条目。它说明这三个8bit的数据域是输入用的，
 364           //属性为：Data,Var,Rel。Data说明数据是可以变的，Var说明
 365           //这些数据域是独立的，即第一个8bit表示X轴，第二个8bit表示
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 7   

 366           //Y轴，第三个8bit表示滚轮。Rel表示这些值是相对值。
 367           0x81, 0x06, //     INPUT (Data,Var,Rel)
 368           
 369           //下面这两个主条目用来关闭前面的集合用。
 370           //我们开了两个集合，所以要关两次。bSize为0，所以后面没数据。
 371           0xc0,       //   END_COLLECTION
 372           0xc0        // END_COLLECTION
 373          //以下注释不包括第一字节报告ID。
 374          //通过上面的报告描述符的定义，我们知道返回的输入报告具有4字节。
 375          //第一字节的低3位用来表示按键是否按下的，高5位为常数0，无用。
 376          //第二字节表示X轴改的变量，第三字节表示Y轴的改变量，第四字节表示
 377          //滚轮的改变量。我们在中断端点1中应该要按照上面的格式返回实际的
 378          //鼠标数据。
 379          };
 380          //由于该报告使用了报告ID，因此报告在返回时，需要在最前面增加
 381          //一字节的报告ID。当报告ID为1时，返回的数据是键盘数据；
 382          //当报告ID为2时，返回的数据是鼠标数据。
 383          ///////////////////////////报告描述符完毕////////////////////////////
 384          
 385          //USB配置描述符集合的定义
 386          //配置描述符总长度为9+9+9+7+7字节
 387          code uint8 ConfigurationDescriptor[9+9+9+7+7]=
 388          {
 389           /***************配置描述符***********************/
 390           //bLength字段。配置描述符的长度为9字节。
 391           0x09,
 392           
 393           //bDescriptorType字段。配置描述符编号为0x02。
 394           0x02,
 395           
 396           //wTotalLength字段。配置描述符集合的总长度，
 397           //包括配置描述符本身、接口描述符、类描述符、端点描述符等。
 398           sizeof(ConfigurationDescriptor)&0xFF, //低字节
 399           (sizeof(ConfigurationDescriptor)>>8)&0xFF, //高字节
 400           
 401           //bNumInterfaces字段。该配置包含的接口数，只有一个接口。
 402           0x01,
 403           
 404           //bConfiguration字段。该配置的值为1。
 405           0x01,
 406           
 407           //iConfigurationz字段，该配置的字符串索引。这里没有，为0。
 408           0x00,
 409           
 410           //bmAttributes字段，该设备的属性。由于我们的板子是总线供电的，
 411           //并且我们不想实现远程唤醒的功能，所以该字段的值为0x80。
 412           0x80,
 413           
 414           //bMaxPower字段，该设备需要的最大电流量。由于我们的板子
 415           //需要的电流不到100mA，因此我们这里设置为100mA。由于每单位
 416           //电流为2mA，所以这里设置为50(0x32)。
 417           0x32,
 418           
 419           /*******************接口描述符*********************/
 420           //bLength字段。接口描述符的长度为9字节。
 421           0x09,
 422           
 423           //bDescriptorType字段。接口描述符的编号为0x04。
 424           0x04,
 425           
 426           //bInterfaceNumber字段。该接口的编号，第一个接口，编号为0。
 427           0x00,
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 8   

 428           
 429           //bAlternateSetting字段。该接口的备用编号，为0。
 430           0x00,
 431           
 432           //bNumEndpoints字段。非0端点的数目。由于USB键盘需要二个
 433           //中断端点（一个输入一个输出），因此该值为2。
 434           0x02,
 435           
 436           //bInterfaceClass字段。该接口所使用的类。USB键盘是HID类，
 437           //HID类的编码为0x03。
 438           0x03,
 439           
 440           //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中，
 441           //只规定了一种子类：支持BIOS引导启动的子类。
 442           //USB键盘、鼠标属于该子类，子类代码为0x01。
 443           0x01,
 444           
 445           //bInterfaceProtocol字段。如果子类为支持引导启动的子类，
 446           //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。
 447           0x01,
 448           
 449           //iConfiguration字段。该接口的字符串索引值。这里没有，为0。
 450           0x00,
 451           
 452           /******************HID描述符************************/
 453           //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。
 454           0x09,
 455           
 456           //bDescriptorType字段。HID描述符的编号为0x21。
 457           0x21,
 458           
 459           //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。
 460           0x10,
 461           0x01,
 462           
 463           //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。
 464           0x21,
 465           
 466           //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。
 467           0x01,
 468           
 469           //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。
 470           0x22,
 471           
 472           //bDescriptorLength字段。下级描述符的长度。下级描述符为报告描述符。
 473           sizeof(ReportDescriptor)&0xFF,
 474           (sizeof(ReportDescriptor)>>8)&0xFF,
 475           
 476           /**********************输入端点描述符***********************/
 477           //bLength字段。端点描述符长度为7字节。
 478           0x07,
 479           
 480           //bDescriptorType字段。端点描述符编号为0x05。
 481           0x05,
 482           
 483           //bEndpointAddress字段。端点的地址。我们使用D12的输入端点1。
 484           //D7位表示数据方向，输入端点D7为1。所以输入端点1的地址为0x81。
 485           0x81,
 486           
 487           //bmAttributes字段。D1~D0为端点传输类型选择。
 488           //该端点为中断端点。中断端点的编号为3。其它位保留为0。
 489           0x03,
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 9   

 490           
 491           //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。
 492           //注意低字节在先。
 493           0x10,
 494           0x00,
 495           
 496           //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。
 497           0x0A,
 498           
 499           /**********************输出端点描述符***********************/
 500           //bLength字段。端点描述符长度为7字节。
 501           0x07,
 502           
 503           //bDescriptorType字段。端点描述符编号为0x05。
 504           0x05,
 505           
 506           //bEndpointAddress字段。端点的地址。我们使用D12的输出端点1。
 507           //D7位表示数据方向，输出端点D7为0。所以输出端点1的地址为0x01。
 508           0x01,
 509           
 510           //bmAttributes字段。D1~D0为端点传输类型选择。
 511           //该端点为中断端点。中断端点的编号为3。其它位保留为0。
 512           0x03,
 513           
 514           //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。
 515           //注意低字节在先。
 516           0x10,
 517           0x00,
 518           
 519           //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。
 520           0x0A
 521          };
 522          ////////////////////////配置描述符集合完毕//////////////////////////
 523          
 524          /************************语言ID的定义********************/
 525          code uint8 LanguageId[4]=
 526          {
 527           0x04, //本描述符的长度
 528           0x03, //字符串描述符
 529           //0x0409为美式英语的ID
 530           0x09,
 531           0x04
 532          };
 533          ////////////////////////语言ID完毕//////////////////////////////////
 534          
 535          /**************************************************/
 536          /*********        本转换结果来自         **********/
 537          /********* Http://computer00.21ic.org    **********/
 538          /*********        作者: 电脑圈圈         **********/
 539          /*********         欢迎大家使用          **********/
 540          /*********    版权所有，盗版请写明出处   **********/
 541          /**************************************************/
 542          
 543          //http://computer00.21ic.org/user1/2198/archives/2007/42769.html
 544          //字符串“电脑圈圈的USB专区 Http://group.ednchina.com/93/”的Unicode编码
 545          //8位小端格式
 546          code uint8 ManufacturerStringDescriptor[82]={
 547          82,         //该描述符的长度为82字节
 548          0x03,       //字符串描述符的类型编码为0x03
 549          0x35, 0x75, //电
 550          0x11, 0x81, //脑
 551          0x08, 0x57, //圈
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 10  

 552          0x08, 0x57, //圈
 553          0x84, 0x76, //的
 554          0x55, 0x00, //U
 555          0x53, 0x00, //S
 556          0x42, 0x00, //B
 557          0x13, 0x4e, //专
 558          0x3a, 0x53, //区
 559          0x20, 0x00, // 
 560          0x48, 0x00, //H
 561          0x74, 0x00, //t
 562          0x74, 0x00, //t
 563          0x70, 0x00, //p
 564          0x3a, 0x00, //:
 565          0x2f, 0x00, ///
 566          0x2f, 0x00, ///
 567          0x67, 0x00, //g
 568          0x72, 0x00, //r
 569          0x6f, 0x00, //o
 570          0x75, 0x00, //u
 571          0x70, 0x00, //p
 572          0x2e, 0x00, //.
 573          0x65, 0x00, //e
 574          0x64, 0x00, //d
 575          0x6e, 0x00, //n
 576          0x63, 0x00, //c
 577          0x68, 0x00, //h
 578          0x69, 0x00, //i
 579          0x6e, 0x00, //n
 580          0x61, 0x00, //a
 581          0x2e, 0x00, //.
 582          0x63, 0x00, //c
 583          0x6f, 0x00, //o
 584          0x6d, 0x00, //m
 585          0x2f, 0x00, ///
 586          0x39, 0x00, //9
 587          0x33, 0x00, //3
 588          0x2f, 0x00  ///
 589          };
 590          /////////////////////////厂商字符串结束/////////////////////////////
 591          
 592          //字符串“《圈圈教你玩USB》之带鼠标的USB键盘”的Unicode编码
 593          //8位小端格式
 594          code uint8 ProductStringDescriptor[42]={
 595          42,         //该描述符的长度为42字节
 596          0x03,       //字符串描述符的类型编码为0x03
 597          0x0a, 0x30, //《
 598          0x08, 0x57, //圈
 599          0x08, 0x57, //圈
 600          0x59, 0x65, //教
 601          0x60, 0x4f, //你
 602          0xa9, 0x73, //玩
 603          0x55, 0x00, //U
 604          0x53, 0x00, //S
 605          0x42, 0x00, //B
 606          0x0b, 0x30, //》
 607          0x4b, 0x4e, //之
 608          0x26, 0x5e, //带
 609          0x20, 0x9f, //鼠
 610          0x07, 0x68, //标
 611          0x84, 0x76, //的
 612          0x55, 0x00, //U
 613          0x53, 0x00, //S
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 11  

 614          0x42, 0x00, //B
 615          0x2e, 0x95, //键
 616          0xd8, 0x76  //盘
 617          };
 618          ////////////////////////产品字符串结束////////////////////////////
 619          
 620          //字符串“2008-07-15”的Unicode编码
 621          //8位小端格式
 622          code uint8 SerialNumberStringDescriptor[22]={
 623          22,         //该描述符的长度为22字节
 624          0x03,       //字符串描述符的类型编码为0x03
 625          0x32, 0x00, //2
 626          0x30, 0x00, //0
 627          0x30, 0x00, //0
 628          0x38, 0x00, //8
 629          0x2d, 0x00, //-
 630          0x30, 0x00, //0
 631          0x37, 0x00, //7
 632          0x2d, 0x00, //-
 633          0x31, 0x00, //1
 634          0x35, 0x00  //5
 635          };
 636          //////////////////////产品序列号字符串结束/////////////////////////
 637          
 638          /********************************************************************
 639          函数功能：延时x毫秒函数。
 640          入口参数：x：延时的毫秒数。
 641          返    回：无。
 642          备    注：无。
 643          ********************************************************************/
 644          void DelayXms(uint16 x)                
 645          {
 646   1       uint16 i;
 647   1       uint16 j;
 648   1       for(i=0;i<x;i++)
 649   1       for(j=0;j<227;j++); //循环语句延时
 650   1      }
 651          ////////////////////////End of function//////////////////////////////
 652          
 653          /********************************************************************
 654          函数功能：USB断开连接函数。
 655          入口参数：无。
 656          返    回：无。
 657          备    注：无。
 658          ********************************************************************/
 659          void UsbDisconnect(void)
 660          {
 661   1      #ifdef DEBUG0
 662   1       Prints("断开USB连接。\r\n");
 663   1      #endif
 664   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 665   1       D12WriteByte(0x06); //设置模式的第一字节
 666   1       D12WriteByte(0x47); //设置模式的第二字节
 667   1       DelayXms(1000);  //延迟1秒
 668   1      }
 669          ////////////////////////End of function//////////////////////////////
 670          
 671          /********************************************************************
 672          函数功能：USB连接函数。
 673          入口参数：无。
 674          返    回：无。
 675          备    注：无。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 12  

 676          ********************************************************************/
 677          void UsbConnect(void)
 678          {
 679   1      #ifdef DEBUG0
 680   1       Prints("连接USB。\r\n");
 681   1      #endif
 682   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 683   1       D12WriteByte(0x16); //设置模式的第一字节
 684   1       D12WriteByte(0x47); //设置模式的第二字节
 685   1      }
 686          ////////////////////////End of function//////////////////////////////
 687          
 688          /********************************************************************
 689          函数功能：总线挂起中断处理函数。
 690          入口参数：无。
 691          返    回：无。
 692          备    注：无。
 693          ********************************************************************/
 694          void UsbBusSuspend(void)
 695          {
 696   1      #ifdef DEBUG0
 697   1       Prints("USB总线挂起。\r\n");
 698   1      #endif
 699   1      }
 700          ////////////////////////End of function//////////////////////////////
 701          
 702          /********************************************************************
 703          函数功能：总线复位中断处理函数。
 704          入口参数：无。
 705          返    回：无。
 706          备    注：无。
 707          ********************************************************************/
 708          void UsbBusReset(void)
 709          {
 710   1      #ifdef DEBUG0
 711   1       Prints("USB总线复位。\r\n");
 712   1      #endif
 713   1       Ep1InIsBusy=0; //复位后端点1输入缓冲区空闲。
 714   1      }
 715          ////////////////////////End of function//////////////////////////////
 716          
 717          /********************************************************************
 718          函数功能：根据pData和SendLength将数据发送到端点0的函数。
 719          入口参数：无。
 720          返    回：无。
 721          备    注：无。
 722          ********************************************************************/
 723          void UsbEp0SendData(void)
 724          {
 725   1       //将数据写到端点中去准备发送
 726   1       //写之前要先判断一下需要发送的数据是否比端点0
 727   1       //最大长度大，如果超过端点大小，则一次只能发送
 728   1       //最大包长的数据。端点0的最大包长在DeviceDescriptor[7]
 729   1       if(SendLength>DeviceDescriptor[7])
 730   1       {
 731   2        //按最大包长度发送
 732   2        D12WriteEndpointBuffer(1,DeviceDescriptor[7],pSendData);
 733   2        //发送后剩余字节数减少最大包长
 734   2        SendLength-=DeviceDescriptor[7];
 735   2        //发送一次后指针位置要调整
 736   2        pSendData+= DeviceDescriptor[7];
 737   2       }
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 13  

 738   1       else
 739   1       {
 740   2        if(SendLength!=0)
 741   2        {
 742   3         //不够最大包长，可以直接发送
 743   3         D12WriteEndpointBuffer(1,SendLength,pSendData);
 744   3         //发送完毕后，SendLength长度变为0
 745   3         SendLength=0;
 746   3        }
 747   2        else //如果要发送的数据包长度为0
 748   2        {
 749   3         if(NeedZeroPacket==1) //如果需要发送0长度数据
 750   3         {
 751   4          D12WriteEndpointBuffer(1,0,pSendData); //发送0长度数据包
 752   4          NeedZeroPacket=0; //清需要发送0长度数据包标志
 753   4         }
 754   3        }
 755   2       }
 756   1      }
 757          ////////////////////////End of function//////////////////////////////
 758          
 759          /********************************************************************
 760          函数功能：端点0输出中断处理函数。
 761          入口参数：无。
 762          返    回：无。
 763          备    注：无。
 764          ********************************************************************/
 765          void UsbEp0Out(void)
 766          {
 767   1      #ifdef DEBUG0
 768   1       Prints("USB端点0输出中断。\r\n");
 769   1      #endif
 770   1       //读取端点0输出最后传输状态，该操作清除中断标志
 771   1       //并判断第5位是否为1，如果是，则说明是建立包
 772   1       if(D12ReadEndpointLastStatus(0)&0x20)
 773   1       {
 774   2        D12ReadEndpointBuffer(0,16,Buffer); //读建立过程数据
 775   2        D12AcknowledgeSetup(); //应答建立包
 776   2        D12ClearBuffer(); //清缓冲区
 777   2        //将缓冲数据填到设备请求的各字段中
 778   2        bmRequestType=Buffer[0];
 779   2        bRequest=Buffer[1];
 780   2        wValue=Buffer[2]+(((uint16)Buffer[3])<<8);
 781   2        wIndex=Buffer[4]+(((uint16)Buffer[5])<<8);
 782   2        wLength=Buffer[6]+(((uint16)Buffer[7])<<8);
 783   2        //下面的代码判断具体的请求，并根据不同的请求进行相关操作
 784   2        //如果D7位为1，则说明是输入请求
 785   2        if((bmRequestType&0x80)==0x80)
 786   2        {
 787   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 788   3         //0为标准请求，1为类请求，2为厂商请求。
 789   3         switch((bmRequestType>>5)&0x03)
 790   3         {
 791   4          case 0:  //标准请求
 792   4           #ifdef DEBUG0
 793   4            Prints("USB标准输入请求：");
 794   4           #endif
 795   4           //USB协议定义了几个标准输入请求，我们实现这些标准请求即可
 796   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 797   4           //事实上，我们还需要对接收者进行散转，因为不同的请求接收者
 798   4           //是不一样的。接收者在bmRequestType的D4~D0位中定义。
 799   4           //我们这里为了简化操作，有些就省略了对接收者的判断。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 14  

 800   4           //例如获取描述符的请求，只根据描述符的类型来区别。
 801   4           switch(bRequest)
 802   4           {
 803   5            case GET_CONFIGURATION: //获取配置
 804   5             #ifdef DEBUG0
 805   5              Prints("获取配置。\r\n");
 806   5             #endif
 807   5            break;
 808   5            
 809   5            case GET_DESCRIPTOR:  //获取描述符
 810   5             #ifdef DEBUG0
 811   5              Prints("获取描述符――");
 812   5             #endif
 813   5             //对描述符类型进行散转，对于全速设备，
 814   5             //标准请求只支持发送到设备的设备、配置、字符串三种描述符
 815   5             switch((wValue>>8)&0xFF)
 816   5              {
 817   6               case DEVICE_DESCRIPTOR: //设备描述符
 818   6                #ifdef DEBUG0
 819   6                 Prints("设备描述符。\r\n");
 820   6                #endif
 821   6                pSendData=DeviceDescriptor;  //需要发送的数据
 822   6                //判断请求的字节数是否比实际需要发送的字节数多
 823   6                //这里请求的是设备描述符，因此数据长度就是
 824   6                //DeviceDescriptor[0]。如果请求的比实际的长，
 825   6                //那么只返回实际长度的数据
 826   6                if(wLength>DeviceDescriptor[0])
 827   6                {
 828   7                 SendLength=DeviceDescriptor[0];
 829   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 830   7                 {
 831   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 832   8                 }
 833   7                }
 834   6                else
 835   6                {
 836   7                 SendLength=wLength;
 837   7                }
 838   6                //将数据通过EP0返回
 839   6                UsbEp0SendData();
 840   6               break;
 841   6               
 842   6               case CONFIGURATION_DESCRIPTOR:  //配置描述符
 843   6                #ifdef DEBUG0
 844   6                 Prints("配置描述符。\r\n");
 845   6                #endif
 846   6                pSendData=ConfigurationDescriptor; //需要发送的数据为配置描述符
 847   6                //判断请求的字节数是否比实际需要发送的字节数多
 848   6                //这里请求的是配置描述符集合，因此数据长度就是
 849   6                //ConfigurationDescriptor[3]*256+ConfigurationDescriptor[2]。
 850   6                //如果请求的比实际的长，那么只返回实际长度的数据
 851   6                SendLength=ConfigurationDescriptor[3];
 852   6                SendLength=SendLength*256+ConfigurationDescriptor[2];
 853   6                if(wLength>SendLength)
 854   6                {
 855   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 856   7                 {
 857   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 858   8                 }
 859   7                }
 860   6                else
 861   6                {
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 15  

 862   7                 SendLength=wLength;
 863   7                }
 864   6                //将数据通过EP0返回
 865   6                UsbEp0SendData();
 866   6               break;
 867   6               
 868   6               case STRING_DESCRIPTOR:  //字符串描述符
 869   6                #ifdef DEBUG0
 870   6                 Prints("字符串描述符");
 871   6                #endif
 872   6                switch(wValue&0xFF)  //根据wValue的低字节（索引值）散转
 873   6                {
 874   7                 case 0:  //获取语言ID
 875   7                  #ifdef DEBUG0
 876   7                   Prints("(语言ID)。\r\n");
 877   7                  #endif
 878   7                  pSendData=LanguageId;
 879   7                  SendLength=LanguageId[0];
 880   7                 break;
 881   7                 
 882   7                 case 1:  //厂商字符串的索引值为1，所以这里为厂商字符串
 883   7                 #ifdef DEBUG0
 884   7                   Prints("(厂商描述)。\r\n");
 885   7                  #endif
 886   7                  pSendData=ManufacturerStringDescriptor;
 887   7                  SendLength=ManufacturerStringDescriptor[0];
 888   7                 break;
 889   7                 
 890   7                 case 2:  //产品字符串的索引值为2，所以这里为产品字符串
 891   7                 #ifdef DEBUG0
 892   7                   Prints("(产品描述)。\r\n");
 893   7                  #endif
 894   7                  pSendData=ProductStringDescriptor;
 895   7                  SendLength=ProductStringDescriptor[0];
 896   7                 break;
 897   7                 
 898   7                 case 3:  //产品序列号的索引值为3，所以这里为序列号
 899   7                 #ifdef DEBUG0
 900   7                   Prints("(产品序列号)。\r\n");
 901   7                  #endif
 902   7                  pSendData=SerialNumberStringDescriptor;
 903   7                  SendLength=SerialNumberStringDescriptor[0];
 904   7                 break;
 905   7                 
 906   7                 default :
 907   7                  #ifdef DEBUG0
 908   7                   Prints("(未知的索引值)。\r\n");
 909   7                  #endif
 910   7                  //对于未知索引值的请求，返回一个0长度的包
 911   7                  SendLength=0;
 912   7                  NeedZeroPacket=1;
 913   7                 break;
 914   7                }
 915   6                //判断请求的字节数是否比实际需要发送的字节数多
 916   6                //如果请求的比实际的长，那么只返回实际长度的数据
 917   6                if(wLength>SendLength)
 918   6                {
 919   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 920   7                 {
 921   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 922   8                 }
 923   7                }
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 16  

 924   6                else
 925   6                {
 926   7                 SendLength=wLength;
 927   7                }
 928   6                //将数据通过EP0返回
 929   6                UsbEp0SendData();         
 930   6               break;
 931   6      
 932   6               case REPORT_DESCRIPTOR:  //报告描述符
 933   6                #ifdef DEBUG0
 934   6                 Prints("报告描述符。\r\n");
 935   6                #endif
 936   6                pSendData=ReportDescriptor; //需要发送的数据为报告描述符
 937   6                SendLength=sizeof(ReportDescriptor); //需要返回的数据长度         
 938   6                //判断请求的字节数是否比实际需要发送的字节数多
 939   6                //如果请求的比实际的长，那么只返回实际长度的数据
 940   6                if(wLength>SendLength)
 941   6                {
 942   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 943   7                 {
 944   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 945   8                 }
 946   7                }
 947   6                else
 948   6                {
 949   7                 SendLength=wLength;
 950   7                }
 951   6                //将数据通过EP0返回
 952   6                UsbEp0SendData();
 953   6               break;
 954   6                       
 955   6               default:  //其它描述符
 956   6                #ifdef DEBUG0
 957   6                 Prints("其他描述符，描述符代码：");
 958   6                 PrintHex((wValue>>8)&0xFF);
 959   6                 Prints("\r\n");
 960   6                #endif
 961   6               break;
 962   6              }
 963   5             break;
 964   5            
 965   5            case GET_INTERFACE: //获取接口
 966   5             #ifdef DEBUG0
 967   5              Prints("获取接口。\r\n");
 968   5             #endif
 969   5            break;
 970   5            
 971   5            case GET_STATUS: //获取状态
 972   5             #ifdef DEBUG0
 973   5              Prints("获取状态。\r\n");
 974   5             #endif
 975   5            break;
 976   5            
 977   5            case SYNCH_FRAME: //同步帧
 978   5             #ifdef DEBUG0
 979   5              Prints("同步帧。\r\n");
 980   5             #endif
 981   5            break;
 982   5            
 983   5            default:  //未定义的标准请求
 984   5             #ifdef DEBUG0
 985   5              Prints("错误：未定义的标准输入请求。\r\n");
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 17  

 986   5             #endif       
 987   5            break;
 988   5           }
 989   4          break;
 990   4          
 991   4          case 1:  //类请求
 992   4           #ifdef DEBUG0
 993   4            Prints("USB类输入请求：\r\n");
 994   4           #endif
 995   4          break;
 996   4          
 997   4          case 2:  //厂商请求
 998   4           #ifdef DEBUG0
 999   4            Prints("USB厂商输入请求：\r\n");
1000   4           #endif
1001   4          break;
1002   4          
1003   4          default: //未定义的请求。这里只显示一个报错信息。
1004   4           #ifdef DEBUG0
1005   4            Prints("错误：未定义的输入请求。\r\n");
1006   4           #endif
1007   4          break;
1008   4         }
1009   3        }
1010   2        //否则说明是输出请求
1011   2        else //if(bmRequestType&0x80==0x80)之else
1012   2        {
1013   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
1014   3         //0为标准请求，1为类请求，2为厂商请求。
1015   3         switch((bmRequestType>>5)&0x03)
1016   3         {
1017   4          case 0:  //标准请求
1018   4           #ifdef DEBUG0
1019   4            Prints("USB标准输出请求：");
1020   4           #endif
1021   4           //USB协议定义了几个标准输出请求，我们实现这些标准请求即可
1022   4           //请求的代码在bRequest中，对不同的请求代码进行散转
1023   4           switch(bRequest)
1024   4           {
1025   5            case CLEAR_FEATURE: //清除特性
1026   5             #ifdef DEBUG0
1027   5              Prints("清除特性。\r\n");
1028   5             #endif
1029   5            break;
1030   5            
1031   5            case SET_ADDRESS:  //设置地址
1032   5             #ifdef DEBUG0
1033   5              Prints("设置地址。地址为：");
1034   5              PrintHex(wValue&0xFF); //显示所设置的地址
1035   5              Prints("\r\n");
1036   5             #endif
1037   5             D12SetAddress(wValue&0xFF); //wValue中的低字节是设置的地址值
1038   5             //设置地址没有数据过程，直接进入到状态过程，返回一个0长度的数据包
1039   5             SendLength=0;
1040   5             NeedZeroPacket=1;
1041   5             //将数据通过EP0返回
1042   5             UsbEp0SendData();
1043   5            break;
1044   5            
1045   5            case SET_CONFIGURATION: //设置配置
1046   5             #ifdef DEBUG0
1047   5              Prints("设置配置。\r\n");
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 18  

1048   5             #endif
1049   5             //使能非0端点。非0端点只有在设置为非0的配置后才能使能。
1050   5             //wValue的低字节为配置的值，如果该值为非0，才能使能非0端点。
1051   5             //保存当前配置值
1052   5             ConfigValue=wValue&0xFF;
1053   5             D12SetEndpointEnable(ConfigValue);
1054   5             //返回一个0长度的状态数据包
1055   5             SendLength=0;
1056   5             NeedZeroPacket=1;
1057   5             //将数据通过EP0返回
1058   5             UsbEp0SendData();
1059   5            break;
1060   5            
1061   5            case SET_DESCRIPTOR: //设置描述符
1062   5             #ifdef DEBUG0
1063   5              Prints("设置描述符。\r\n");
1064   5             #endif
1065   5            break;
1066   5            
1067   5            case SET_FEATURE: //设置特性
1068   5             #ifdef DEBUG0
1069   5              Prints("设置特性。\r\n");
1070   5             #endif
1071   5            break;
1072   5      
1073   5            case SET_INTERFACE: //设置接口
1074   5             #ifdef DEBUG0
1075   5              Prints("设置接口。\r\n");
1076   5             #endif
1077   5            break;      
1078   5            
1079   5            default:  //未定义的标准请求
1080   5             #ifdef DEBUG0
1081   5              Prints("错误：未定义的标准输出请求。\r\n");
1082   5             #endif       
1083   5            break;
1084   5           }
1085   4          break;
1086   4          
1087   4          case 1:  //类请求
1088   4           #ifdef DEBUG0
1089   4            Prints("USB类输出请求：");
1090   4           #endif
1091   4           switch(bRequest)
1092   4           {
1093   5            case SET_IDLE:
1094   5             #ifdef DEBUG0
1095   5              Prints("设置空闲。\r\n");
1096   5             #endif
1097   5             //只需要返回一个0长度的数据包即可
1098   5             SendLength=0;
1099   5             NeedZeroPacket=1;
1100   5             //将数据通过EP0返回
1101   5             UsbEp0SendData();
1102   5            break;
1103   5            
1104   5            default:
1105   5             #ifdef DEBUG0
1106   5              Prints("未知请求。\r\n");
1107   5             #endif
1108   5            break;
1109   5           }
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 19  

1110   4          break;
1111   4          
1112   4          case 2:  //厂商请求
1113   4           #ifdef DEBUG0
1114   4            Prints("USB厂商输出请求：\r\n");
1115   4           #endif
1116   4          break;
1117   4          
1118   4          default: //未定义的请求。这里只显示一个报错信息。
1119   4           #ifdef DEBUG0
1120   4            Prints("错误：未定义的输出请求。\r\n");
1121   4           #endif
1122   4          break;
1123   4         }
1124   3        }
1125   2       }
1126   1       //普通数据输出
1127   1       else //if(D12ReadEndpointLastStatus(0)&0x20)之else
1128   1       {
1129   2        D12ReadEndpointBuffer(0,16,Buffer);
1130   2        D12ClearBuffer();
1131   2       }
1132   1      }
1133          ////////////////////////End of function//////////////////////////////
1134          
1135          /********************************************************************
1136          函数功能：端点0输入中断处理函数。
1137          入口参数：无。
1138          返    回：无。
1139          备    注：无。
1140          ********************************************************************/
1141          void UsbEp0In(void)
1142          {
1143   1      #ifdef DEBUG0
1144   1       Prints("USB端点0输入中断。\r\n");
1145   1      #endif
1146   1       //读最后发送状态，这将清除端点0的中断标志位
1147   1       D12ReadEndpointLastStatus(1);
1148   1       //发送剩余的字节数
1149   1       UsbEp0SendData();
1150   1      }
1151          ////////////////////////End of function//////////////////////////////
1152          
1153          /********************************************************************
1154          函数功能：端点1输出中断处理函数。
1155          入口参数：无。
1156          返    回：无。
1157          备    注：无。
1158          ********************************************************************/
1159          void UsbEp1Out(void)
1160          {
1161   1       uint8 Buf[2]; //用来保存2字节的输出报告，控制LED。
1162   1      #ifdef DEBUG0
1163   1       Prints("USB端点1输出中断。\r\n");
1164   1      #endif
1165   1       //读端点最后状态，这将清除端点1输出的中断标志位
1166   1       D12ReadEndpointLastStatus(2);
1167   1       //从端点1输出缓冲读回2字节数据
1168   1       D12ReadEndpointBuffer(2,2,Buf);
1169   1       //清除端点缓冲区
1170   1       D12ClearBuffer();
1171   1       //注意输出报告也增加了一字节的报告ID。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 20  

1172   1       //第1字节为报告ID，第2字节为LED状态，某位为1时，表示LED亮。
1173   1       //我们定义的键盘的报告ID为1，所以这里判断一下报告ID是否为1。
1174   1       if(Buf[0]==0x01)  //报告ID为1，即键盘的输出报告
1175   1       {
1176   2        LEDs=~Buf[1];
1177   2       }
1178   1      }
1179          ////////////////////////End of function//////////////////////////////
1180          
1181          /********************************************************************
1182          函数功能：端点1输入中断处理函数。
1183          入口参数：无。
1184          返    回：无。
1185          备    注：无。
1186          ********************************************************************/
1187          void UsbEp1In(void)
1188          {
1189   1      #ifdef DEBUG0
1190   1       Prints("USB端点1输入中断。\r\n");
1191   1      #endif
1192   1       //读最后发送状态，这将清除端点1输入的中断标志位
1193   1       D12ReadEndpointLastStatus(3);
1194   1       //端点1输入处于空闲状态
1195   1       Ep1InIsBusy=0;
1196   1      }
1197          ////////////////////////End of function//////////////////////////////
1198          
1199          /********************************************************************
1200          函数功能：端点2输出中断处理函数。
1201          入口参数：无。
1202          返    回：无。
1203          备    注：无。
1204          ********************************************************************/
1205          void UsbEp2Out(void)
1206          {
1207   1      #ifdef DEBUG0
1208   1       Prints("USB端点2输出中断。\r\n");
1209   1      #endif
1210   1      }
1211          ////////////////////////End of function//////////////////////////////
1212          
1213          /********************************************************************
1214          函数功能：端点2输入中断处理函数。
1215          入口参数：无。
1216          返    回：无。
1217          备    注：无。
1218          ********************************************************************/
1219          void UsbEp2In(void)
1220          {
1221   1      #ifdef DEBUG0
1222   1       Prints("USB端点2输入中断。\r\n");
1223   1      #endif
1224   1      }
1225          ////////////////////////End of function//////////////////////////////


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1265    ----
   CONSTANT SIZE    =   1084    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16       2
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 16:00:01 PAGE 21  

   IDATA SIZE       =     16    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
