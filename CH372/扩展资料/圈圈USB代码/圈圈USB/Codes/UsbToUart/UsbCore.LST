C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE USBCORE
OBJECT MODULE PLACED IN UsbCore.OBJ
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE UsbCore.c BROWSE DEBUG OBJECTEXTEND TABS(1)

stmt level    source

   1          /******************************************************************
   2             本程序只供学习使用，未经作者许可，不得用于其它任何用途
   3             
   4                  欢迎访问我的USB专区：http://group.ednchina.com/93/
   5                  欢迎访问我的blog：   http://www.ednchina.com/blog/computer00
   6                                       http://computer00.21ic.org
   7          
   8                  感谢PCB赞助商――电子园： http://bbs.cepark.com/
   9          
  10          UsbCore.c file
  11          
  12          作者：电脑圈圈
  13          建立日期: 2008.06.29
  14          修改日期: 2008.08.05
  15          版本：V1.1
  16          版权所有，盗版必究。
  17          Copyright(C) 电脑圈圈 2008-2018
  18          All rights reserved            
  19          *******************************************************************/
  20          
  21          #include "config.h"
  22          #include "pdiusbd12.h"
  23          #include "uart.h"
  24          #include "usbcore.h"
  25          
  26          idata uint8 Buffer[16];  //读端点0用的缓冲区
  27          
  28          
  29          //USB设备请求的各字段
  30          uint8  bmRequestType;
  31          uint8  bRequest;
  32          uint16 wValue;
  33          uint16 wIndex;
  34          uint16 wLength;
  35          //当前发送数据的位置
  36          uint8 * pSendData;
  37          //需要发送数据的长度
  38          uint16 SendLength;
  39          //是否需要发送0数据包的标志。在USB控制传输的数据过程中，
  40          //当返回的数据包字节数少于最大包长时，会认为数据过程结束。
  41          //当请求的字节数比实际需要返回的字节数长，而实际返回的字节
  42          //数又刚好是端点0大小的整数倍时，就需要返回一个0长度的数据包
  43          //来结束数据过程。因此这里增加一个标志，供程序决定是否需要返回
  44          //一个0长度的数据包。
  45          uint8 NeedZeroPacket;
  46          
  47          //当前的配置值。只有在设置非0配置后
  48          uint8 ConfigValue;
  49          
  50          //端点1缓冲是否忙的标志。当缓冲区中有数据时，该标志为真。
  51          //当缓冲区中空闲时，该标志为假。
  52          uint8 Ep1InIsBusy;
  53          
  54          //端点2缓冲是否忙的标志。当缓冲区中有数据时，该标志为真。
  55          //当缓冲区中空闲时，该标志为假。
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 2   

  56          uint8 Ep2InIsBusy;
  57          
  58          //LineCoding数组，用来保存波特率、停止位等串口属性。
  59          //初始化波特率为9600，1停止位，无校验，8数据位。
  60          uint8 LineCoding[7]={0x80,0x25,0x00,0x00,0x00,0x00,0x08};
  61          
  62          //USB设备描述符的定义
  63          code uint8 DeviceDescriptor[0x12]=  //设备描述符为18字节
  64          {
  65          //bLength字段。设备描述符的长度为18(0x12)字节
  66           0x12,
  67           
  68          //bDescriptorType字段。设备描述符的编号为0x01
  69           0x01,
  70           
  71          //bcdUSB字段。这里设置版本为USB1.1，即0x0110。
  72          //由于是小端结构，所以低字节在先，即0x10，0x01。
  73           0x10,
  74           0x01,
  75           
  76          //bDeviceClass字段。本设备必须在设备描述符中指定设备的类型，
  77          //否则，由于在配置集合中有两个接口，就会被系统认为是一个USB
  78          //复合设备，从而导致设备工作不正常。0x02为通信设备类的类代码。
  79           0x02,
  80           
  81          //bDeviceSubClass字段。必须为0。
  82           0x00,
  83           
  84          //bDeviceProtocol字段。必须为0。
  85           0x00,
  86           
  87          //bMaxPacketSize0字段。PDIUSBD12的端点0大小的16字节。
  88           0x10,
  89           
  90          //idVender字段。厂商ID号，我们这里取0x8888，仅供实验用。
  91          //实际产品不能随便使用厂商ID号，必须跟USB协会申请厂商ID号。
  92          //注意小端模式，低字节在先。
  93           0x88,
  94           0x88,
  95           
  96          //idProduct字段。产品ID号，由于是第七个实验，我们这里取0x0007。
  97          //注意小端模式，低字节应该在前。
  98           0x07,
  99           0x00,
 100           
 101          //bcdDevice字段。取1.0版，即0x0100。
 102          //小端模式，低字节在先。
 103           0x00,
 104           0x01,
 105           
 106          //iManufacturer字段。厂商字符串的索引值，为了方便记忆和管理，
 107          //字符串索引就从1开始。
 108           0x01,
 109          
 110          //iProduct字段。产品字符串的索引值。刚刚用了1，这里就取2吧。
 111          //注意字符串索引值不要使用相同的值。
 112           0x02,
 113           
 114          //iSerialNumber字段。设备的序列号字符串索引值。
 115          //这里取3就可以了。
 116           0x03,
 117          
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 3   

 118          //bNumConfigurations字段。该设备所具有的配置数。
 119          //我们只需要一种配置就行了，因此该值设置为1。
 120           0x01
 121          };
 122          //////////////////////////设备描述符完毕//////////////////////////////
 123          
 124          
 125          //USB配置描述符集合的定义
 126          //配置描述符总长度为9+9+5+5+4+5+7+9+7+7字节
 127          code uint8 ConfigurationDescriptor[9+9+5+5+4+5+7+9+7+7]=
 128          {
 129           /***************配置描述符***********************/
 130           //bLength字段。配置描述符的长度为9字节。
 131           0x09,
 132           
 133           //bDescriptorType字段。配置描述符编号为0x02。
 134           0x02,
 135           
 136           //wTotalLength字段。配置描述符集合的总长度，
 137           //包括配置描述符本身、接口描述符、类描述符、端点描述符等。
 138           sizeof(ConfigurationDescriptor)&0xFF, //低字节
 139           (sizeof(ConfigurationDescriptor)>>8)&0xFF, //高字节
 140           
 141           //bNumInterfaces字段。该配置包含的接口数，有两个接口。
 142           0x02,
 143           
 144           //bConfiguration字段。该配置的值为1。
 145           0x01,
 146           
 147           //iConfigurationz字段，该配置的字符串索引。这里没有，为0。
 148           0x00,
 149           
 150           //bmAttributes字段，该设备的属性。由于我们的板子是总线供电的，
 151           //并且我们不想实现远程唤醒的功能，所以该字段的值为0x80。
 152           0x80,
 153           
 154           //bMaxPower字段，该设备需要的最大电流量。由于我们的板子
 155           //需要的电流不到100mA，因此我们这里设置为100mA。由于每单位
 156           //电流为2mA，所以这里设置为50(0x32)。
 157           0x32,
 158           
 159           /*******************CDC类接口描述符*********************/
 160           //bLength字段。接口描述符的长度为9字节。
 161           0x09,
 162           
 163           //bDescriptorType字段。接口描述符的编号为0x04。
 164           0x04,
 165           
 166           //bInterfaceNumber字段。该接口的编号，第一个接口，编号为0。
 167           0x00,
 168           
 169           //bAlternateSetting字段。该接口的备用编号，为0。
 170           0x00,
 171           
 172           //bNumEndpoints字段。非0端点的数目。CDC接口只使用一个中断
 173           //输入端点。
 174           0x01,
 175           
 176           //bInterfaceClass字段。该接口所使用的类。CDC类的类代码为0x02。
 177           0x02,
 178           
 179           //bInterfaceSubClass字段。该接口所使用的子类。要实现USB转串口，
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 4   

 180           //就必须使用Abstract Control Model（抽象控制模型）子类。它的
 181           //编号为0x02。
 182           0x02,
 183           
 184           //bInterfaceProtocol字段。使用Common AT Commands（通用AT命令）
 185           //协议。该协议的编号为0x01。
 186           0x01,
 187           
 188           //iConfiguration字段。该接口的字符串索引值。这里没有，为0。
 189           0x00,
 190           
 191           /***************以下为功能描述符****************/
 192           /********* Header Functional Descriptor ********/
 193           //bFunctionLength字段。该描述符长度为5字节
 194           0x05,
 195           
 196           //bDescriptorType字段。描述符类型为类特殊接口（CS_INTERFACE）
 197           //编号为0x24。
 198           0x24,
 199           
 200           //bDescriptorSubtype字段。描述符子类为Header Functional Descriptor
 201           //编号为0x00。
 202           0x00,
 203           
 204           //bcdCDC字段。CDC版本号，为0x0110（低字节在先）
 205           0x10,
 206           0x01,
 207           
 208           /**** Call Management Functional Descriptor ****/
 209           //bFunctionLength字段。该描述符长度为5字节
 210           0x05,
 211           
 212           //bDescriptorType字段。描述符类型为类特殊接口（CS_INTERFACE）
 213           //编号为0x24。
 214           0x24,
 215           
 216           //bDescriptorSubtype字段。描述符子类为Call Management 
 217           //functional descriptor，编号为0x01。
 218           0x01,
 219           
 220           //bmCapabilities字段。设备自己不管理call management
 221           0x00,
 222           
 223           //bDataInterface字段。没有数据类接口用作call management
 224           0x00,
 225          
 226           /*** Abstract Control Management Functional Descriptor ***/
 227           //bFunctionLength字段。该描述符长度为4字节
 228           0x04,
 229           
 230           //bDescriptorType字段。描述符类型为类特殊接口（CS_INTERFACE）
 231           //编号为0x24。
 232           0x24,
 233           
 234           //bDescriptorSubtype字段。描述符子类为Abstract Control 
 235           //Management functional descriptor，编号为0x02。
 236           0x02,
 237          
 238           //bmCapabilities字段。支持Set_Line_Coding、Set_Control_Line_State、
 239           //Get_Line_Coding请求和Serial_State通知
 240           0x02,
 241          
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 5   

 242           /***  Union Functional Descriptor  **/
 243           //bFunctionLength字段。该描述符长度为5字节。 
 244           0x05,
 245          
 246           //bDescriptorType字段。描述符类型为类特殊接口（CS_INTERFACE）
 247           //编号为0x24。
 248           0x24,
 249           
 250           //bDescriptorSubtype字段。描述符子类为
 251           //Union functional descriptor，编号为0x06。
 252           0x06,
 253           
 254           //MasterInterface字段。这里为前面编号为0的CDC接口。
 255           0x00,
 256           
 257           //SlaveInterface字段，这里为接下来编号为1的数据类接口。
 258           0x01,
 259          
 260           /***********  以下为接口0的端点描述符  *******/
 261           //bLength字段。端点描述符长度为7字节。
 262           0x07,
 263           
 264           //bDescriptorType字段。端点描述符编号为0x05。
 265           0x05,
 266           
 267           //bEndpointAddress字段。端点的地址。这里使用D12的输入端点1。
 268           //D7位表示数据方向，输入端点D7为1。所以输入端点1的地址为0x81。
 269           0x81,
 270           
 271           //bmAttributes字段。D1~D0为端点传输类型选择。
 272           //该端点为中断端点。中断端点的编号为3。其它位保留为0。
 273           0x03,
 274           
 275           //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。
 276           //注意低字节在先。
 277           0x10,
 278           0x00,
 279           
 280           //bInterval字段。端点查询的时间，这里设置为10个帧时间，即10ms。
 281           0x0A,
 282           
 283           /*********  以下为接口1（数据接口）的接口描述符  *********/
 284           //bLength字段。接口描述符的长度为9字节。
 285           0x09,
 286           
 287           //bDescriptorType字段。接口描述符的编号为0x04。
 288           0x04,
 289           
 290           //bInterfaceNumber字段。该接口的编号，第二个接口，编号为1。
 291           0x01,
 292           
 293           //bAlternateSetting字段。该接口的备用编号，为0。
 294           0x00,
 295           
 296           //bNumEndpoints字段。非0端点的数目。该设备需要使用一对批量端点，设置为2。
 297           0x02,
 298           
 299           //bInterfaceClass字段。该接口所使用的类。数据类接口的代码为0x0A。
 300           0x0A,
 301           
 302           //bInterfaceSubClass字段。该接口所使用的子类为0。
 303           0x00,
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 6   

 304           
 305           //bInterfaceProtocol字段。该接口所使用的协议为0。
 306           0x00,
 307           
 308           //iConfiguration字段。该接口的字符串索引值。这里没有，为0。
 309           0x00,
 310           
 311           /*****  以下为接口1（数据类接口）的端点描述符  *****/
 312           /*************** 批量输入端点2描述符 ******************/
 313           //bLength字段。端点描述符长度为7字节。
 314           0x07,
 315           
 316           //bDescriptorType字段。端点描述符编号为0x05。
 317           0x05,
 318           
 319           //bEndpointAddress字段。端点的地址。我们使用D12的输入端点2。
 320           //D7位表示数据方向，输入端点D7为1。所以输入端点2的地址为0x82。
 321           0x82,
 322           
 323           //bmAttributes字段。D1~D0为端点传输类型选择。
 324           //该端点为批量端点，批量端点的编号为0x02。其它位保留为0。
 325           0x02,
 326           
 327           //wMaxPacketSize字段。该端点的最大包长。端点2的最大包长为64字节。
 328           //注意低字节在先。
 329           0x40,
 330           0x00,
 331           
 332           //bInterval字段。端点查询的时间，这里对批量端点无效。
 333           0x00,
 334           
 335           /*************** 批量输出端点2描述符 ******************/
 336           //bLength字段。端点描述符长度为7字节。
 337           0x07,
 338           
 339           //bDescriptorType字段。端点描述符编号为0x05。
 340           0x05,
 341           
 342           //bEndpointAddress字段。端点的地址。我们使用D12的输出端点2。
 343           //D7位表示数据方向，输出端点D7为0。所以输出端点2的地址为0x02。
 344           0x02,
 345           
 346           //bmAttributes字段。D1~D0为端点传输类型选择。
 347           //该端点为批量端点，批量端点的编号为0x02。其它位保留为0。
 348           0x02,
 349           
 350           //wMaxPacketSize字段。该端点的最大包长。端点2的最大包长为64字节。
 351           //注意低字节在先。
 352           0x40,
 353           0x00,
 354           
 355           //bInterval字段。端点查询的时间，这里对批量端点无效。
 356           0x00
 357          };
 358          ////////////////////////配置描述符集合完毕//////////////////////////
 359          
 360          /************************语言ID的定义********************/
 361          code uint8 LanguageId[4]=
 362          {
 363           0x04, //本描述符的长度
 364           0x03, //字符串描述符
 365           //0x0409为美式英语的ID
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 7   

 366           0x09,
 367           0x04
 368          };
 369          ////////////////////////语言ID完毕//////////////////////////////////
 370          
 371          /**************************************************/
 372          /*********        本转换结果来自         **********/
 373          /********* Http://computer00.21ic.org    **********/
 374          /*********        作者: 电脑圈圈         **********/
 375          /*********         欢迎大家使用          **********/
 376          /*********    版权所有，盗版请写明出处   **********/
 377          /**************************************************/
 378          
 379          //http://computer00.21ic.org/user1/2198/archives/2007/42769.html
 380          //字符串“电脑圈圈的USB专区 Http://group.ednchina.com/93/”的Unicode编码
 381          //8位小端格式
 382          code uint8 ManufacturerStringDescriptor[82]={
 383          82,         //该描述符的长度为82字节
 384          0x03,       //字符串描述符的类型编码为0x03
 385          0x35, 0x75, //电
 386          0x11, 0x81, //脑
 387          0x08, 0x57, //圈
 388          0x08, 0x57, //圈
 389          0x84, 0x76, //的
 390          0x55, 0x00, //U
 391          0x53, 0x00, //S
 392          0x42, 0x00, //B
 393          0x13, 0x4e, //专
 394          0x3a, 0x53, //区
 395          0x20, 0x00, // 
 396          0x48, 0x00, //H
 397          0x74, 0x00, //t
 398          0x74, 0x00, //t
 399          0x70, 0x00, //p
 400          0x3a, 0x00, //:
 401          0x2f, 0x00, ///
 402          0x2f, 0x00, ///
 403          0x67, 0x00, //g
 404          0x72, 0x00, //r
 405          0x6f, 0x00, //o
 406          0x75, 0x00, //u
 407          0x70, 0x00, //p
 408          0x2e, 0x00, //.
 409          0x65, 0x00, //e
 410          0x64, 0x00, //d
 411          0x6e, 0x00, //n
 412          0x63, 0x00, //c
 413          0x68, 0x00, //h
 414          0x69, 0x00, //i
 415          0x6e, 0x00, //n
 416          0x61, 0x00, //a
 417          0x2e, 0x00, //.
 418          0x63, 0x00, //c
 419          0x6f, 0x00, //o
 420          0x6d, 0x00, //m
 421          0x2f, 0x00, ///
 422          0x39, 0x00, //9
 423          0x33, 0x00, //3
 424          0x2f, 0x00  ///
 425          };
 426          /////////////////////////厂商字符串结束/////////////////////////////
 427          
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 8   

 428          //字符串“《圈圈教你玩USB》之 USB转串口”的Unicode编码
 429          //8位小端格式
 430          code uint8 ProductStringDescriptor[38]={
 431          38,         //该描述符的长度为38字节
 432          0x03,       //字符串描述符的类型编码为0x03
 433          0x0a, 0x30, //《
 434          0x08, 0x57, //圈
 435          0x08, 0x57, //圈
 436          0x59, 0x65, //教
 437          0x60, 0x4f, //你
 438          0xa9, 0x73, //玩
 439          0x55, 0x00, //U
 440          0x53, 0x00, //S
 441          0x42, 0x00, //B
 442          0x0b, 0x30, //》
 443          0x4b, 0x4e, //之
 444          0x20, 0x00, // 
 445          0x55, 0x00, //U
 446          0x53, 0x00, //S
 447          0x42, 0x00, //B
 448          0x6c, 0x8f, //转
 449          0x32, 0x4e, //串
 450          0xe3, 0x53  //口
 451          };
 452          ////////////////////////产品字符串结束////////////////////////////
 453          
 454          //字符串“2008-08-03”的Unicode编码
 455          //8位小端格式
 456          code uint8 SerialNumberStringDescriptor[22]={
 457          22,         //该描述符的长度为22字节
 458          0x03,       //字符串描述符的类型编码为0x03
 459          0x32, 0x00, //2
 460          0x30, 0x00, //0
 461          0x30, 0x00, //0
 462          0x38, 0x00, //8
 463          0x2d, 0x00, //-
 464          0x30, 0x00, //0
 465          0x38, 0x00, //8
 466          0x2d, 0x00, //-
 467          0x30, 0x00, //0
 468          0x33, 0x00  //3
 469          };
 470          //////////////////////产品序列号字符串结束/////////////////////////
 471          
 472          /********************************************************************
 473          函数功能：延时x毫秒函数。
 474          入口参数：x：延时的毫秒数。
 475          返    回：无。
 476          备    注：无。
 477          ********************************************************************/
 478          void DelayXms(uint16 x)                
 479          {
 480   1       uint16 i;
 481   1       uint16 j;
 482   1       for(i=0;i<x;i++)
 483   1       for(j=0;j<227;j++); //循环语句延时
 484   1      }
 485          ////////////////////////End of function//////////////////////////////
 486          
 487          /********************************************************************
 488          函数功能：USB断开连接函数。
 489          入口参数：无。
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 9   

 490          返    回：无。
 491          备    注：无。
 492          ********************************************************************/
 493          void UsbDisconnect(void)
 494          {
 495   1      #ifdef DEBUG0
               Prints("断开USB连接。\r\n");
              #endif
 498   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 499   1       D12WriteByte(0x06); //设置模式的第一字节
 500   1       D12WriteByte(0x47); //设置模式的第二字节
 501   1       DelayXms(1000);  //延迟1秒
 502   1      }
 503          ////////////////////////End of function//////////////////////////////
 504          
 505          /********************************************************************
 506          函数功能：USB连接函数。
 507          入口参数：无。
 508          返    回：无。
 509          备    注：无。
 510          ********************************************************************/
 511          void UsbConnect(void)
 512          {
 513   1      #ifdef DEBUG0
               Prints("连接USB。\r\n");
              #endif
 516   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 517   1       D12WriteByte(0x16); //设置模式的第一字节
 518   1       D12WriteByte(0x47); //设置模式的第二字节
 519   1      }
 520          ////////////////////////End of function//////////////////////////////
 521          
 522          /********************************************************************
 523          函数功能：总线挂起中断处理函数。
 524          入口参数：无。
 525          返    回：无。
 526          备    注：无。
 527          ********************************************************************/
 528          void UsbBusSuspend(void)
 529          {
 530   1      #ifdef DEBUG0
               Prints("USB总线挂起。\r\n");
              #endif
 533   1      }
 534          ////////////////////////End of function//////////////////////////////
 535          
 536          /********************************************************************
 537          函数功能：总线复位中断处理函数。
 538          入口参数：无。
 539          返    回：无。
 540          备    注：无。
 541          ********************************************************************/
 542          void UsbBusReset(void)
 543          {
 544   1      #ifdef DEBUG0
               Prints("USB总线复位。\r\n");
              #endif
 547   1       Ep1InIsBusy=0; //复位后端点1输入缓冲区空闲。
 548   1       Ep2InIsBusy=0; //复位后端点2输入缓冲区空闲。
 549   1       UartBufferOutputPoint=0;
 550   1       UartBufferInputPoint=0;
 551   1       UartByteCount=0;
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 10  

 552   1       UsbEp2ByteCount=0;
 553   1       UsbEp2BufferOutputPoint=0;
 554   1      }
 555          ////////////////////////End of function//////////////////////////////
 556          
 557          /********************************************************************
 558          函数功能：根据pData和SendLength将数据发送到端点0的函数。
 559          入口参数：无。
 560          返    回：无。
 561          备    注：无。
 562          ********************************************************************/
 563          void UsbEp0SendData(void)
 564          {
 565   1       //将数据写到端点中去准备发送
 566   1       //写之前要先判断一下需要发送的数据是否比端点0
 567   1       //最大长度大，如果超过端点大小，则一次只能发送
 568   1       //最大包长的数据。端点0的最大包长在DeviceDescriptor[7]
 569   1       if(SendLength>DeviceDescriptor[7])
 570   1       {
 571   2        //按最大包长度发送
 572   2        D12WriteEndpointBuffer(1,DeviceDescriptor[7],pSendData);
 573   2        //发送后剩余字节数减少最大包长
 574   2        SendLength-=DeviceDescriptor[7];
 575   2        //发送一次后指针位置要调整
 576   2        pSendData+= DeviceDescriptor[7];
 577   2       }
 578   1       else
 579   1       {
 580   2        if(SendLength!=0)
 581   2        {
 582   3         //不够最大包长，可以直接发送
 583   3         D12WriteEndpointBuffer(1,SendLength,pSendData);
 584   3         //发送完毕后，SendLength长度变为0
 585   3         SendLength=0;
 586   3        }
 587   2        else //如果要发送的数据包长度为0
 588   2        {
 589   3         if(NeedZeroPacket==1) //如果需要发送0长度数据
 590   3         {
 591   4          D12WriteEndpointBuffer(1,0,pSendData); //发送0长度数据包
 592   4          NeedZeroPacket=0; //清需要发送0长度数据包标志
 593   4         }
 594   3        }
 595   2       }
 596   1      }
 597          ////////////////////////End of function//////////////////////////////
 598          
 599          /********************************************************************
 600          函数功能：USB端点0数据过程数据处理函数。
 601          入口参数：无。
 602          返    回：无。
 603          备    注：该函数用来处理0端点控制传输的数据或状态过程。
 604          ********************************************************************/
 605          void UsbEp0DataOut(void)
 606          {
 607   1       //由于本程序中只有一个请求输出数据，所以可以直接使用if语句判断条件，
 608   1       //如果有很多请求的话，使用if语句就不方便了，而应该使用switch语句散转。
 609   1       if((bmRequestType==0x21)&&(bRequest==SET_LINE_CODING))
 610   1       {
 611   2        uint32 BitRate;
 612   2        uint8 Length;
 613   2        
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 11  

 614   2        //读回7字节的LineCoding值
 615   2        Length=D12ReadEndpointBuffer(0,7,LineCoding);
 616   2        D12ClearBuffer(); //清除缓冲区
 617   2        
 618   2        if(Length==7) //如果长度正确
 619   2        {
 620   3         //从LineCoding计算设置的波特率
 621   3         BitRate=LineCoding[3];
 622   3         BitRate=(BitRate<<8)+LineCoding[2];
 623   3         BitRate=(BitRate<<8)+LineCoding[1];
 624   3         BitRate=(BitRate<<8)+LineCoding[0];
 625   3        #ifdef DEBUG0
                 Prints("波特率设置为：");
                 PrintLongInt(BitRate);
                 Prints("bps\r\n");
                #endif
 630   3         //设置串口的波特率
 631   3         BitRate=UartSetBitRate(BitRate);
 632   3         
 633   3         //将LineCoding的值设置为实际的设置值
 634   3         LineCoding[0]=BitRate&0xFF;
 635   3         LineCoding[1]=(BitRate>>8)&0xFF;
 636   3         LineCoding[2]=(BitRate>>16)&0xFF;
 637   3         LineCoding[3]=(BitRate>>24)&0xFF;
 638   3        
 639   3         //由于只支持一停止位、无校验、8位数据位，
 640   3         //所以固定这些数据。
 641   3         LineCoding[4]=0x00;
 642   3         LineCoding[5]=0x00;
 643   3         LineCoding[6]=0x08;
 644   3        }
 645   2        //返回0长度的状态数据包。
 646   2        D12WriteEndpointBuffer(1,0,0);
 647   2       }
 648   1       else  //其它请求的数据过程或者状态过程
 649   1       {
 650   2        D12ReadEndpointBuffer(0,16,Buffer);
 651   2        D12ClearBuffer();
 652   2       }
 653   1      }
 654          ////////////////////////End of function//////////////////////////////
 655          
 656          /********************************************************************
 657          函数功能：端点0输出中断处理函数。
 658          入口参数：无。
 659          返    回：无。
 660          备    注：无。
 661          ********************************************************************/
 662          void UsbEp0Out(void)
 663          {
 664   1      #ifdef DEBUG0
               Prints("USB端点0输出中断。\r\n");
              #endif
 667   1       //读取端点0输出最后传输状态，该操作清除中断标志
 668   1       //并判断第5位是否为1，如果是，则说明是建立包
 669   1       if(D12ReadEndpointLastStatus(0)&0x20)
 670   1       {
 671   2        D12ReadEndpointBuffer(0,16,Buffer); //读建立过程数据
 672   2        D12AcknowledgeSetup(); //应答建立包
 673   2        D12ClearBuffer(); //清缓冲区
 674   2        //将缓冲数据填到设备请求的各字段中
 675   2        bmRequestType=Buffer[0];
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 12  

 676   2        bRequest=Buffer[1];
 677   2        wValue=Buffer[2]+(((uint16)Buffer[3])<<8);
 678   2        wIndex=Buffer[4]+(((uint16)Buffer[5])<<8);
 679   2        wLength=Buffer[6]+(((uint16)Buffer[7])<<8);
 680   2        //下面的代码判断具体的请求，并根据不同的请求进行相关操作
 681   2        //如果D7位为1，则说明是输入请求
 682   2        if((bmRequestType&0x80)==0x80)
 683   2        {
 684   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 685   3         //0为标准请求，1为类请求，2为厂商请求。
 686   3         switch((bmRequestType>>5)&0x03)
 687   3         {
 688   4          case 0:  //标准请求
 689   4           #ifdef DEBUG0
                    Prints("USB标准输入请求：");
                   #endif
 692   4           //USB协议定义了几个标准输入请求，我们实现这些标准请求即可
 693   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 694   4           //事实上，我们还需要对接收者进行散转，因为不同的请求接收者
 695   4           //是不一样的。接收者在bmRequestType的D4~D0位中定义。
 696   4           //我们这里为了简化操作，有些就省略了对接收者的判断。
 697   4           //例如获取描述符的请求，只根据描述符的类型来区别。
 698   4           switch(bRequest)
 699   4           {
 700   5            case GET_CONFIGURATION: //获取配置
 701   5             #ifdef DEBUG0
                      Prints("获取配置。\r\n");
                     #endif
 704   5            break;
 705   5            
 706   5            case GET_DESCRIPTOR:  //获取描述符
 707   5             #ifdef DEBUG0
                      Prints("获取描述符――");
                     #endif
 710   5             //对描述符类型进行散转，对于全速设备，
 711   5             //标准请求只支持发送到设备的设备、配置、字符串三种描述符
 712   5             switch((wValue>>8)&0xFF)
 713   5              {
 714   6               case DEVICE_DESCRIPTOR: //设备描述符
 715   6                #ifdef DEBUG0
                         Prints("设备描述符。\r\n");
                        #endif
 718   6                pSendData=DeviceDescriptor;  //需要发送的数据
 719   6                //判断请求的字节数是否比实际需要发送的字节数多
 720   6                //这里请求的是设备描述符，因此数据长度就是
 721   6                //DeviceDescriptor[0]。如果请求的比实际的长，
 722   6                //那么只返回实际长度的数据
 723   6                if(wLength>DeviceDescriptor[0])
 724   6                {
 725   7                 SendLength=DeviceDescriptor[0];
 726   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 727   7                 {
 728   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 729   8                 }
 730   7                }
 731   6                else
 732   6                {
 733   7                 SendLength=wLength;
 734   7                }
 735   6                //将数据通过EP0返回
 736   6                UsbEp0SendData();
 737   6               break;
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 13  

 738   6               
 739   6               case CONFIGURATION_DESCRIPTOR:  //配置描述符
 740   6                #ifdef DEBUG0
                         Prints("配置描述符。\r\n");
                        #endif
 743   6                pSendData=ConfigurationDescriptor; //需要发送的数据为配置描述符
 744   6                //判断请求的字节数是否比实际需要发送的字节数多
 745   6                //这里请求的是配置描述符集合，因此数据长度就是
 746   6                //ConfigurationDescriptor[3]*256+ConfigurationDescriptor[2]。
 747   6                //如果请求的比实际的长，那么只返回实际长度的数据
 748   6                SendLength=ConfigurationDescriptor[3];
 749   6                SendLength=SendLength*256+ConfigurationDescriptor[2];
 750   6                if(wLength>SendLength)
 751   6                {
 752   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 753   7                 {
 754   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 755   8                 }
 756   7                }
 757   6                else
 758   6                {
 759   7                 SendLength=wLength;
 760   7                }
 761   6                //将数据通过EP0返回
 762   6                UsbEp0SendData();
 763   6               break;
 764   6               
 765   6               case STRING_DESCRIPTOR:  //字符串描述符
 766   6                #ifdef DEBUG0
                         Prints("字符串描述符");
                        #endif
 769   6                switch(wValue&0xFF)  //根据wValue的低字节（索引值）散转
 770   6                {
 771   7                 case 0:  //获取语言ID
 772   7                  #ifdef DEBUG0
                           Prints("(语言ID)。\r\n");
                          #endif
 775   7                  pSendData=LanguageId;
 776   7                  SendLength=LanguageId[0];
 777   7                 break;
 778   7                 
 779   7                 case 1:  //厂商字符串的索引值为1，所以这里为厂商字符串
 780   7                 #ifdef DEBUG0
                           Prints("(厂商描述)。\r\n");
                          #endif
 783   7                  pSendData=ManufacturerStringDescriptor;
 784   7                  SendLength=ManufacturerStringDescriptor[0];
 785   7                 break;
 786   7                 
 787   7                 case 2:  //产品字符串的索引值为2，所以这里为产品字符串
 788   7                 #ifdef DEBUG0
                           Prints("(产品描述)。\r\n");
                          #endif
 791   7                  pSendData=ProductStringDescriptor;
 792   7                  SendLength=ProductStringDescriptor[0];
 793   7                 break;
 794   7                 
 795   7                 case 3:  //产品序列号的索引值为3，所以这里为序列号
 796   7                 #ifdef DEBUG0
                           Prints("(产品序列号)。\r\n");
                          #endif
 799   7                  pSendData=SerialNumberStringDescriptor;
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 14  

 800   7                  SendLength=SerialNumberStringDescriptor[0];
 801   7                 break;
 802   7                 
 803   7                 default :
 804   7                  #ifdef DEBUG0
                           Prints("(未知的索引值)。\r\n");
                          #endif
 807   7                  //对于未知索引值的请求，返回一个0长度的包
 808   7                  SendLength=0;
 809   7                  NeedZeroPacket=1;
 810   7                 break;
 811   7                }
 812   6                //判断请求的字节数是否比实际需要发送的字节数多
 813   6                //如果请求的比实际的长，那么只返回实际长度的数据
 814   6                if(wLength>SendLength)
 815   6                {
 816   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 817   7                 {
 818   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 819   8                 }
 820   7                }
 821   6                else
 822   6                {
 823   7                 SendLength=wLength;
 824   7                }
 825   6                //将数据通过EP0返回
 826   6                UsbEp0SendData();         
 827   6               break;
 828   6                       
 829   6               default:  //其它描述符
 830   6                #ifdef DEBUG0
                         Prints("其他描述符，描述符代码：");
                         PrintHex((wValue>>8)&0xFF);
                         Prints("\r\n");
                        #endif
 835   6               break;
 836   6              }
 837   5             break;
 838   5            
 839   5            case GET_INTERFACE: //获取接口
 840   5             #ifdef DEBUG0
                      Prints("获取接口。\r\n");
                     #endif
 843   5            break;
 844   5            
 845   5            case GET_STATUS: //获取状态
 846   5             #ifdef DEBUG0
                      Prints("获取状态。\r\n");
                     #endif
 849   5            break;
 850   5            
 851   5            case SYNCH_FRAME: //同步帧
 852   5             #ifdef DEBUG0
                      Prints("同步帧。\r\n");
                     #endif
 855   5            break;
 856   5            
 857   5            default:  //未定义的标准请求
 858   5             #ifdef DEBUG0
                      Prints("错误：未定义的标准输入请求。\r\n");
                     #endif       
 861   5            break;
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 15  

 862   5           }
 863   4          break;
 864   4          
 865   4          case 1:  //类请求
 866   4           #ifdef DEBUG0
                    Prints("USB类输入请求：");
                   #endif
 869   4           switch(bRequest)
 870   4           {
 871   5            case GET_LINE_CODING: //GET_LINE_CODING请求
 872   5             #ifdef DEBUG0
                      Prints("GET_LINE_CODING。\r\n");
                     #endif
 875   5             SendLength=0x07; //7字节的LineCoding
 876   5             pSendData=LineCoding;
 877   5            break;
 878   5            
 879   5            case SERIAL_STATE: //获取SERIAL_STATE请求
 880   5             //本来该请求是获取串口状态的，但是圈圈在实际使用中，
 881   5             //发现主机从来未发送过该请求，因而这里并不对它进行处理，
 882   5             //只是简单地发送一个0长度的数据包。
 883   5             #ifdef DEBUG0
                      Prints("SERIAL_STATE。\r\n");
                     #endif       
 886   5             SendLength=0;
 887   5             NeedZeroPacket=1;
 888   5            break;
 889   5            
 890   5            default:
 891   5             #ifdef DEBUG0
                      Prints("未知类请求。\r\n");
                     #endif
 894   5             SendLength=0;
 895   5             NeedZeroPacket=1;
 896   5            break;
 897   5           }
 898   4          //判断请求的字节数是否比实际需要发送的字节数多
 899   4          //如果请求的比实际的长，那么只返回实际长度的数据
 900   4          if(wLength>SendLength)
 901   4          {
 902   5           if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 903   5           {
 904   6            NeedZeroPacket=1; //需要返回0长度的数据包
 905   6           }
 906   5          }
 907   4          else
 908   4          {
 909   5           SendLength=wLength;
 910   5          }
 911   4          //将数据通过EP0返回
 912   4          UsbEp0SendData();
 913   4          break;
 914   4          
 915   4          case 2:  //厂商请求
 916   4           #ifdef DEBUG0
                    Prints("USB厂商输入请求：\r\n");
                   #endif
 919   4          break;
 920   4          
 921   4          default: //未定义的请求。这里只显示一个报错信息。
 922   4           #ifdef DEBUG0
                    Prints("错误：未定义的输入请求。\r\n");
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 16  

                   #endif
 925   4          break;
 926   4         }
 927   3        }
 928   2        //否则说明是输出请求
 929   2        else //if(bmRequestType&0x80==0x80)之else
 930   2        {
 931   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 932   3         //0为标准请求，1为类请求，2为厂商请求。
 933   3         switch((bmRequestType>>5)&0x03)
 934   3         {
 935   4          case 0:  //标准请求
 936   4           #ifdef DEBUG0
                    Prints("USB标准输出请求：");
                   #endif
 939   4           //USB协议定义了几个标准输出请求，我们实现这些标准请求即可
 940   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 941   4           switch(bRequest)
 942   4           {
 943   5            case CLEAR_FEATURE: //清除特性
 944   5             #ifdef DEBUG0
                      Prints("清除特性。\r\n");
                     #endif
 947   5            break;
 948   5            
 949   5            case SET_ADDRESS:  //设置地址
 950   5             #ifdef DEBUG0
                      Prints("设置地址。地址为：");
                      PrintHex(wValue&0xFF); //显示所设置的地址
                      Prints("\r\n");
                     #endif
 955   5             D12SetAddress(wValue&0xFF); //wValue中的低字节是设置的地址值
 956   5             //设置地址没有数据过程，直接进入到状态过程，返回一个0长度的数据包
 957   5             SendLength=0;
 958   5             NeedZeroPacket=1;
 959   5             //将数据通过EP0返回
 960   5             UsbEp0SendData();
 961   5            break;
 962   5            
 963   5            case SET_CONFIGURATION: //设置配置
 964   5             #ifdef DEBUG0
                      Prints("设置配置。\r\n");
                     #endif
 967   5             //使能非0端点。非0端点只有在设置为非0的配置后才能使能。
 968   5             //wValue的低字节为配置的值，如果该值为非0，才能使能非0端点。
 969   5             //保存当前配置值
 970   5             ConfigValue=wValue&0xFF;
 971   5             D12SetEndpointEnable(ConfigValue);
 972   5             //返回一个0长度的状态数据包
 973   5             SendLength=0;
 974   5             NeedZeroPacket=1;
 975   5             //将数据通过EP0返回
 976   5             UsbEp0SendData();
 977   5            break;
 978   5            
 979   5            case SET_DESCRIPTOR: //设置描述符
 980   5             #ifdef DEBUG0
                      Prints("设置描述符。\r\n");
                     #endif
 983   5            break;
 984   5            
 985   5            case SET_FEATURE: //设置特性
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 17  

 986   5             #ifdef DEBUG0
                      Prints("设置特性。\r\n");
                     #endif
 989   5            break;
 990   5      
 991   5            case SET_INTERFACE: //设置接口
 992   5             #ifdef DEBUG0
                      Prints("设置接口。\r\n");
                     #endif
 995   5            break;      
 996   5            
 997   5            default:  //未定义的标准请求
 998   5             #ifdef DEBUG0
                      Prints("错误：未定义的标准输出请求。\r\n");
                     #endif       
1001   5            break;
1002   5           }
1003   4          break;
1004   4          
1005   4          case 1:  //类请求
1006   4           #ifdef DEBUG0
                    Prints("USB类输出请求：");
                   #endif
1009   4           switch(bRequest)
1010   4           {
1011   5            case SET_CONTROL_LINE_STATE:
1012   5             #ifdef DEBUG0
                      Prints("SET_CONTROL_LINE_STATE。\r\n");
                     #endif
1015   5             //该请求没有数据输出阶段，其中wValue字段的D0位表示DTR，
1016   5             //D1位表示RTS。但是我们的板上的串口并没有这两引脚，因而
1017   5             //对该请求我们仅是简单地返回一个0长度的状态过程数据包即可
1018   5             SendLength=0;
1019   5             NeedZeroPacket=1;
1020   5             //将数据通过EP0返回
1021   5             UsbEp0SendData();
1022   5            break;
1023   5            
1024   5            case SET_LINE_CODING:
1025   5            //该请求设置串口的属性，但是实际的数据并不在设置过程发出，
1026   5            //而是在之后的数据过程发出。这里不用做任何处理，在数据过程
1027   5            //完成后返回0长度的状态包。
1028   5             #ifdef DEBUG0
                      Prints("SET_LINE_CODING。\r\n");
                     #endif
1031   5             break;
1032   5             
1033   5            default:
1034   5             #ifdef DEBUG0
                      Prints("未知请求。\r\n");
                     #endif
1037   5            break;
1038   5           }
1039   4          break;
1040   4          
1041   4          case 2:  //厂商请求
1042   4           #ifdef DEBUG0
                    Prints("USB厂商输出请求：\r\n");
                   #endif
1045   4          break;
1046   4          
1047   4          default: //未定义的请求。这里只显示一个报错信息。
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 18  

1048   4           #ifdef DEBUG0
                    Prints("错误：未定义的输出请求。\r\n");
                   #endif
1051   4          break;
1052   4         }
1053   3        }
1054   2       }
1055   1       //普通数据输出
1056   1       else //if(D12ReadEndpointLastStatus(0)&0x20)之else
1057   1       {
1058   2        UsbEp0DataOut();
1059   2       }
1060   1      }
1061          ////////////////////////End of function//////////////////////////////
1062          
1063          /********************************************************************
1064          函数功能：端点0输入中断处理函数。
1065          入口参数：无。
1066          返    回：无。
1067          备    注：无。
1068          ********************************************************************/
1069          void UsbEp0In(void)
1070          {
1071   1      #ifdef DEBUG0
               Prints("USB端点0输入中断。\r\n");
              #endif
1074   1       //读最后发送状态，这将清除端点0的中断标志位
1075   1       D12ReadEndpointLastStatus(1);
1076   1       //发送剩余的字节数
1077   1       UsbEp0SendData();
1078   1      }
1079          ////////////////////////End of function//////////////////////////////
1080          
1081          /********************************************************************
1082          函数功能：端点1输出中断处理函数。
1083          入口参数：无。
1084          返    回：无。
1085          备    注：无。
1086          ********************************************************************/
1087          void UsbEp1Out(void)
1088          {
1089   1      #ifdef DEBUG0
               Prints("USB端点1输出中断。\r\n");
              #endif
1092   1       //读端点最后状态，这将清除端点1输出的中断标志位
1093   1       D12ReadEndpointLastStatus(2);
1094   1       //清除端点缓冲区
1095   1       D12ClearBuffer();
1096   1      }
1097          ////////////////////////End of function//////////////////////////////
1098          
1099          /********************************************************************
1100          函数功能：端点1输入中断处理函数。
1101          入口参数：无。
1102          返    回：无。
1103          备    注：无。
1104          ********************************************************************/
1105          void UsbEp1In(void)
1106          {
1107   1      #ifdef DEBUG0
               Prints("USB端点1输入中断。\r\n");
              #endif
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 19  

1110   1       //读最后发送状态，这将清除端点1输入的中断标志位
1111   1       D12ReadEndpointLastStatus(3);
1112   1       //端点1输入处于空闲状态
1113   1       Ep1InIsBusy=0;
1114   1      }
1115          ////////////////////////End of function//////////////////////////////
1116          
1117          /********************************************************************
1118          函数功能：端点2输出中断处理函数。
1119          入口参数：无。
1120          返    回：无。
1121          备    注：无。
1122          ********************************************************************/
1123          void UsbEp2Out(void)
1124          {
1125   1      #ifdef DEBUG0
               Prints("USB端点2输出中断。\r\n");
              #endif
1128   1       //如果缓冲区中的数据还未通过串口发送完毕，则暂时不处理该中断，直接返回。
1129   1       if(UsbEp2ByteCount!=0) return;
1130   1      
1131   1      /* 旧版代码，有BUG。修改在函数返回时清除中断 
1132   1       //读最后接收状态，这将清除端点2输出的中断标志位。
1133   1       //注意端点2有个双缓冲机制，在清除中断之前，先检查是否两个缓冲区
1134   1       //是否全满了，如果两个缓冲区全满的话，就不用清除中断标志。只有当
1135   1       //两个缓冲区不全满的时候才需要清除中断标志。
1136   1       if((D12ReadEndpointStatus(4)&0x60)!=0x60)
1137   1       {
1138   1        D12ReadEndpointLastStatus(4);
1139   1       }
1140   1      */
1141   1      
1142   1       //读取端点2的数据。返回值为实际读到的数据字节数
1143   1       UsbEp2ByteCount=D12ReadEndpointBuffer(4,BUF_LEN,UsbEp2Buffer);
1144   1       //清除端点缓冲区
1145   1       D12ClearBuffer();
1146   1       
1147   1       //输出位置设为0
1148   1       UsbEp2BufferOutputPoint=0;
1149   1      
1150   1       //当两个缓冲区中都没有数据时，才能清除中断标志
1151   1       if(!(D12ReadEndpointStatus(4)&0x60))
1152   1       {
1153   2        //读最后发送状态，这将清除端点2输入的中断标志位
1154   2        D12ReadEndpointLastStatus(4);
1155   2       }
1156   1      }
1157          ////////////////////////End of function//////////////////////////////
1158          
1159          /********************************************************************
1160          函数功能：端点2输入中断处理函数。
1161          入口参数：无。
1162          返    回：无。
1163          备    注：无。
1164          ********************************************************************/
1165          void UsbEp2In(void)
1166          {
1167   1      #ifdef DEBUG0
               Prints("USB端点2输入中断。\r\n");
              #endif
1170   1       //读最后发送状态，这将清除端点2输入的中断标志位
1171   1       D12ReadEndpointLastStatus(5);
C51 COMPILER V7.06   USBCORE                                                               04/13/2009 14:23:24 PAGE 20  

1172   1       //端点2输入处于空闲状态
1173   1       Ep2InIsBusy=0;
1174   1      }
1175          ////////////////////////End of function//////////////////////////////


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1105    ----
   CONSTANT SIZE    =    231    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24       5
   IDATA SIZE       =     16    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
