C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE USBCORE
OBJECT MODULE PLACED IN UsbCore.OBJ
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE UsbCore.c BROWSE DEBUG OBJECTEXTEND TABS(1)

stmt level    source

   1          /******************************************************************
   2             本程序只供学习使用，未经作者许可，不得用于其它任何用途
   3             
   4                  欢迎访问我的USB专区：http://group.ednchina.com/93/
   5                  欢迎访问我的blog：   http://www.ednchina.com/blog/computer00
   6                                       http://computer00.21ic.org
   7          
   8                  感谢PCB赞助商――电子园： http://bbs.cepark.com/
   9          
  10          UsbCore.c file
  11          
  12          作者：电脑圈圈
  13          建立日期: 2008.06.29
  14          修改日期: 2008.07.10
  15          版本：V1.1
  16          版权所有，盗版必究。
  17          Copyright(C) 电脑圈圈 2008-2018
  18          All rights reserved            
  19          *******************************************************************/
  20          
  21          #include "config.h"
  22          #include "pdiusbd12.h"
  23          #include "uart.h"
  24          #include "usbcore.h"
  25          
  26          idata uint8 Buffer[16];  //读端点0用的缓冲区
  27          
  28          //USB设备请求的各字段
  29          uint8  bmRequestType;
  30          uint8  bRequest;
  31          uint16 wValue;
  32          uint16 wIndex;
  33          uint16 wLength;
  34          //当前发送数据的位置
  35          uint8 * pSendData;
  36          //需要发送数据的长度
  37          uint16 SendLength;
  38          //是否需要发送0数据包的标志。在USB控制传输的数据过程中，
  39          //当返回的数据包字节数少于最大包长时，会认为数据过程结束。
  40          //当请求的字节数比实际需要返回的字节数长，而实际返回的字节
  41          //数又刚好是端点0大小的整数倍时，就需要返回一个0长度的数据包
  42          //来结束数据过程。因此这里增加一个标志，供程序决定是否需要返回
  43          //一个0长度的数据包。
  44          uint8 NeedZeroPacket;
  45          
  46          //当前的配置值。只有在设置非0配置后
  47          uint8 ConfigValue;
  48          
  49          //端点1缓冲是否忙的标志。当缓冲区中有数据时，该标志为真。
  50          //当缓冲区中空闲时，该标志为假。
  51          uint8 Ep1InIsBusy;
  52          
  53          //USB设备描述符的定义
  54          code uint8 DeviceDescriptor[0x12]=  //设备描述符为18字节
  55          {
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 2   

  56          //bLength字段。设备描述符的长度为18(0x12)字节
  57           0x12,
  58           
  59          //bDescriptorType字段。设备描述符的编号为0x01
  60           0x01,
  61           
  62          //bcdUSB字段。这里设置版本为USB1.1，即0x0110。
  63          //由于是小端结构，所以低字节在先，即0x10，0x01。
  64           0x10,
  65           0x01,
  66           
  67          //bDeviceClass字段。我们不在设备描述符中定义设备类，
  68          //而在接口描述符中定义设备类，所以该字段的值为0。
  69           0x00,
  70           
  71          //bDeviceSubClass字段。bDeviceClass字段为0时，该字段也为0。
  72           0x00,
  73           
  74          //bDeviceProtocol字段。bDeviceClass字段为0时，该字段也为0。
  75           0x00,
  76           
  77          //bMaxPacketSize0字段。PDIUSBD12的端点0大小的16字节。
  78           0x10,
  79           
  80          //idVender字段。厂商ID号，我们这里取0x8888，仅供实验用。
  81          //实际产品不能随便使用厂商ID号，必须跟USB协会申请厂商ID号。
  82          //注意小端模式，低字节在先。
  83           0x88,
  84           0x88,
  85           
  86          //idProduct字段。产品ID号，由于是第一个实验，我们这里取0x0001。
  87          //注意小端模式，低字节应该在前。
  88           0x01,
  89           0x00,
  90           
  91          //bcdDevice字段。我们这个USB鼠标刚开始做，就叫它1.0版吧，即0x0100。
  92          //小端模式，低字节在先。
  93           0x00,
  94           0x01,
  95           
  96          //iManufacturer字段。厂商字符串的索引值，为了方便记忆和管理，
  97          //字符串索引就从1开始吧。
  98           0x01,
  99          
 100          //iProduct字段。产品字符串的索引值。刚刚用了1，这里就取2吧。
 101          //注意字符串索引值不要使用相同的值。
 102           0x02,
 103           
 104          //iSerialNumber字段。设备的序列号字符串索引值。
 105          //这里取3就可以了。
 106           0x03,
 107          
 108          //bNumConfigurations字段。该设备所具有的配置数。
 109          //我们只需要一种配置就行了，因此该值设置为1。
 110           0x01
 111          };
 112          //////////////////////////设备描述符完毕//////////////////////////////
 113          
 114          //USB报告描述符的定义
 115          code uint8 ReportDescriptor[]=
 116          {
 117           //每行开始的第一字节为该条目的前缀，前缀的格式为：
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 3   

 118           //D7~D4：bTag。D3~D2：bType；D1~D0：bSize。以下分别对每个条目注释。
 119           
 120           //这是一个全局（bType为1）条目，选择用途页为普通桌面Generic Desktop Page(0x01)
 121           //后面跟一字节数据（bSize为1），后面的字节数就不注释了，
 122           //自己根据bSize来判断。
 123           0x05, 0x01, // USAGE_PAGE (Generic Desktop)
 124           
 125           //这是一个局部（bType为2）条目，说明接下来的应用集合用途用于鼠标
 126           0x09, 0x02, // USAGE (Mouse)
 127           
 128           //这是一个主条目（bType为0）条目，开集合，后面跟的数据0x01表示
 129           //该集合是一个应用集合。它的性质在前面由用途页和用途定义为
 130           //普通桌面用的鼠标。
 131           0xa1, 0x01, // COLLECTION (Application)
 132           
 133           //这是一个局部条目。说明用途为指针集合
 134           0x09, 0x01, //   USAGE (Pointer)
 135           
 136           //这是一个主条目，开集合，后面跟的数据0x00表示该集合是一个
 137           //物理集合，用途由前面的局部条目定义为指针集合。
 138           0xa1, 0x00, //   COLLECTION (Physical)
 139           
 140           //这是一个全局条目，选择用途页为按键（Button Page(0x09)）
 141           0x05, 0x09, //     USAGE_PAGE (Button)
 142           
 143           //这是一个局部条目，说明用途的最小值为1。实际上是鼠标左键。
 144           0x19, 0x01, //     USAGE_MINIMUM (Button 1)
 145           
 146           //这是一个局部条目，说明用途的最大值为3。实际上是鼠标中键。
 147           0x29, 0x03, //     USAGE_MAXIMUM (Button 3)
 148           
 149           //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值啦）
 150           //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。
 151           0x15, 0x00, //     LOGICAL_MINIMUM (0)
 152           
 153           //这是一个全局条目，说明逻辑值最大为1。
 154           0x25, 0x01, //     LOGICAL_MAXIMUM (1)
 155           
 156           //这是一个全局条目，说明数据域的数量为三个。
 157           0x95, 0x03, //     REPORT_COUNT (3)
 158           
 159           //这是一个全局条目，说明每个数据域的长度为1个bit。
 160           0x75, 0x01, //     REPORT_SIZE (1)
 161           
 162           //这是一个主条目，说明有3个长度为1bit的数据域（数量和长度
 163           //由前面的两个全局条目所定义）用来做为输入，
 164           //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示
 165           //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。
 166           //这样定义的结果就是，第一个数据域bit0表示按键1（左键）是否按下，
 167           //第二个数据域bit1表示按键2（右键）是否按下，第三个数据域bit2表示
 168           //按键3（中键）是否按下。
 169           0x81, 0x02, //     INPUT (Data,Var,Abs)
 170           
 171           //这是一个全局条目，说明数据域数量为1个
 172           0x95, 0x01, //     REPORT_COUNT (1)
 173           
 174           //这是一个全局条目，说明每个数据域的长度为5bit。
 175           0x75, 0x05, //     REPORT_SIZE (5)
 176           
 177           //这是一个主条目，输入用，由前面两个全局条目可知，长度为5bit，
 178           //数量为1个。它的属性为常量（即返回的数据一直是0）。
 179           //这个只是为了凑齐一个字节（前面用了3个bit）而填充的一些数据
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 4   

 180           //而已，所以它是没有实际用途的。
 181           0x81, 0x03, //     INPUT (Cnst,Var,Abs)
 182           
 183           //这是一个全局条目，选择用途页为普通桌面Generic Desktop Page(0x01)
 184           0x05, 0x01, //     USAGE_PAGE (Generic Desktop)
 185           
 186           //这是一个局部条目，说明用途为X轴
 187           0x09, 0x30, //     USAGE (X)
 188           
 189           //这是一个局部条目，说明用途为Y轴
 190           0x09, 0x31, //     USAGE (Y)
 191           
 192           //这是一个局部条目，说明用途为滚轮
 193           0x09, 0x38, //     USAGE (Wheel)
 194           
 195           //下面两个为全局条目，说明返回的逻辑最小和最大值。
 196           //因为鼠标指针移动时，通常是用相对值来表示的，
 197           //相对值的意思就是，当指针移动时，只发送移动量。
 198           //往右移动时，X值为正；往下移动时，Y值为正。
 199           //对于滚轮，当滚轮往上滚时，值为正。
 200           0x15, 0x81, //     LOGICAL_MINIMUM (-127)
 201           0x25, 0x7f, //     LOGICAL_MAXIMUM (127)
 202           
 203           //这是一个全局条目，说明数据域的长度为8bit。
 204           0x75, 0x08, //     REPORT_SIZE (8)
 205           
 206           //这是一个全局条目，说明数据域的个数为3个。
 207           0x95, 0x03, //     REPORT_COUNT (3)
 208           
 209           //这是一个主条目。它说明这三个8bit的数据域是输入用的，
 210           //属性为：Data,Var,Rel。Data说明数据是可以变的，Var说明
 211           //这些数据域是独立的，即第一个8bit表示X轴，第二个8bit表示
 212           //Y轴，第三个8bit表示滚轮。Rel表示这些值是相对值。
 213           0x81, 0x06, //     INPUT (Data,Var,Rel)
 214           
 215           //下面这两个主条目用来关闭前面的集合用。
 216           //我们开了两个集合，所以要关两次。bSize为0，所以后面没数据。
 217           0xc0,       //   END_COLLECTION
 218           0xc0        // END_COLLECTION
 219          };
 220          //通过上面的报告描述符的定义，我们知道返回的输入报告具有4字节。
 221          //第一字节的低3位用来表示按键是否按下的，高5位为常数0，无用。
 222          //第二字节表示X轴改的变量，第三字节表示Y轴的改变量，第四字节表示
 223          //滚轮的改变量。我们在中断端点1中应该要按照上面的格式返回实际的
 224          //鼠标数据。
 225          ///////////////////////////报告描述符完毕////////////////////////////
 226          
 227          //USB配置描述符集合的定义
 228          //配置描述符总长度为9+9+9+7字节
 229          code uint8 ConfigurationDescriptor[9+9+9+7]=
 230          {
 231           /***************配置描述符***********************/
 232           //bLength字段。配置描述符的长度为9字节。
 233           0x09,
 234           
 235           //bDescriptorType字段。配置描述符编号为0x02。
 236           0x02,
 237           
 238           //wTotalLength字段。配置描述符集合的总长度，
 239           //包括配置描述符本身、接口描述符、类描述符、端点描述符等。
 240           sizeof(ConfigurationDescriptor)&0xFF, //低字节
 241           (sizeof(ConfigurationDescriptor)>>8)&0xFF, //高字节
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 5   

 242           
 243           //bNumInterfaces字段。该配置包含的接口数，只有一个接口。
 244           0x01,
 245           
 246           //bConfiguration字段。该配置的值为1。
 247           0x01,
 248           
 249           //iConfigurationz字段，该配置的字符串索引。这里没有，为0。
 250           0x00,
 251           
 252           //bmAttributes字段，该设备的属性。由于我们的板子是总线供电的，
 253           //并且我们不想实现远程唤醒的功能，所以该字段的值为0x80。
 254           0x80,
 255           
 256           //bMaxPower字段，该设备需要的最大电流量。由于我们的板子
 257           //需要的电流不到100mA，因此我们这里设置为100mA。由于每单位
 258           //电流为2mA，所以这里设置为50(0x32)。
 259           0x32,
 260           
 261           /*******************接口描述符*********************/
 262           //bLength字段。接口描述符的长度为9字节。
 263           0x09,
 264           
 265           //bDescriptorType字段。接口描述符的编号为0x04。
 266           0x04,
 267           
 268           //bInterfaceNumber字段。该接口的编号，第一个接口，编号为0。
 269           0x00,
 270           
 271           //bAlternateSetting字段。该接口的备用编号，为0。
 272           0x00,
 273           
 274           //bNumEndpoints字段。非0端点的数目。由于USB鼠标只需要一个
 275           //中断输入端点，因此该值为1。
 276           0x01,
 277           
 278           //bInterfaceClass字段。该接口所使用的类。USB鼠标是HID类，
 279           //HID类的编码为0x03。
 280           0x03,
 281           
 282           //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中，
 283           //只规定了一种子类：支持BIOS引导启动的子类。
 284           //USB键盘、鼠标属于该子类，子类代码为0x01。
 285           0x01,
 286           
 287           //bInterfaceProtocol字段。如果子类为支持引导启动的子类，
 288           //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。
 289           0x02,
 290           
 291           //iConfiguration字段。该接口的字符串索引值。这里没有，为0。
 292           0x00,
 293           
 294           /******************HID描述符************************/
 295           //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。
 296           0x09,
 297           
 298           //bDescriptorType字段。HID描述符的编号为0x21。
 299           0x21,
 300           
 301           //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。
 302           0x10,
 303           0x01,
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 6   

 304           
 305           //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。
 306           0x21,
 307           
 308           //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。
 309           0x01,
 310           
 311           //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。
 312           0x22,
 313           
 314           //bDescriptorLength字段。下级描述符的长度。下级描述符为报告描述符。
 315           sizeof(ReportDescriptor)&0xFF,
 316           (sizeof(ReportDescriptor)>>8)&0xFF,
 317           
 318           /**********************端点描述符***********************/
 319           //bLength字段。端点描述符长度为7字节。
 320           0x07,
 321           
 322           //bDescriptorType字段。端点描述符编号为0x05。
 323           0x05,
 324           
 325           //bEndpointAddress字段。端点的地址。我们使用D12的输入端点1。
 326           //D7位表示数据方向，输入端点D7为1。所以输入端点1的地址为0x81。
 327           0x81,
 328           
 329           //bmAttributes字段。D1~D0为端点传输类型选择。
 330           //该端点为中断端点。中断端点的编号为3。其它位保留为0。
 331           0x03,
 332           
 333           //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。
 334           //注意低字节在先。
 335           0x10,
 336           0x00,
 337           
 338           //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。
 339           0x0A
 340          };
 341          ////////////////////////配置描述符集合完毕//////////////////////////
 342          
 343          /************************语言ID的定义********************/
 344          code uint8 LanguageId[4]=
 345          {
 346           0x04, //本描述符的长度
 347           0x03, //字符串描述符
 348           //0x0409为美式英语的ID
 349           0x09,
 350           0x04
 351          };
 352          ////////////////////////语言ID完毕//////////////////////////////////
 353          
 354          /**************************************************/
 355          /*********        本转换结果来自         **********/
 356          /********* Http://computer00.21ic.org    **********/
 357          /*********        作者: 电脑圈圈         **********/
 358          /*********         欢迎大家使用          **********/
 359          /*********    版权所有，盗版请写明出处   **********/
 360          /**************************************************/
 361          
 362          //http://computer00.21ic.org/user1/2198/archives/2007/42769.html
 363          //字符串“电脑圈圈的USB专区 Http://group.ednchina.com/93/”的Unicode编码
 364          //8位小端格式
 365          code uint8 ManufacturerStringDescriptor[82]={
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 7   

 366          82,         //该描述符的长度为82字节
 367          0x03,       //字符串描述符的类型编码为0x03
 368          0x35, 0x75, //电
 369          0x11, 0x81, //脑
 370          0x08, 0x57, //圈
 371          0x08, 0x57, //圈
 372          0x84, 0x76, //的
 373          0x55, 0x00, //U
 374          0x53, 0x00, //S
 375          0x42, 0x00, //B
 376          0x13, 0x4e, //专
 377          0x3a, 0x53, //区
 378          0x20, 0x00, // 
 379          0x48, 0x00, //H
 380          0x74, 0x00, //t
 381          0x74, 0x00, //t
 382          0x70, 0x00, //p
 383          0x3a, 0x00, //:
 384          0x2f, 0x00, ///
 385          0x2f, 0x00, ///
 386          0x67, 0x00, //g
 387          0x72, 0x00, //r
 388          0x6f, 0x00, //o
 389          0x75, 0x00, //u
 390          0x70, 0x00, //p
 391          0x2e, 0x00, //.
 392          0x65, 0x00, //e
 393          0x64, 0x00, //d
 394          0x6e, 0x00, //n
 395          0x63, 0x00, //c
 396          0x68, 0x00, //h
 397          0x69, 0x00, //i
 398          0x6e, 0x00, //n
 399          0x61, 0x00, //a
 400          0x2e, 0x00, //.
 401          0x63, 0x00, //c
 402          0x6f, 0x00, //o
 403          0x6d, 0x00, //m
 404          0x2f, 0x00, ///
 405          0x39, 0x00, //9
 406          0x33, 0x00, //3
 407          0x2f, 0x00  ///
 408          };
 409          /////////////////////////厂商字符串结束/////////////////////////////
 410          
 411          //字符串“《圈圈教你玩USB》之USB鼠标”的Unicode编码
 412          //8位小端格式
 413          code uint8 ProductStringDescriptor[34]={
 414          34,         //该描述符的长度为34字节
 415          0x03,       //字符串描述符的类型编码为0x03
 416          0x0a, 0x30, //《
 417          0x08, 0x57, //圈
 418          0x08, 0x57, //圈
 419          0x59, 0x65, //教
 420          0x60, 0x4f, //你
 421          0xa9, 0x73, //玩
 422          0x55, 0x00, //U
 423          0x53, 0x00, //S
 424          0x42, 0x00, //B
 425          0x0b, 0x30, //》
 426          0x4b, 0x4e, //之
 427          0x55, 0x00, //U
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 8   

 428          0x53, 0x00, //S
 429          0x42, 0x00, //B
 430          0x20, 0x9f, //鼠
 431          0x07, 0x68  //标
 432          };
 433          ////////////////////////产品字符串结束////////////////////////////
 434          
 435          //字符串“2008-07-07”的Unicode编码
 436          //8位小端格式
 437          code uint8 SerialNumberStringDescriptor[22]={
 438          22,         //该描述符的长度为22字节
 439          0x03,       //字符串描述符的类型编码为0x03
 440          0x32, 0x00, //2
 441          0x30, 0x00, //0
 442          0x30, 0x00, //0
 443          0x38, 0x00, //8
 444          0x2d, 0x00, //-
 445          0x30, 0x00, //0
 446          0x37, 0x00, //7
 447          0x2d, 0x00, //-
 448          0x30, 0x00, //0
 449          0x37, 0x00  //7
 450          };
 451          //////////////////////产品序列号字符串结束/////////////////////////
 452          
 453          /********************************************************************
 454          函数功能：延时x毫秒函数。
 455          入口参数：x：延时的毫秒数。
 456          返    回：无。
 457          备    注：无。
 458          ********************************************************************/
 459          void DelayXms(uint16 x)                
 460          {
 461   1       uint16 i;
 462   1       uint16 j;
 463   1       for(i=0;i<x;i++)
 464   1       for(j=0;j<227;j++); //循环语句延时
 465   1      }
 466          ////////////////////////End of function//////////////////////////////
 467          
 468          /********************************************************************
 469          函数功能：USB断开连接函数。
 470          入口参数：无。
 471          返    回：无。
 472          备    注：无。
 473          ********************************************************************/
 474          void UsbDisconnect(void)
 475          {
 476   1      #ifdef DEBUG0
 477   1       Prints("断开USB连接。\r\n");
 478   1      #endif
 479   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 480   1       D12WriteByte(0x06); //设置模式的第一字节
 481   1       D12WriteByte(0x47); //设置模式的第二字节
 482   1       DelayXms(1000);  //延迟1秒
 483   1      }
 484          ////////////////////////End of function//////////////////////////////
 485          
 486          /********************************************************************
 487          函数功能：USB连接函数。
 488          入口参数：无。
 489          返    回：无。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 9   

 490          备    注：无。
 491          ********************************************************************/
 492          void UsbConnect(void)
 493          {
 494   1      #ifdef DEBUG0
 495   1       Prints("连接USB。\r\n");
 496   1      #endif
 497   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 498   1       D12WriteByte(0x16); //设置模式的第一字节
 499   1       D12WriteByte(0x47); //设置模式的第二字节
 500   1      }
 501          ////////////////////////End of function//////////////////////////////
 502          
 503          /********************************************************************
 504          函数功能：总线挂起中断处理函数。
 505          入口参数：无。
 506          返    回：无。
 507          备    注：无。
 508          ********************************************************************/
 509          void UsbBusSuspend(void)
 510          {
 511   1      #ifdef DEBUG0
 512   1       Prints("USB总线挂起。\r\n");
 513   1      #endif
 514   1      }
 515          ////////////////////////End of function//////////////////////////////
 516          
 517          /********************************************************************
 518          函数功能：总线复位中断处理函数。
 519          入口参数：无。
 520          返    回：无。
 521          备    注：无。
 522          ********************************************************************/
 523          void UsbBusReset(void)
 524          {
 525   1      #ifdef DEBUG0
 526   1       Prints("USB总线复位。\r\n");
 527   1      #endif
 528   1       Ep1InIsBusy=0; //复位后端点1输入缓冲区空闲。
 529   1      }
 530          ////////////////////////End of function//////////////////////////////
 531          
 532          /********************************************************************
 533          函数功能：根据pData和SendLength将数据发送到端点0的函数。
 534          入口参数：无。
 535          返    回：无。
 536          备    注：无。
 537          ********************************************************************/
 538          void UsbEp0SendData(void)
 539          {
 540   1       //将数据写到端点中去准备发送
 541   1       //写之前要先判断一下需要发送的数据是否比端点0
 542   1       //最大长度大，如果超过端点大小，则一次只能发送
 543   1       //最大包长的数据。端点0的最大包长在DeviceDescriptor[7]
 544   1       if(SendLength>DeviceDescriptor[7])
 545   1       {
 546   2        //按最大包长度发送
 547   2        D12WriteEndpointBuffer(1,DeviceDescriptor[7],pSendData);
 548   2        //发送后剩余字节数减少最大包长
 549   2        SendLength-=DeviceDescriptor[7];
 550   2        //发送一次后指针位置要调整
 551   2        pSendData+= DeviceDescriptor[7];
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 10  

 552   2       }
 553   1       else
 554   1       {
 555   2        if(SendLength!=0)
 556   2        {
 557   3         //不够最大包长，可以直接发送
 558   3         D12WriteEndpointBuffer(1,SendLength,pSendData);
 559   3         //发送完毕后，SendLength长度变为0
 560   3         SendLength=0;
 561   3        }
 562   2        else //如果要发送的数据包长度为0
 563   2        {
 564   3         if(NeedZeroPacket==1) //如果需要发送0长度数据
 565   3         {
 566   4          D12WriteEndpointBuffer(1,0,pSendData); //发送0长度数据包
 567   4          NeedZeroPacket=0; //清需要发送0长度数据包标志
 568   4         }
 569   3        }
 570   2       }
 571   1      }
 572          ////////////////////////End of function//////////////////////////////
 573          
 574          /********************************************************************
 575          函数功能：端点0输出中断处理函数。
 576          入口参数：无。
 577          返    回：无。
 578          备    注：无。
 579          ********************************************************************/
 580          void UsbEp0Out(void)
 581          {
 582   1      #ifdef DEBUG0
 583   1       Prints("USB端点0输出中断。\r\n");
 584   1      #endif
 585   1       //读取端点0输出最后传输状态，该操作清除中断标志
 586   1       //并判断第5位是否为1，如果是，则说明是建立包
 587   1       if(D12ReadEndpointLastStatus(0)&0x20)
 588   1       {
 589   2        D12ReadEndpointBuffer(0,16,Buffer); //读建立过程数据
 590   2        D12AcknowledgeSetup(); //应答建立包
 591   2        D12ClearBuffer(); //清缓冲区
 592   2        //将缓冲数据填到设备请求的各字段中
 593   2        bmRequestType=Buffer[0];
 594   2        bRequest=Buffer[1];
 595   2        wValue=Buffer[2]+(((uint16)Buffer[3])<<8);
 596   2        wIndex=Buffer[4]+(((uint16)Buffer[5])<<8);
 597   2        wLength=Buffer[6]+(((uint16)Buffer[7])<<8);
 598   2        //下面的代码判断具体的请求，并根据不同的请求进行相关操作
 599   2        //如果D7位为1，则说明是输入请求
 600   2        if((bmRequestType&0x80)==0x80)
 601   2        {
 602   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 603   3         //0为标准请求，1为类请求，2为厂商请求。
 604   3         switch((bmRequestType>>5)&0x03)
 605   3         {
 606   4          case 0:  //标准请求
 607   4           #ifdef DEBUG0
 608   4            Prints("USB标准输入请求：");
 609   4           #endif
 610   4           //USB协议定义了几个标准输入请求，我们实现这些标准请求即可
 611   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 612   4           //事实上，我们还需要对接收者进行散转，因为不同的请求接收者
 613   4           //是不一样的。接收者在bmRequestType的D4~D0位中定义。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 11  

 614   4           //我们这里为了简化操作，有些就省略了对接收者的判断。
 615   4           //例如获取描述符的请求，只根据描述符的类型来区别。
 616   4           switch(bRequest)
 617   4           {
 618   5            case GET_CONFIGURATION: //获取配置
 619   5             #ifdef DEBUG0
 620   5              Prints("获取配置。\r\n");
 621   5             #endif
 622   5            break;
 623   5            
 624   5            case GET_DESCRIPTOR:  //获取描述符
 625   5             #ifdef DEBUG0
 626   5              Prints("获取描述符――");
 627   5             #endif
 628   5             //对描述符类型进行散转，对于全速设备，
 629   5             //标准请求只支持发送到设备的设备、配置、字符串三种描述符
 630   5             switch((wValue>>8)&0xFF)
 631   5              {
 632   6               case DEVICE_DESCRIPTOR: //设备描述符
 633   6                #ifdef DEBUG0
 634   6                 Prints("设备描述符。\r\n");
 635   6                #endif
 636   6                pSendData=DeviceDescriptor;  //需要发送的数据
 637   6                //判断请求的字节数是否比实际需要发送的字节数多
 638   6                //这里请求的是设备描述符，因此数据长度就是
 639   6                //DeviceDescriptor[0]。如果请求的比实际的长，
 640   6                //那么只返回实际长度的数据
 641   6                if(wLength>DeviceDescriptor[0])
 642   6                {
 643   7                 SendLength=DeviceDescriptor[0];
 644   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 645   7                 {
 646   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 647   8                 }
 648   7                }
 649   6                else
 650   6                {
 651   7                 SendLength=wLength;
 652   7                }
 653   6                //将数据通过EP0返回
 654   6                UsbEp0SendData();
 655   6               break;
 656   6               
 657   6               case CONFIGURATION_DESCRIPTOR:  //配置描述符
 658   6                #ifdef DEBUG0
 659   6                 Prints("配置描述符。\r\n");
 660   6                #endif
 661   6                pSendData=ConfigurationDescriptor; //需要发送的数据为配置描述符
 662   6                //判断请求的字节数是否比实际需要发送的字节数多
 663   6                //这里请求的是配置描述符集合，因此数据长度就是
 664   6                //ConfigurationDescriptor[3]*256+ConfigurationDescriptor[2]。
 665   6                //如果请求的比实际的长，那么只返回实际长度的数据
 666   6                SendLength=ConfigurationDescriptor[3];
 667   6                SendLength=SendLength*256+ConfigurationDescriptor[2];
 668   6                if(wLength>SendLength)
 669   6                {
 670   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 671   7                 {
 672   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 673   8                 }
 674   7                }
 675   6                else
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 12  

 676   6                {
 677   7                 SendLength=wLength;
 678   7                }
 679   6                //将数据通过EP0返回
 680   6                UsbEp0SendData();
 681   6               break;
 682   6               
 683   6               case STRING_DESCRIPTOR:  //字符串描述符
 684   6                #ifdef DEBUG0
 685   6                 Prints("字符串描述符");
 686   6                #endif
 687   6                switch(wValue&0xFF)  //根据wValue的低字节（索引值）散转
 688   6                {
 689   7                 case 0:  //获取语言ID
 690   7                  #ifdef DEBUG0
 691   7                   Prints("(语言ID)。\r\n");
 692   7                  #endif
 693   7                  pSendData=LanguageId;
 694   7                  SendLength=LanguageId[0];
 695   7                 break;
 696   7                 
 697   7                 case 1:  //厂商字符串的索引值为1，所以这里为厂商字符串
 698   7                 #ifdef DEBUG0
 699   7                   Prints("(厂商描述)。\r\n");
 700   7                  #endif
 701   7                  pSendData=ManufacturerStringDescriptor;
 702   7                  SendLength=ManufacturerStringDescriptor[0];
 703   7                 break;
 704   7                 
 705   7                 case 2:  //产品字符串的索引值为2，所以这里为产品字符串
 706   7                 #ifdef DEBUG0
 707   7                   Prints("(产品描述)。\r\n");
 708   7                  #endif
 709   7                  pSendData=ProductStringDescriptor;
 710   7                  SendLength=ProductStringDescriptor[0];
 711   7                 break;
 712   7                 
 713   7                 case 3:  //产品序列号的索引值为3，所以这里为序列号
 714   7                 #ifdef DEBUG0
 715   7                   Prints("(产品序列号)。\r\n");
 716   7                  #endif
 717   7                  pSendData=SerialNumberStringDescriptor;
 718   7                  SendLength=SerialNumberStringDescriptor[0];
 719   7                 break;
 720   7                 
 721   7                 default :
 722   7                  #ifdef DEBUG0
 723   7                   Prints("(未知的索引值)。\r\n");
 724   7                  #endif
 725   7                  //对于未知索引值的请求，返回一个0长度的包
 726   7                  SendLength=0;
 727   7                  NeedZeroPacket=1;
 728   7                 break;
 729   7                }
 730   6                //判断请求的字节数是否比实际需要发送的字节数多
 731   6                //如果请求的比实际的长，那么只返回实际长度的数据
 732   6                if(wLength>SendLength)
 733   6                {
 734   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 735   7                 {
 736   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 737   8                 }
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 13  

 738   7                }
 739   6                else
 740   6                {
 741   7                 SendLength=wLength;
 742   7                }
 743   6                //将数据通过EP0返回
 744   6                UsbEp0SendData();         
 745   6               break;
 746   6      
 747   6               case REPORT_DESCRIPTOR:  //报告描述符
 748   6                #ifdef DEBUG0
 749   6                 Prints("报告描述符。\r\n");
 750   6                #endif
 751   6                pSendData=ReportDescriptor; //需要发送的数据为报告描述符
 752   6                SendLength=sizeof(ReportDescriptor); //需要返回的数据长度         
 753   6                //判断请求的字节数是否比实际需要发送的字节数多
 754   6                //如果请求的比实际的长，那么只返回实际长度的数据
 755   6                if(wLength>SendLength)
 756   6                {
 757   7                 if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 758   7                 {
 759   8                  NeedZeroPacket=1; //需要返回0长度的数据包
 760   8                 }
 761   7                }
 762   6                else
 763   6                {
 764   7                 SendLength=wLength;
 765   7                }
 766   6                //将数据通过EP0返回
 767   6                UsbEp0SendData();
 768   6               break;
 769   6                       
 770   6               default:  //其它描述符
 771   6                #ifdef DEBUG0
 772   6                 Prints("其他描述符，描述符代码：");
 773   6                 PrintHex((wValue>>8)&0xFF);
 774   6                 Prints("\r\n");
 775   6                #endif
 776   6               break;
 777   6              }
 778   5             break;
 779   5            
 780   5            case GET_INTERFACE: //获取接口
 781   5             #ifdef DEBUG0
 782   5              Prints("获取接口。\r\n");
 783   5             #endif
 784   5            break;
 785   5            
 786   5            case GET_STATUS: //获取状态
 787   5             #ifdef DEBUG0
 788   5              Prints("获取状态。\r\n");
 789   5             #endif
 790   5            break;
 791   5            
 792   5            case SYNCH_FRAME: //同步帧
 793   5             #ifdef DEBUG0
 794   5              Prints("同步帧。\r\n");
 795   5             #endif
 796   5            break;
 797   5            
 798   5            default:  //未定义的标准请求
 799   5             #ifdef DEBUG0
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 14  

 800   5              Prints("错误：未定义的标准输入请求。\r\n");
 801   5             #endif       
 802   5            break;
 803   5           }
 804   4          break;
 805   4          
 806   4          case 1:  //类请求
 807   4           #ifdef DEBUG0
 808   4            Prints("USB类输入请求：\r\n");
 809   4           #endif
 810   4          break;
 811   4          
 812   4          case 2:  //厂商请求
 813   4           #ifdef DEBUG0
 814   4            Prints("USB厂商输入请求：\r\n");
 815   4           #endif
 816   4          break;
 817   4          
 818   4          default: //未定义的请求。这里只显示一个报错信息。
 819   4           #ifdef DEBUG0
 820   4            Prints("错误：未定义的输入请求。\r\n");
 821   4           #endif
 822   4          break;
 823   4         }
 824   3        }
 825   2        //否则说明是输出请求
 826   2        else //if(bmRequestType&0x80==0x80)之else
 827   2        {
 828   3         //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 829   3         //0为标准请求，1为类请求，2为厂商请求。
 830   3         switch((bmRequestType>>5)&0x03)
 831   3         {
 832   4          case 0:  //标准请求
 833   4           #ifdef DEBUG0
 834   4            Prints("USB标准输出请求：");
 835   4           #endif
 836   4           //USB协议定义了几个标准输出请求，我们实现这些标准请求即可
 837   4           //请求的代码在bRequest中，对不同的请求代码进行散转
 838   4           switch(bRequest)
 839   4           {
 840   5            case CLEAR_FEATURE: //清除特性
 841   5             #ifdef DEBUG0
 842   5              Prints("清除特性。\r\n");
 843   5             #endif
 844   5            break;
 845   5            
 846   5            case SET_ADDRESS:  //设置地址
 847   5             #ifdef DEBUG0
 848   5              Prints("设置地址。地址为：");
 849   5              PrintHex(wValue&0xFF); //显示所设置的地址
 850   5              Prints("\r\n");
 851   5             #endif
 852   5             D12SetAddress(wValue&0xFF); //wValue中的低字节是设置的地址值
 853   5             //设置地址没有数据过程，直接进入到状态过程，返回一个0长度的数据包
 854   5             SendLength=0;
 855   5             NeedZeroPacket=1;
 856   5             //将数据通过EP0返回
 857   5             UsbEp0SendData();
 858   5            break;
 859   5            
 860   5            case SET_CONFIGURATION: //设置配置
 861   5             #ifdef DEBUG0
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 15  

 862   5              Prints("设置配置。\r\n");
 863   5             #endif
 864   5             //使能非0端点。非0端点只有在设置为非0的配置后才能使能。
 865   5             //wValue的低字节为配置的值，如果该值为非0，才能使能非0端点。
 866   5             //保存当前配置值
 867   5             ConfigValue=wValue&0xFF;
 868   5             D12SetEndpointEnable(ConfigValue);
 869   5             //返回一个0长度的状态数据包
 870   5             SendLength=0;
 871   5             NeedZeroPacket=1;
 872   5             //将数据通过EP0返回
 873   5             UsbEp0SendData();
 874   5            break;
 875   5            
 876   5            case SET_DESCRIPTOR: //设置描述符
 877   5             #ifdef DEBUG0
 878   5              Prints("设置描述符。\r\n");
 879   5             #endif
 880   5            break;
 881   5            
 882   5            case SET_FEATURE: //设置特性
 883   5             #ifdef DEBUG0
 884   5              Prints("设置特性。\r\n");
 885   5             #endif
 886   5            break;
 887   5      
 888   5            case SET_INTERFACE: //设置接口
 889   5             #ifdef DEBUG0
 890   5              Prints("设置接口。\r\n");
 891   5             #endif
 892   5            break;      
 893   5            
 894   5            default:  //未定义的标准请求
 895   5             #ifdef DEBUG0
 896   5              Prints("错误：未定义的标准输出请求。\r\n");
 897   5             #endif       
 898   5            break;
 899   5           }
 900   4          break;
 901   4          
 902   4          case 1:  //类请求
 903   4           #ifdef DEBUG0
 904   4            Prints("USB类输出请求：");
 905   4           #endif
 906   4           switch(bRequest)
 907   4           {
 908   5            case SET_IDLE:
 909   5             #ifdef DEBUG0
 910   5              Prints("设置空闲。\r\n");
 911   5             #endif
 912   5             //只需要返回一个0长度的数据包即可
 913   5             SendLength=0;
 914   5             NeedZeroPacket=1;
 915   5             //将数据通过EP0返回
 916   5             UsbEp0SendData();
 917   5            break;
 918   5            
 919   5            default:
 920   5             #ifdef DEBUG0
 921   5              Prints("未知请求。\r\n");
 922   5             #endif
 923   5            break;
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 16  

 924   5           }
 925   4          break;
 926   4          
 927   4          case 2:  //厂商请求
 928   4           #ifdef DEBUG0
 929   4            Prints("USB厂商输出请求：\r\n");
 930   4           #endif
 931   4          break;
 932   4          
 933   4          default: //未定义的请求。这里只显示一个报错信息。
 934   4           #ifdef DEBUG0
 935   4            Prints("错误：未定义的输出请求。\r\n");
 936   4           #endif
 937   4          break;
 938   4         }
 939   3        }
 940   2       }
 941   1       //普通数据输出
 942   1       else //if(D12ReadEndpointLastStatus(0)&0x20)之else
 943   1       {
 944   2        D12ReadEndpointBuffer(0,16,Buffer);
 945   2        D12ClearBuffer();
 946   2       }
 947   1      }
 948          ////////////////////////End of function//////////////////////////////
 949          
 950          /********************************************************************
 951          函数功能：端点0输入中断处理函数。
 952          入口参数：无。
 953          返    回：无。
 954          备    注：无。
 955          ********************************************************************/
 956          void UsbEp0In(void)
 957          {
 958   1      #ifdef DEBUG0
 959   1       Prints("USB端点0输入中断。\r\n");
 960   1      #endif
 961   1       //读最后发送状态，这将清除端点0的中断标志位
 962   1       D12ReadEndpointLastStatus(1);
 963   1       //发送剩余的字节数
 964   1       UsbEp0SendData();
 965   1      }
 966          ////////////////////////End of function//////////////////////////////
 967          
 968          /********************************************************************
 969          函数功能：端点1输出中断处理函数。
 970          入口参数：无。
 971          返    回：无。
 972          备    注：无。
 973          ********************************************************************/
 974          void UsbEp1Out(void)
 975          {
 976   1      #ifdef DEBUG0
 977   1       Prints("USB端点1输出中断。\r\n");
 978   1      #endif
 979   1      }
 980          ////////////////////////End of function//////////////////////////////
 981          
 982          /********************************************************************
 983          函数功能：端点1输入中断处理函数。
 984          入口参数：无。
 985          返    回：无。
C51 COMPILER V7.06   USBCORE                                                               11/16/2008 15:59:43 PAGE 17  

 986          备    注：无。
 987          ********************************************************************/
 988          void UsbEp1In(void)
 989          {
 990   1      #ifdef DEBUG0
 991   1       Prints("USB端点1输入中断。\r\n");
 992   1      #endif
 993   1       //读最后发送状态，这将清除端点1输入的中断标志位
 994   1       D12ReadEndpointLastStatus(3);
 995   1       //端点1输入处于空闲状态
 996   1       Ep1InIsBusy=0;
 997   1      }
 998          ////////////////////////End of function//////////////////////////////
 999          
1000          /********************************************************************
1001          函数功能：端点2输出中断处理函数。
1002          入口参数：无。
1003          返    回：无。
1004          备    注：无。
1005          ********************************************************************/
1006          void UsbEp2Out(void)
1007          {
1008   1      #ifdef DEBUG0
1009   1       Prints("USB端点2输出中断。\r\n");
1010   1      #endif
1011   1      }
1012          ////////////////////////End of function//////////////////////////////
1013          
1014          /********************************************************************
1015          函数功能：端点2输入中断处理函数。
1016          入口参数：无。
1017          返    回：无。
1018          备    注：无。
1019          ********************************************************************/
1020          void UsbEp2In(void)
1021          {
1022   1      #ifdef DEBUG0
1023   1       Prints("USB端点2输入中断。\r\n");
1024   1      #endif
1025   1      }
1026          ////////////////////////End of function//////////////////////////////


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1233    ----
   CONSTANT SIZE    =   1000    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16    ----
   IDATA SIZE       =     16    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
