// MyUsbLowerFilterDriver.cpp
//
// Generated by DriverWizard 3.2.0 (Build 2485)
// Requires DDK and DriverWorks
// File created on 8/28/2008
//
// This source file contains the implementation of a subclass of KDriver.
// WDM drivers implement a subclass of KDriver and override member
// function DriverEntry and AddDevice.
//

#define VDW_MAIN
#include <vdw.h>
#include "function.h"
#include "MyUsbLowerFilterDriver.h"
#include "MyUsbLowerFilterDevice.h"

#pragma hdrstop("MyUsbLowerFilter.pch")

// Memory allocation pool tag
// Override this value using the global function SetPoolTag().
POOLTAG DefaultPoolTag('sUyM');

// Global driver trace object
// TODO:	Use KDebugOnlyTrace if you want trace messages
//			to appear only in checked builds.  Use KTrace if
//			you want trace messages to always appear.  Call
//			method SetOutputLevel to set the output threshold.
KDebugOnlyTrace T("MyUsbLowerFilter");

///////////////////////////////////////////////////////////////////////////////////////////////////
// Begin INIT section
#pragma code_seg("INIT")

DECLARE_DRIVER_CLASS(MyUsbLowerFilterDriver, NULL)

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDriver::DriverEntry
//		This routine is called when the driver is loaded.  Drivers often 
//		read the registry for configurable parameters.
//
//	Arguments:
//		IN	RegistryPath
//				pointer to a unicode string representing the path to
//				driver-specific key in the registry.  Look for:
//				HKLM\SYSTEM\CurrentControlSet\Services\MyUsbLowerFilter
//
//	Return Value:
//		NTSTATUS code
//
NTSTATUS MyUsbLowerFilterDriver::DriverEntry(PUNICODE_STRING RegistryPath)
{
	T.Trace(TraceInfo, __FUNCTION__"++. Compiled at " __TIME__ " on " __DATE__ "\n");

#ifdef DBG
	//DbgBreakPoint();
#endif

	NTSTATUS status = STATUS_SUCCESS;

	m_Unit = 0;

	// This macro suppresses compiler warning for unreferenced variable.
	// If you reference this parameter, simply remove the macro.
	UNREFERENCED_PARAMETER(RegistryPath);

	T.Trace(TraceInfo, __FUNCTION__"--. STATUS %x\n", status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
#pragma code_seg()	// end INIT code
///////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDriver::AddDevice
//		This routine is called when the system detects a device for which this
//		driver is filtering.  This function creates a Filter Device Object that
//		enables the driver to filter requests for another device object.
//
//	Arguments:
//		IN Pdo
//				Physical Device Object.  This is a pointer to a system device
//				object.
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS MyUsbLowerFilterDriver::AddDevice(PDEVICE_OBJECT Pdo)
{
	T.Trace(TraceInfo, __FUNCTION__"++.\n");

	NTSTATUS status = STATUS_SUCCESS;

	// Create MyUsbLowerFilterDevice using a form of "placement" new
	// that is a member operator of KDevice.  This will use storage
	// in the system device object extension to store the class instance.
	MyUsbLowerFilterDevice* pDevice = new (
            NULL,                    // no name
			FILE_DEVICE_UNKNOWN,
            NULL,                    // no name
			0,
			0
			)
		MyUsbLowerFilterDevice(Pdo, m_Unit);

	if (pDevice == NULL)
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
	}
	else
	{
		status = pDevice->ConstructorStatus();
		if (!NT_SUCCESS(status))
		{
			delete pDevice;
		}
		else
		{
			m_Unit++;
		}
	}

	T.Trace(TraceInfo, __FUNCTION__"--. STATUS %x\n", status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDriver::Unload
//		This routine is called when the driver is unloaded.  Delete any
//		device objects created in DriverEntry by calling base class method
//		Unload().  Cleanup any allocations made for registry values in
//		DriverEntry.  
//
//	Arguments:
//		none
//
//	Return Value:
//		none
//
VOID MyUsbLowerFilterDriver::Unload(VOID)
{
	T.Trace(TraceInfo, __FUNCTION__"++.\n");

	// If you don't need to perform any functions
	// except to call the base class KDriver::Unload(),
	// then this entire routine may be safely deleted.

    // Call base class to delete all devices.
	KDriver::Unload();

	T.Trace(TraceInfo, __FUNCTION__"--.\n");
}
