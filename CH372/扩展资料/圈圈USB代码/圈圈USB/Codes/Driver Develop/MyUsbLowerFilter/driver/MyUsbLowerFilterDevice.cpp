/******************************************************************
   本程序只供学习使用，未经作者许可，不得用于其它任何用途
			
        欢迎访问我的USB专区：http://group.ednchina.com/93/
        欢迎访问我的blog：   http://www.ednchina.com/blog/computer00
                             http://computer00.21ic.org

作者：电脑圈圈
建立日期: 2008.08.27
修改日期: 2008.08.29
版本：V1.1
版权所有，盗版必究。
Copyright(C) 电脑圈圈 2008-2018
All rights reserved            
*******************************************************************/

// MyUsbLowerFilterDevice.cpp
//
// Generated by DriverWizard 3.2.0 (Build 2485)
// Requires DDK and DriverWorks
// File created on 8/28/2008
//
// This source file contains the implementation of a subclass of KWdmFilterDevice.
// WDM filter drivers declare a subclass of KWdmFilterDevice and override member
// functions to filter requests (IRPs) from the system.  The default behavior
// of base class methods is to pass all IRPs thru to the lower driver.  Only
// override those IRP handlers to add custom processing for a particular IRP.
//

#include <vdw.h>
#include <Kwdmfltr.cpp>
#include <kusb.h>
#include "MyUsbLowerFilterDevice.h"

#pragma hdrstop("MyUsbLowerFilter.pch")

ULONG MyCount=0;

// Global driver trace object
// TODO:	Use KDebugOnlyTrace if you want trace messages
//			to appear only in checked builds.  Use KTrace if
//			you want trace messages to always appear.  Call
//			method SetOutputLevel to set the output threshold.
// TODO:	For any KIrp, to display the contents of the IRP
//			in a formatted way, use the KTrace << operator:
//				T << I;
extern KDebugOnlyTrace T;

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDevice::MyUsbLowerFilterDevice
//		This is the constructor for the class representing the Filter
//		Device Object, or FiDO.  It is derived from KWdmFilterDevice, which builds
//		in automatic dispatching of IRPs to virtual member functions.  The default
//		behavior of the base class virtual member functions (IRP handlers) is to
//		pass-thru all requests.  It is only necessary to override virtual member
//		functions to add custom processing to an IRP handler.
//		The object being constructed contains a data member (m_Lower) of type
//		KPnpLowerDevice. By initializing it, the driver binds the Filter 
//		Device Object to the device stack.
//
//	Arguments:
//		IN	Pdo
//				Physical Device Object.  This is a pointer to a system
//				device object that represents the physical device.
//
//		IN	Unit
//				Unit number to append to the device's base device name 
//				to distinguish multiple units of this device type.
//
//	Return Value:
//		none
//
MyUsbLowerFilterDevice::MyUsbLowerFilterDevice(PDEVICE_OBJECT Pdo, ULONG Unit) :
	KWdmFilterDevice(Pdo, NULL),
	m_Unit(Unit)
{
	if (!NT_SUCCESS(m_ConstructorStatus))
	{
		T.Trace(TraceError, __FUNCTION__": Failed to create device MyUsbLowerFilterDevice"
			" unit number %d status %x\n", Unit, m_ConstructorStatus);
		ASSERT(FALSE);
		return;
	}

	// Initialize the lower device
	m_Lower.Initialize(this, Pdo);

	// Attach the filter
	m_ConstructorStatus = AttachFilter(&m_Lower); 

	// Check the status
	if ( !NT_SUCCESS(m_ConstructorStatus) )
	{
		T.Trace(TraceError, __FUNCTION__": Failed to attach filter device MyUsbLowerFilterDevice"
			" unit number %d status %x\n", Unit, m_ConstructorStatus);
		ASSERT(FALSE);
		return;
	}

	// Initialize the Filter Power Policy settings 
	SetFilterPowerPolicy();

	// Initialize the Filter PnP Policy settings 
	SetFilterPnpPolicy();
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDevice::~MyUsbLowerFilterDevice
//		This is the destructor for the class. 
//
//	Arguments:
//		none
//
//	Return Value:
//		none
//
MyUsbLowerFilterDevice::~MyUsbLowerFilterDevice()
{
}

void DispUrbInf(PURB p)
{
	ULONG i,j;

	T << "URB Length:";
	T << p->UrbControlDescriptorRequest.Hdr.Length;
	T << "\nURB Function:";
	T << p->UrbControlDescriptorRequest.Hdr.Function;
	T << "\nURB Status:";
	T << p->UrbControlDescriptorRequest.Hdr.Status;
	T << "\nURB UsbdDeviceHandle:";
	T << p->UrbControlDescriptorRequest.Hdr.UsbdDeviceHandle;
	T << "\nURB UsbdFlags:";
	T << p->UrbControlDescriptorRequest.Hdr.UsbdFlags;

	j=p->UrbControlDescriptorRequest.TransferBufferLength;
	T << "\nURB TransferBufferLength:";
	T << j;
	T << "\nURB TransferBufferData:";
	for(i=0;i<j;i++)
	{
		T << ((UCHAR*)(p->UrbControlDescriptorRequest.TransferBuffer))[i];
		T << " ";
		if((i%16)==0)
		{
			T << "\n";
		}
	}
	T << "\nURB TransferBuffer:";
	T << p->UrbControlDescriptorRequest.TransferBuffer;	
	T << "\nURB DescriptorType:";
	T << p->UrbControlDescriptorRequest.DescriptorType;	
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDevice::IrpCompletionRoutine
//		Completion Handler for IRPs
//		This routine is called when the lower driver completes the request
//
//	Arguments:
//		IN	I 
//			the IRP completed by lower driver
//
//	Return Value:
//		NTSTATUS 
//			Result returned from lower device
//
NTSTATUS MyUsbLowerFilterDevice::IrpCompletionRoutine(KIrp I)
{
 NTSTATUS status = I.Status();

 //T.Trace(TraceInfo, __FUNCTION__" IRP %p, STATUS %x\n", I, status);

 // TODO: Add driver specific code to process the IRP that the lower 
 // device has completed.
 
 UCHAR *pBuf;
 ULONG Len;
 
 T<<"进入完成函数\n";

 PURB pUrb=I.Urb(CURRENT); //获取当前IRP中的URB

 if(pUrb!=NULL) //如果pUrb有效
 {
  switch(pUrb->UrbHeader.Function) //对功能代码散转
  {
   //如果是控制传输(注意：当获取描述符的IRP完成时，功能代码会变成控制传输)
   case URB_FUNCTION_CONTROL_TRANSFER:  //值为0x08
    //判断描述符类型是否为报告描述符(0x22)
    if(pUrb->UrbControlDescriptorRequest.DescriptorType==0x22)
    {
     T<<"获取报告描述符完成\n";
     //获取缓冲区地址
     pBuf=(UCHAR*)pUrb->UrbControlDescriptorRequest.TransferBuffer;
     //获取传输的长度
     Len=pUrb->UrbControlDescriptorRequest.TransferBufferLength;
     if(Len==65) //说明报告描述符长度正确，因为我们的键盘报告描述符为65字节
     {
      //原来的报告描述符第四字节为0x06，表示集合用于键盘，这里改成0xFF，为自定义
      T<<"报告描述符第4字节被修改为0xFF\n";
      pBuf[3]=0xFF;
      //原来的报告描述符第62字节为0x03，表示附加字段的大小为3bit，
      //上面已经定义了5个bit，一共8bit，即1字节。现在需要再增加7字，
      //即增加7*8=56bit，加上原来的3bit为59bit，因此修改pBuf[61]为59。
      pBuf[61]=59; //这样整个输出报告就是8字节的了
      T<<"报告描述符第62字节被修改为59\n";
     }
    }
   break;
   
   //如果是批量或中断传输
   case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER: //值为0x09
    //如果为输入请求(TransferFlags的最低位为传输方向)
    if((pUrb->UrbBulkOrInterruptTransfer.TransferFlags)&0x01)
    {
     T<<"批量或中断读数据完成\n";
     //获取缓冲区地址
     pBuf=(UCHAR*)pUrb->UrbBulkOrInterruptTransfer.TransferBuffer;
     //获取传输的长度
     Len=pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;
     if(Len==8)  //如果返回的是8字节数据
     {
      unsigned int i;
      //用来保存按键的状态
      UCHAR KeyStatus;
      //在USB键盘程序中，KEY1、KEY2、KEY3刚好对应着报告第一字节的低3位
      //所以这里可以直接将pBuf[0]的低3位赋值给KeyStatus
      KeyStatus=(pBuf[0])&(0x07);
      //第二字节(即pBuf[1])为保留字节
      //剩下的6个字节(pBuf[2]~pBuf[7])为6个键码，当某个键按下时会出现对应的键码
      //KEY4对应的键码为0x59，KEY5对应的键码为0x5A，KEY6对应的键码为0x5B，
      //KEY7对应的键码为0x39，KEY8对应的键码为0x53。在这6个字节中查找是否有
      //对应的键码出现就知道该键是否被按下了
      for(i=2;i<8;i++)
      {
       if(pBuf[i]==0x59)KeyStatus|=0x08; //KEY4
       if(pBuf[i]==0x5A)KeyStatus|=0x10; //KEY5
       if(pBuf[i]==0x5B)KeyStatus|=0x20; //KEY6
       if(pBuf[i]==0x39)KeyStatus|=0x40; //KEY7
       if(pBuf[i]==0x53)KeyStatus|=0x80; //KEY8
      }
      pBuf[0]=KeyStatus; //设置按键情况
      MyCount++; //计数器加1
      //pBuf[1]~pBuf[4]为计数器值
      pBuf[1]=(UCHAR)(MyCount&0xFF);       //最低字节
      pBuf[2]=(UCHAR)((MyCount>>8)&0xFF);  //次低字节
      pBuf[3]=(UCHAR)((MyCount>>16)&0xFF); //次高字节
      pBuf[4]=(UCHAR)((MyCount>>24)&0xFF); //最高字节
      //pBuf[5]~[7]设置为0
      pBuf[5]=0;
      pBuf[6]=0;
      pBuf[7]=0;
      T<<"修改输入报告完毕\n";
     }
    }
   break;

   default:
   break;
  }
 }

 return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDevice::Read
//		Dispatch routine for IRP_MJ_READ requests.  
//
//	Arguments:
//		IN I 
//			the read IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS MyUsbLowerFilterDevice::Read(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	// TODO: Add driver specific code to process the IRP prior to forwarding
	// to the lower device.  Call PassThrough() to send the IRP to the lower 
	// device.  Optionally, use the commented out code to use a completion 
	// routine to process the IRP after the lower device has completed it:
	//
	// NTSTATUS = PassThrough(I, LinkTo(IrpCompletionRoutine), this);

	// This implementation simply forwards the IRP to the lower device.
	NTSTATUS status = PassThrough(I);

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDevice::Write
//		Dispatch routine for IRP_MJ_WRITE requests.  
//
//	Arguments:
//		IN I 
//			the write IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS MyUsbLowerFilterDevice::Write(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	// TODO: Add driver specific code to process the IRP prior to forwarding
	// to the lower device.  Call PassThrough() to send the IRP to the lower 
	// device.  Optionally, use the commented out code to use a completion 
	// routine to process the IRP after the lower device has completed it:
	//
	// NTSTATUS = PassThrough(I, LinkTo(IrpCompletionRoutine), this);

	// This implementation simply forwards the IRP to the lower device.
	NTSTATUS status = PassThrough(I);

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDevice::InternalDeviceControl
//		Dispatch routine for IRP_MJ_INTERNAL_DEVICE_CONTROL requests.  
//
//	Arguments:
//		IN I 
//			the internal ioctl IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS MyUsbLowerFilterDevice::InternalDeviceControl(KIrp I)
{
 //T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

 T<<"进入InternalDeviceControl函数\n";  //显示调试信息

 //如果Ioctl代码为IOCTL_INTERNAL_USB_SUBMIT_URB，
 //那么就是提交URB的请求，在这里判断我们需要过滤的IRP
 if(I.IoctlCode() == IOCTL_INTERNAL_USB_SUBMIT_URB)
 {
  PURB pUrb=I.Urb(CURRENT); //获取当前IRP的URB
  if(pUrb!=NULL) //如果pUrb有效
  {
   //T << *pUrb; //可以显示URB的详细信息(需要增加usbd.lib才能使用)
   T<<"URB功能代码为："; //显示URB的功能代码
   T<<pUrb->UrbHeader.Function; //获取功能代码
   T<<"\n"; //换行
   switch(pUrb->UrbHeader.Function) //对功能代码散转
   {
    //如果功能代码为从接口请求描述符(0x28)
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
     T<<"从接口获取描述符的URB\n"; //显示调试信息
     //判断请求的描述符是否为报告描述符（0x22）
     if(pUrb->UrbControlDescriptorRequest.DescriptorType==0x22)  
     {
      T<<"描述符的类型为报告描述符(0x22)\n"; //显示调试信息
      T<<"设置完成函数\n";
						//设置完成函数为IrpCompletionRoutine
      return PassThrough(I, LinkTo(IrpCompletionRoutine), this);
     }
    break;
    
    //如果功能代码为批量或中断传输(0x09)
    case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
     T<<"批量或中断传输的URB "; //显示调试信息
     //如果为输入请求(TransferFlags的最低位为传输方向)
     if((pUrb->UrbBulkOrInterruptTransfer.TransferFlags)&0x01)
     {
      T<<"(输入传输)\n"; //显示调试信息
      T<<"设置完成函数\n";
      //设置完成函数为IrpCompletionRoutine
      return PassThrough(I, LinkTo(IrpCompletionRoutine), this);
     }
     else //为输出请求
     {
      UCHAR* pBuf; //保存缓冲区地址
      ULONG Len; //保存长度

      T<<"(输出传输)\n"; //显示调试信息
      //获取缓冲区地址
      pBuf=(UCHAR*)pUrb->UrbBulkOrInterruptTransfer.TransferBuffer;
      //获取传输的长度
      Len=pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;
      if(Len==8) //8字节的报告
      {
       if(pBuf[1]!=0) //当第二字节不为0时，要清除计数器
       {
        T<<"清除计数器\n";
        MyCount=0; //计数器清0
       }
      }
      //仅发送一字节数据
      pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength=1;
      T<<"修改输出报告完毕\n";
     }
    break;
 
    default:
    break;
   }
  }
 }

 // TODO: Add driver specific code to process the IRP prior to forwarding
 // to the lower device.  Call PassThrough() to send the IRP to the lower 
 // device.  Optionally, use the commented out code to use a completion 
 // routine to process the IRP after the lower device has completed it:
 //
 // NTSTATUS = PassThrough(I, LinkTo(IrpCompletionRoutine), this);

 // This implementation simply forwards the IRP to the lower device.

 //对于不需要过滤的IRP，将它直接传递给下层即可
 NTSTATUS status = PassThrough(I); 

 //T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

 return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDevice::OnStartDevice
//		Handler for IRP_MJ_PNP subfcn IRP_MN_START_DEVICE. 
//		There is no required functionality here, other than to pass the IRP 
//		through to the lower device. However, the handler exercises some of  
//		the other functions of KPnpLowerDevice, and displays information to 
//		the debug console about the lower device that is filtered.
//
//	Arguments:
//		IN	I
//			the start device IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS MyUsbLowerFilterDevice::OnStartDevice(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	NTSTATUS status = STATUS_SUCCESS;

	// Retrieve some interesting information about the lower device
	// that is being filtered and display to the debug console

#define BUF_LEN 256
	USHORT buf[BUF_LEN];
	ULONG PropLen;

	m_Lower.GetDeviceDescription( buf, sizeof(buf), &PropLen );
	T.Trace(TraceInfo, "Device Description: |%s|\n", buf);

	m_Lower.GetPhysicalObjectName( buf, sizeof(buf), &PropLen );
	T.Trace(TraceInfo, "PDO Name: |%s|\n", buf);

	m_Lower.GetHardwareID( buf, sizeof(buf), &PropLen );
	T.Trace(TraceInfo, "Hardware ID: |%s|\n", buf);

	m_Lower.GetClassName( buf, sizeof(buf), &PropLen );
	T.Trace(TraceInfo, "Class Name: |%s|\n", buf);

	m_Lower.GetManufacturer( buf, sizeof(buf), &PropLen );
	T.Trace(TraceInfo, "Manufacturer: |%s|\n", buf);

	PCM_RESOURCE_LIST pcrl;
	m_Lower.GetBootConfiguration( FALSE, &pcrl, &PropLen ); 

	status = PassThrough(I);

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDevice::OnStopDevice
//		Handler for IRP_MJ_PNP subfcn IRP_MN_STOP_DEVICE. 
//
//	Arguments:
//		IN	I
//			the stop device IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS MyUsbLowerFilterDevice::OnStopDevice(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	// TODO: Add driver specific code to process the IRP prior to forwarding
	// to the lower device.  Call PassThrough() to send the IRP to the lower 
	// device.  Optionally, use the commented out code to use a completion 
	// routine to process the IRP after the lower device has completed it:
	//
	// NTSTATUS = PassThrough(I, LinkTo(IrpCompletionRoutine), this);

	// This implementation simply forwards the IRP to the lower device.
	NTSTATUS status = PassThrough(I);

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDevice::OnRemoveDevice
//		Handler for IRP_MJ_PNP subfcn IRP_MN_REMOVE_DEVICE. 
//
//	Arguments:
//		IN	I
//			the remove device IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS MyUsbLowerFilterDevice::OnRemoveDevice(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	// TODO: Add driver specific code to process the IRP prior to forwarding
	// to the lower device.  Call PassThrough() to send the IRP to the lower 
	// device.  Optionally, use the commented out code to use a completion 
	// routine to process the IRP after the lower device has completed it:
	//
	// NTSTATUS = PassThrough(I, LinkTo(IrpCompletionRoutine), this);

	// This implementation simply forwards the IRP to the lower device.
	NTSTATUS status = PassThrough(I);

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDevice::OnQueryRemoveDevice
//		Handler for IRP_MJ_PNP subfcn IRP_MN_QUERY_REMOVE_DEVICE. 
//
//	Arguments:
//		IN	I
//			the query remove device IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS MyUsbLowerFilterDevice::OnQueryRemoveDevice(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	// TODO: Add driver specific code to process the IRP prior to forwarding
	// to the lower device.  Call PassThrough() to send the IRP to the lower 
	// device.  Optionally, use the commented out code to use a completion 
	// routine to process the IRP after the lower device has completed it:
	//
	// NTSTATUS = PassThrough(I, LinkTo(IrpCompletionRoutine), this);

	// This implementation simply forwards the IRP to the lower device.
	NTSTATUS status = PassThrough(I);

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDevice::OnSurpriseRemoval
//		Handler for IRP_MJ_PNP subfcn IRP_MN_SURPRISE_REMOVAL. 
//
//	Arguments:
//		IN	I
//			the surprise remove device IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS MyUsbLowerFilterDevice::OnSurpriseRemoval(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	// TODO: Add driver specific code to process the IRP prior to forwarding
	// to the lower device.  Call PassThrough() to send the IRP to the lower 
	// device.  Optionally, use the commented out code to use a completion 
	// routine to process the IRP after the lower device has completed it:
	//
	// NTSTATUS = PassThrough(I, LinkTo(IrpCompletionRoutine), this);

	// This implementation simply forwards the IRP to the lower device.
	NTSTATUS status = PassThrough(I);

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDevice::OnCancelRemoveDevice
//		Handler for IRP_MJ_PNP subfcn IRP_MN_CANCEL_REMOVE_DEVICE. 
//
//	Arguments:
//		IN	I
//			the cancel remove device IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS MyUsbLowerFilterDevice::OnCancelRemoveDevice(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	// TODO: Add driver specific code to process the IRP prior to forwarding
	// to the lower device.  Call PassThrough() to send the IRP to the lower 
	// device.  Optionally, use the commented out code to use a completion 
	// routine to process the IRP after the lower device has completed it:
	//
	// NTSTATUS = PassThrough(I, LinkTo(IrpCompletionRoutine), this);

	// This implementation simply forwards the IRP to the lower device.
	NTSTATUS status = PassThrough(I);

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDevice::OnQueryStopDevice
//		Handler for IRP_MJ_PNP subfcn IRP_MN_QUERY_STOP_DEVICE. 
//
//	Arguments:
//		IN	I
//			the query stop device IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS MyUsbLowerFilterDevice::OnQueryStopDevice(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	// TODO: Add driver specific code to process the IRP prior to forwarding
	// to the lower device.  Call PassThrough() to send the IRP to the lower 
	// device.  Optionally, use the commented out code to use a completion 
	// routine to process the IRP after the lower device has completed it:
	//
	// NTSTATUS = PassThrough(I, LinkTo(IrpCompletionRoutine), this);

	// This implementation simply forwards the IRP to the lower device.
	NTSTATUS status = PassThrough(I);

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  MyUsbLowerFilterDevice::OnCancelStopDevice
//		Handler for IRP_MJ_PNP subfcn IRP_MN_CANCEL_STOP_DEVICE. 
//
//	Arguments:
//		IN	I
//			the cancel stop device IRP
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS MyUsbLowerFilterDevice::OnCancelStopDevice(KIrp I)
{
	T.Trace(TraceInfo, __FUNCTION__"++.  IRP %p\n", I);

	// TODO: Add driver specific code to process the IRP prior to forwarding
	// to the lower device.  Call PassThrough() to send the IRP to the lower 
	// device.  Optionally, use the commented out code to use a completion 
	// routine to process the IRP after the lower device has completed it:
	//
	// NTSTATUS = PassThrough(I, LinkTo(IrpCompletionRoutine), this);

	// This implementation simply forwards the IRP to the lower device.
	NTSTATUS status = PassThrough(I);

	T.Trace(TraceInfo, __FUNCTION__"--.  IRP %p, STATUS %x\n", I, status);

	return status;
}
