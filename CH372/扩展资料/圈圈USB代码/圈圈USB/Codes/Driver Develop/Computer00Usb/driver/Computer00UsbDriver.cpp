// Computer00UsbDriver.cpp
//
// Generated by DriverWizard 3.2.0 (Build 2485)
// Requires DDK and DriverWorks
// File created on 8/22/2008
//
// This source file contains the implementation of a subclass of KDriver.
// WDM drivers implement a subclass of KDriver and override member
// function DriverEntry and AddDevice.
//

#define VDW_MAIN
#include <vdw.h>
#include <kusb.h>
#include <kusbbusintf.h>
#include "function.h"
#include "Computer00UsbDriver.h"
#include "Computer00UsbDevice.h"

#pragma hdrstop("Computer00Usb.pch")

// Memory allocation pool tag
// Override this value using the global function SetPoolTag().
POOLTAG DefaultPoolTag('pmoC');

// Global driver trace object
// TODO:	Use KDebugOnlyTrace if you want trace messages
//			to appear only in checked builds.  Use KTrace if
//			you want trace messages to always appear.  Call
//			method SetOutputLevel to set the output threshold.
KDebugOnlyTrace T("Computer00Usb");

///////////////////////////////////////////////////////////////////////////////////////////////////
// Begin INIT section
#pragma code_seg("INIT")

DECLARE_DRIVER_CLASS(Computer00UsbDriver, NULL)

///////////////////////////////////////////////////////////////////////////////////////////////////
//  Computer00UsbDriver::DriverEntry
//		This routine is called when the driver is loaded.  Drivers often 
//		read the registry for configurable parameters.
//
//	Arguments:
//		IN	RegistryPath
//				pointer to a unicode string representing the path to
//				driver-specific key in the registry.  Look for:
//				HKLM\SYSTEM\CurrentControlSet\Services\Computer00Usb
//
//	Return Value:
//		NTSTATUS code
//
NTSTATUS Computer00UsbDriver::DriverEntry(PUNICODE_STRING RegistryPath)
{
	T.Trace(TraceInfo, __FUNCTION__"++. Compiled at " __TIME__ " on " __DATE__ "\n");

#ifdef DBG
	//DbgBreakPoint();
#endif

	NTSTATUS status = STATUS_SUCCESS;

	m_Unit = 0;

	// Read driver-specific registry parameters
	LoadRegistryParameters(RegistryPath);

	T.Trace(TraceInfo, __FUNCTION__"--. STATUS %x\n", status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  Computer00UsbDriver::LoadRegistryParameters
//		Read the registry to initialize driver data members.
//
//	Arguments:
//		IN	RegistryPath
//				pointer to a unicode string representing the path to
//				driver-specific key in the registry.  Look for:
//				HKLM\SYSTEM\CurrentControlSet\Services\Computer00Usb
//
//	Return Value:
//		none
//
void Computer00UsbDriver::LoadRegistryParameters(PUNICODE_STRING RegistryPath)
{
    // Read the driver's registry values from the registry
	NTSTATUS status = STATUS_SUCCESS;

	// Initialize data members 

	UNICODE_STRING	regPath;
	KRegistryKey	RegKey;
    ULONG			length;

}

///////////////////////////////////////////////////////////////////////////////////////////////////
#pragma code_seg()	// end INIT code
///////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
//  Computer00UsbDriver::AddDevice
//		This routine is called when the system detects a device for which this
//		driver is responsible.  This function creates the Functional Device 
//		Object, or FDO. The FDO enables this driver to handle requests for  
//		the physical device.
//
//	Arguments:
//		IN Pdo
//				Physical Device Object.  This is a pointer to a system device
//				object that represents the physical device.
//
//	Return Value:
//		NTSTATUS
//
NTSTATUS Computer00UsbDriver::AddDevice(PDEVICE_OBJECT Pdo)
{
	T.Trace(TraceInfo, __FUNCTION__"++.\n");

	NTSTATUS status = STATUS_SUCCESS;

	// Create Computer00UsbDevice using a form of "placement" new
	// that is a member operator of KDevice.  This will use storage
	// in the system device object extension to store the class instance.
	Computer00UsbDevice* pDevice = new (
            NULL,                    // no name
			FILE_DEVICE_UNKNOWN,
            NULL,                    // no name
			0,
			DO_BUFFERED_IO
				| DO_POWER_INRUSH
			)
		Computer00UsbDevice(Pdo, m_Unit);

	if (pDevice == NULL)
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
	}
	else
	{
		status = pDevice->ConstructorStatus();
		if (!NT_SUCCESS(status))
		{
			delete pDevice;
		}
		else
		{
			m_Unit++;
			pDevice->ReportNewDevicePowerState(PowerDeviceD0);
		}
	}

	T.Trace(TraceInfo, __FUNCTION__"--. STATUS %x\n", status);

	return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  Computer00UsbDriver::Unload
//		This routine is called when the driver is unloaded.  Delete any
//		device objects created in DriverEntry by calling base class method
//		Unload().  Cleanup any allocations made for registry values in
//		DriverEntry.  
//
//	Arguments:
//		none
//
//	Return Value:
//		none
//
VOID Computer00UsbDriver::Unload(VOID)
{
	T.Trace(TraceInfo, __FUNCTION__"++.\n");


	// If you don't need to perform any functions
	// except to call the base class KDriver::Unload(),
	// then this entire routine may be safely deleted.

    // Call base class to delete all devices.
	KDriver::Unload();

	T.Trace(TraceInfo, __FUNCTION__"--.\n");
}
